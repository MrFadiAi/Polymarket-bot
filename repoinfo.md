This document contains the complete source code of the repository consolidated into a single file for streamlined AI analysis.
The repository contents have been processed and combined with security validation bypassed.

# Repository Overview

## About This Document
This consolidated file represents the complete codebase from the repository, 
merged into a unified document optimized for AI consumption and automated 
analysis workflows.

## Repository Information
- **Repository:** cyl19970726/poly-sdk
- **Branch:** main
- **Total Files:** 143
- **Generated:** 2026-01-09T23:23:37.974Z

## Document Structure
The content is organized in the following sequence:
1. This overview section
2. Repository metadata and information  
3. File system hierarchy
4. Repository files (when included)
5. Individual source files, each containing:
   a. File path header (## File: path/to/file)
   b. Complete file contents within code blocks

## Best Practices
- Treat this document as read-only - make changes in the original repository
- Use file path headers to navigate between different source files
- Handle with appropriate security measures as this may contain sensitive data
- This consolidated view is generated from the live repository state

## Important Notes
- Files excluded by .gitignore and configuration rules are omitted
- Binary assets are not included - refer to the file structure for complete file listings
- Default ignore patterns have been applied to filter content
- Security validation is disabled - review content for sensitive information carefully

# Repository Structure

```
cyl19970726/poly-sdk/
├── examples
│   ├── 01-basic-usage.ts
│   ├── 02-smart-money.ts
│   ├── 03-market-analysis.ts
│   ├── 04-kline-aggregation.ts
│   ├── 05-follow-wallet-strategy.ts
│   ├── 06-services-demo.ts
│   ├── 07-realtime-websocket.ts
│   ├── 08-trading-orders.ts
│   ├── 09-rewards-tracking.ts
│   ├── 10-ctf-operations.ts
│   ├── 11-live-arbitrage-scan.ts
│   ├── 12-trending-arb-monitor.ts
│   └── 13-arbitrage-service.ts
├── scripts
│   ├── api-verification
│   │   ├── 01-gamma-api.ts
│   │   ├── 02-clob-api.ts
│   │   ├── 03-data-api.ts
│   │   ├── 04-data-api-params.ts
│   │   ├── 05-verify-params-effective.ts
│   │   ├── 06-test-new-features.ts
│   │   ├── 11-test-subgraph-client.ts
│   │   └── 12-test-period-leaderboard.ts
│   ├── approvals
│   │   ├── approve-erc1155.ts
│   │   ├── approve-neg-risk-erc1155.ts
│   │   ├── approve-neg-risk.ts
│   │   ├── check-all-allowances.ts
│   │   ├── check-allowance.ts
│   │   └── check-ctf-approval.ts
│   ├── arb
│   │   ├── settle-position.ts
│   │   └── token-rebalancer.ts
│   ├── archive
│   │   ├── api-verification-history
│   │   │   ├── 07-subgraph-api.ts
│   │   │   ├── 08-subgraph-explore.ts
│   │   │   ├── 09-subgraph-correct.ts
│   │   │   └── 10-subgraph-official.ts
│   │   └── one-off-trading
│   │       ├── faze-bo3-arb.ts
│   │       └── sell-nvidia-positions.ts
│   ├── benchmark
│   │   ├── compare.ts
│   │   ├── order-latency.ts
│   │   ├── rpc-latency.ts
│   │   ├── run-all.ts
│   │   └── ws-latency.ts
│   ├── deposit
│   │   └── deposit.ts
│   ├── dip-arb
│   │   ├── auto-trade.ts
│   │   ├── example-basic.ts
│   │   ├── redeem-positions.ts
│   │   └── scan-markets.ts
│   ├── rescue
│   │   ├── rescue-contract.ts
│   │   ├── rescue-erc1155.ts
│   │   ├── test-dry-run.ts
│   │   └── verify-erc1155-transfer.ts
│   ├── research
│   │   └── research-markets.ts
│   ├── smart-money
│   │   ├── 01-e2e.ts
│   │   ├── 02-e2e-low-level.ts
│   │   ├── 03-test-service.ts
│   │   ├── 04-auto-copy-trading.ts
│   │   ├── 05-auto-copy-simple.ts
│   │   └── 06-real-copy-test.ts
│   ├── trading
│   │   ├── check-orders.ts
│   │   └── test-order.ts
│   ├── verify
│   │   ├── test-approve-trading.ts
│   │   ├── test-provider-fix.ts
│   │   ├── test-search-mcp.ts
│   │   └── verify-all-apis.ts
│   ├── wallet
│   │   ├── check-wallet-balances.ts
│   │   ├── test-wallet-operations.ts
│   │   └── verify-wallet-tools.ts
│   └── redeem.ts
├── src
│   ├── clients
│   │   ├── bridge-client.ts
│   │   ├── ctf-client.ts
│   │   ├── data-api.ts
│   │   ├── gamma-api.ts
│   │   └── subgraph.ts
│   ├── services
│   │   ├── arbitrage-service.ts
│   │   ├── authorization-service.ts
│   │   ├── binance-service.ts
│   │   ├── dip-arb-service.ts
│   │   ├── dip-arb-types.ts
│   │   ├── market-service.ts
│   │   ├── onchain-service.ts
│   │   ├── realtime-service-v2.ts
│   │   ├── smart-money-service.ts
│   │   ├── swap-service.ts
│   │   ├── trading-service.ts
│   │   └── wallet-service.ts
│   ├── utils
│   │   └── price-utils.ts
│   └── index.ts
├── package.json
└── sell2.mjs
```

================================================================================
// File: examples/01-basic-usage.ts
================================================================================
/**
 * Example 1: Basic SDK Usage
 *
 * This example demonstrates:
 * - Getting trending markets from Gamma API
 * - Getting market details from unified API (Gamma + CLOB)
 * - Getting orderbook data
 *
 * Run: npx ts-node examples/01-basic-usage.ts
 */

import { PolymarketSDK } from '../src/index.js';

async function main() {
  console.log('=== Polymarket SDK Basic Usage ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get trending markets
  console.log('1. Fetching trending markets...');
  const trendingMarkets = await sdk.gammaApi.getTrendingMarkets(5);
  console.log(`   Found ${trendingMarkets.length} trending markets:\n`);

  for (const market of trendingMarkets) {
    console.log(`   - ${market.question}`);
    console.log(`     Slug: ${market.slug}`);
    console.log(`     Volume: $${market.volume.toLocaleString()}`);
    console.log(`     24h Volume: $${market.volume24hr?.toLocaleString() || 'N/A'}`);
    console.log(`     Prices: Yes=${market.outcomePrices[0]?.toFixed(2)}, No=${market.outcomePrices[1]?.toFixed(2)}`);
    console.log('');
  }

  // 2. Get unified market details (Gamma + CLOB merged)
  if (trendingMarkets.length > 0) {
    const firstMarket = trendingMarkets[0];
    console.log(`2. Getting unified market details for: ${firstMarket.slug}`);
    const unifiedMarket = await sdk.getMarket(firstMarket.slug);
    console.log(`   Question: ${unifiedMarket.question}`);
    console.log(`   Condition ID: ${unifiedMarket.conditionId}`);
    const yesToken = unifiedMarket.tokens.find(t => t.outcome === 'Yes');
    const noToken = unifiedMarket.tokens.find(t => t.outcome === 'No');
    console.log(`   YES Token ID: ${yesToken?.tokenId}`);
    console.log(`   NO Token ID: ${noToken?.tokenId}`);
    console.log(`   YES Price: ${yesToken?.price.toFixed(4)}`);
    console.log(`   NO Price: ${noToken?.price.toFixed(4)}`);
    console.log(`   Source: ${unifiedMarket.source}`);
    console.log('');

    // 3. Get orderbook
    console.log('3. Getting orderbook...');
    const orderbook = await sdk.getOrderbook(unifiedMarket.conditionId);
    console.log(`   YES Best Bid: ${orderbook.yes.bid.toFixed(4)} (size: ${orderbook.yes.bidSize.toFixed(2)})`);
    console.log(`   YES Best Ask: ${orderbook.yes.ask.toFixed(4)} (size: ${orderbook.yes.askSize.toFixed(2)})`);
    console.log(`   YES Spread: ${(orderbook.yes.spread * 100).toFixed(2)}%`);
    console.log('');
    console.log(`   NO Best Bid: ${orderbook.no.bid.toFixed(4)} (size: ${orderbook.no.bidSize.toFixed(2)})`);
    console.log(`   NO Best Ask: ${orderbook.no.ask.toFixed(4)} (size: ${orderbook.no.askSize.toFixed(2)})`);
    console.log(`   NO Spread: ${(orderbook.no.spread * 100).toFixed(2)}%`);
    console.log('');
    console.log(`   Ask Sum (YES+NO): ${orderbook.summary.askSum.toFixed(4)}`);
    console.log(`   Bid Sum (YES+NO): ${orderbook.summary.bidSum.toFixed(4)}`);
    console.log(`   Long Arb Profit: ${(orderbook.summary.longArbProfit * 100).toFixed(3)}%`);
    console.log(`   Short Arb Profit: ${(orderbook.summary.shortArbProfit * 100).toFixed(3)}%`);
    console.log(`   Imbalance Ratio: ${orderbook.summary.imbalanceRatio.toFixed(2)}`);
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/02-smart-money.ts
================================================================================
/**
 * Example 2: Smart Money Analysis
 *
 * This example demonstrates:
 * - Getting wallet positions
 * - Getting wallet activity (trades)
 * - Getting leaderboard data
 * - Discovering active wallets from recent trades
 *
 * Run: npx ts-node examples/02-smart-money.ts
 */

import { PolymarketSDK } from '../src/index.js';

async function main() {
  console.log('=== Smart Money Analysis ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get leaderboard
  console.log('1. Fetching leaderboard (top 10)...');
  const leaderboard = await sdk.dataApi\.fetchLeaderboard({ limit: 10 });
  console.log(`   Total entries: ${leaderboard.total}`);
  console.log('   Top 10 traders:\n');

  for (const entry of leaderboard.entries.slice(0, 10)) {
    console.log(`   #${entry.rank} ${entry.address.slice(0, 8)}...${entry.address.slice(-6)}`);
    console.log(`       PnL: $${entry.pnl.toLocaleString()}`);
    console.log(`       Volume: $${entry.volume.toLocaleString()}`);
    console.log(`       Positions: ${entry.positions}, Trades: ${entry.trades}`);
  }

  // 2. Get wallet positions for top trader
  if (leaderboard.entries.length > 0) {
    const topTrader = leaderboard.entries[0].address;
    console.log(`\n2. Getting positions for top trader: ${topTrader.slice(0, 8)}...`);

    const positions = await sdk.dataApi.getPositions(topTrader);
    console.log(`   Found ${positions.length} positions:\n`);

    for (const pos of positions.slice(0, 5)) {
      console.log(`   - ${pos.title || 'Unknown Market'}`);
      console.log(`     Outcome: ${pos.outcome}`);
      console.log(`     Size: ${pos.size.toFixed(2)}`);
      console.log(`     Avg Price: ${pos.avgPrice.toFixed(4)}`);
      console.log(`     Current Price: ${pos.curPrice?.toFixed(4) || 'N/A'}`);
      console.log(`     PnL: $${pos.cashPnl?.toFixed(2) || 'N/A'} (${pos.percentPnl?.toFixed(1) || 'N/A'}%)`);
      console.log('');
    }

    // 3. Get recent activity for top trader
    console.log(`3. Getting recent activity for top trader...`);
    const activity = await sdk.dataApi.getActivity(topTrader, { limit: 10 });
    console.log(`   Found ${activity.length} recent activities:\n`);

    for (const act of activity.slice(0, 5)) {
      const date = new Date(act.timestamp).toLocaleString();
      console.log(`   - [${date}] ${act.type} ${act.side}`);
      console.log(`     Size: ${act.size.toFixed(2)} @ ${act.price.toFixed(4)}`);
      console.log(`     Value: $${(act.usdcSize || 0).toFixed(2)}`);
      console.log(`     Outcome: ${act.outcome}`);
      console.log('');
    }
  }

  // 4. Discover active wallets from recent trades
  console.log('4. Discovering active wallets from recent trades...');
  const recentTrades = await sdk.dataApi.getTrades({ limit: 100 });
  console.log(`   Fetched ${recentTrades.length} recent trades`);

  // Count trades per wallet
  const walletCounts = new Map<string, number>();
  for (const trade of recentTrades) {
    if (trade.proxyWallet) {
      walletCounts.set(
        trade.proxyWallet,
        (walletCounts.get(trade.proxyWallet) || 0) + 1
      );
    }
  }

  // Sort by count
  const sortedWallets = [...walletCounts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  console.log('   Most active wallets in recent trades:\n');
  for (const [wallet, count] of sortedWallets) {
    console.log(`   - ${wallet.slice(0, 8)}...${wallet.slice(-6)}: ${count} trades`);
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/03-market-analysis.ts
================================================================================
/**
 * Example 3: Market Analysis & Arbitrage Detection
 *
 * This example demonstrates:
 * - Getting multiple markets' orderbooks
 * - Detecting arbitrage opportunities
 * - Analyzing market depth and imbalance
 *
 * Run: npx ts-node examples/03-market-analysis.ts
 */

import { PolymarketSDK } from '../src/index.js';

async function main() {
  console.log('=== Market Analysis & Arbitrage Detection ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get trending markets for analysis
  console.log('1. Fetching trending markets...');
  const markets = await sdk.gammaApi.getTrendingMarkets(10);
  console.log(`   Found ${markets.length} trending markets\n`);

  // 2. Analyze each market for arbitrage
  console.log('2. Analyzing markets for arbitrage opportunities...\n');

  const arbitrageOpportunities = [];

  for (const market of markets) {
    try {
      console.log(`   Checking: ${market.question.slice(0, 60)}...`);

      // Get unified market for token IDs
      const unifiedMarket = await sdk.getMarket(market.conditionId);

      const yesToken = unifiedMarket.tokens.find(t => t.outcome === 'Yes');
      const noToken = unifiedMarket.tokens.find(t => t.outcome === 'No');
      if (!yesToken?.tokenId || !noToken?.tokenId) {
        console.log('     Skipping (missing token IDs)\n');
        continue;
      }

      // Get orderbook
      const orderbook = await sdk.getOrderbook(market.conditionId);

      // Check for arbitrage
      const arb = await sdk.detectArbitrage(market.conditionId, 0.001); // 0.1% threshold

      if (arb) {
        console.log(`     ** ARBITRAGE FOUND **`);
        console.log(`     Type: ${arb.type}`);
        console.log(`     Profit: ${(arb.profit * 100).toFixed(3)}%`);
        console.log(`     Action: ${arb.action}`);
        arbitrageOpportunities.push({
          market: market.question,
          slug: market.slug,
          ...arb,
        });
      } else {
        console.log(`     No arbitrage (ask sum: ${orderbook.summary.askSum.toFixed(4)}, bid sum: ${orderbook.summary.bidSum.toFixed(4)})`);
      }
      console.log('');

    } catch (error) {
      console.log(`     Error: ${(error as Error).message}\n`);
    }
  }

  // 3. Summary
  console.log('=== Summary ===\n');

  if (arbitrageOpportunities.length > 0) {
    console.log(`Found ${arbitrageOpportunities.length} arbitrage opportunities:\n`);
    for (const opp of arbitrageOpportunities) {
      console.log(`- ${opp.market.slice(0, 60)}...`);
      console.log(`  Slug: ${opp.slug}`);
      console.log(`  Type: ${opp.type}, Profit: ${(opp.profit * 100).toFixed(3)}%`);
      console.log('');
    }
  } else {
    console.log('No arbitrage opportunities found (this is normal in efficient markets)');
  }

  // 4. Analyze market depth
  console.log('\n=== Market Depth Analysis ===\n');

  for (const market of markets.slice(0, 3)) {
    try {
      const orderbook = await sdk.getOrderbook(market.conditionId);

      console.log(`Market: ${market.question.slice(0, 50)}...`);
      console.log(`  Total Bid Depth: $${orderbook.summary.totalBidDepth.toFixed(2)}`);
      console.log(`  Total Ask Depth: $${orderbook.summary.totalAskDepth.toFixed(2)}`);
      console.log(`  Imbalance Ratio: ${orderbook.summary.imbalanceRatio.toFixed(2)}`);

      if (orderbook.summary.imbalanceRatio > 1.5) {
        console.log(`  ** HIGH BUY PRESSURE (ratio > 1.5) **`);
      } else if (orderbook.summary.imbalanceRatio < 0.67) {
        console.log(`  ** HIGH SELL PRESSURE (ratio < 0.67) **`);
      }
      console.log('');
    } catch {
      // Skip errors
    }
  }

  console.log('=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/04-kline-aggregation.ts
================================================================================
/**
 * Example 4: K-Line Aggregation from Trade Data
 *
 * This example demonstrates:
 * - Getting trade history for a market
 * - Aggregating trades into K-Line (OHLCV) candles
 * - Calculating dual-token K-Lines (YES + NO)
 *
 * Run: npx ts-node examples/04-kline-aggregation.ts
 */

import { PolymarketSDK, type Trade, type KLineInterval, getIntervalMs } from '../src/index.js';

interface KLineCandle {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  tradeCount: number;
  buyVolume: number;
  sellVolume: number;
}

function aggregateToKLines(trades: Trade[], interval: KLineInterval): KLineCandle[] {
  const intervalMs = getIntervalMs(interval);
  const buckets = new Map<number, Trade[]>();

  // Group trades into time buckets
  for (const trade of trades) {
    const bucketTime = Math.floor(trade.timestamp / intervalMs) * intervalMs;
    const bucket = buckets.get(bucketTime) || [];
    bucket.push(trade);
    buckets.set(bucketTime, bucket);
  }

  // Convert buckets to candles
  const candles: KLineCandle[] = [];
  for (const [timestamp, bucketTrades] of buckets) {
    if (bucketTrades.length === 0) continue;

    // Sort by timestamp for correct open/close
    bucketTrades.sort((a, b) => a.timestamp - b.timestamp);

    const prices = bucketTrades.map((t) => t.price);
    const buyTrades = bucketTrades.filter((t) => t.side === 'BUY');
    const sellTrades = bucketTrades.filter((t) => t.side === 'SELL');

    candles.push({
      timestamp,
      open: bucketTrades[0].price,
      high: Math.max(...prices),
      low: Math.min(...prices),
      close: bucketTrades[bucketTrades.length - 1].price,
      volume: bucketTrades.reduce((sum, t) => sum + t.size * t.price, 0),
      tradeCount: bucketTrades.length,
      buyVolume: buyTrades.reduce((sum, t) => sum + t.size * t.price, 0),
      sellVolume: sellTrades.reduce((sum, t) => sum + t.size * t.price, 0),
    });
  }

  return candles.sort((a, b) => a.timestamp - b.timestamp);
}

async function main() {
  console.log('=== K-Line Aggregation from Trade Data ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get a trending market
  console.log('1. Fetching a trending market...');
  const markets = await sdk.gammaApi.getTrendingMarkets(1);

  if (markets.length === 0) {
    console.log('No trending markets found');
    return;
  }

  const market = markets[0];
  console.log(`   Selected: ${market.question}`);
  console.log(`   Condition ID: ${market.conditionId}\n`);

  // 2. Get trade history
  console.log('2. Fetching trade history...');
  const trades = await sdk.dataApi.getTradesByMarket(market.conditionId, 500);
  console.log(`   Found ${trades.length} trades\n`);

  if (trades.length === 0) {
    console.log('No trades found for this market');
    return;
  }

  // 3. Get token info
  console.log('3. Getting token info...');
  const unifiedMarket = await sdk.getMarket(market.conditionId);
  const yesToken = unifiedMarket.tokens.find(t => t.outcome === 'Yes');
  const noToken = unifiedMarket.tokens.find(t => t.outcome === 'No');
  console.log(`   YES Token: ${yesToken?.tokenId.slice(0, 16)}...`);
  console.log(`   NO Token: ${noToken?.tokenId.slice(0, 16)}...\n`);

  // 4. Separate trades by token (YES vs NO)
  const yesTrades = trades.filter((t) => t.outcomeIndex === 0 || t.outcome === 'Yes');
  const noTrades = trades.filter((t) => t.outcomeIndex === 1 || t.outcome === 'No');
  console.log(`4. Separated trades: YES=${yesTrades.length}, NO=${noTrades.length}\n`);

  // 5. Aggregate into 1-hour candles
  const interval: KLineInterval = '1h';
  console.log(`5. Aggregating into ${interval} candles...\n`);

  const yesCandles = aggregateToKLines(yesTrades, interval);
  const noCandles = aggregateToKLines(noTrades, interval);

  console.log(`   YES Token K-Lines (${yesCandles.length} candles):`);
  for (const candle of yesCandles.slice(-5)) {
    const date = new Date(candle.timestamp).toLocaleString();
    console.log(
      `   [${date}] O:${candle.open.toFixed(3)} H:${candle.high.toFixed(3)} L:${candle.low.toFixed(3)} C:${candle.close.toFixed(3)} V:$${candle.volume.toFixed(0)} (${candle.tradeCount} trades)`
    );
  }

  console.log(`\n   NO Token K-Lines (${noCandles.length} candles):`);
  for (const candle of noCandles.slice(-5)) {
    const date = new Date(candle.timestamp).toLocaleString();
    console.log(
      `   [${date}] O:${candle.open.toFixed(3)} H:${candle.high.toFixed(3)} L:${candle.low.toFixed(3)} C:${candle.close.toFixed(3)} V:$${candle.volume.toFixed(0)} (${candle.tradeCount} trades)`
    );
  }

  // 6. Calculate spread over time
  console.log('\n6. Spread Analysis (YES_price + NO_price):\n');

  // Find matching timestamps
  const yesMap = new Map(yesCandles.map((c) => [c.timestamp, c]));
  const noMap = new Map(noCandles.map((c) => [c.timestamp, c]));

  const allTimestamps = [...new Set([...yesMap.keys(), ...noMap.keys()])].sort();
  let lastYes = 0.5;
  let lastNo = 0.5;

  for (const ts of allTimestamps.slice(-5)) {
    const date = new Date(ts).toLocaleString();
    const yesCandle = yesMap.get(ts);
    const noCandle = noMap.get(ts);

    if (yesCandle) lastYes = yesCandle.close;
    if (noCandle) lastNo = noCandle.close;

    const spread = lastYes + lastNo;
    const arbOpportunity = spread < 1 ? 'LONG ARB' : spread > 1 ? 'SHORT ARB' : '';

    console.log(
      `   [${date}] YES:${lastYes.toFixed(3)} + NO:${lastNo.toFixed(3)} = ${spread.toFixed(4)} ${arbOpportunity}`
    );
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/05-follow-wallet-strategy.ts
================================================================================
/**
 * Example 5: Follow Wallet Strategy
 *
 * This example demonstrates:
 * - Tracking a smart money wallet's positions
 * - Detecting sell activity (for exit signals)
 * - Calculating sell ratio for position exit
 *
 * Run: npx ts-node examples/05-follow-wallet-strategy.ts
 */

import { PolymarketSDK, type Position, type Activity } from '../src/index.js';

interface WalletPositionTracker {
  address: string;
  position: Position;
  entryTimestamp: number;
  peakValue: number;
  cumulativeSellAmount: number;
  sellRatio: number;
}

async function detectSellActivity(
  sdk: PolymarketSDK,
  address: string,
  conditionId: string,
  sinceTimestamp: number
): Promise<{ totalSellAmount: number; sellTransactions: Activity[] }> {
  const activities = await sdk.dataApi.getActivity(address, { limit: 200, type: 'TRADE' });

  const sellTransactions = activities.filter(
    (a) =>
      a.conditionId === conditionId &&
      a.side === 'SELL' &&
      a.timestamp >= sinceTimestamp
  );

  const totalSellAmount = sellTransactions.reduce(
    (sum, a) => sum + (a.usdcSize || a.size * a.price),
    0
  );

  return { totalSellAmount, sellTransactions };
}

async function main() {
  console.log('=== Follow Wallet Strategy ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get top traders from leaderboard
  console.log('1. Getting top traders from leaderboard...');
  const leaderboard = await sdk.dataApi\.fetchLeaderboard({ limit: 5 });
  console.log(`   Found ${leaderboard.entries.length} top traders\n`);

  if (leaderboard.entries.length === 0) {
    console.log('No leaderboard entries found');
    return;
  }

  // 2. Select a trader to follow
  const traderToFollow = leaderboard.entries[0];
  console.log(`2. Following trader: ${traderToFollow.address.slice(0, 10)}...`);
  console.log(`   Rank: #${traderToFollow.rank}`);
  console.log(`   PnL: $${traderToFollow.pnl.toLocaleString()}\n`);

  // 3. Get their positions
  console.log('3. Getting positions...');
  const positions = await sdk.dataApi.getPositions(traderToFollow.address);
  console.log(`   Found ${positions.length} positions\n`);

  if (positions.length === 0) {
    console.log('No positions found for this trader');
    return;
  }

  // 4. Analyze each position for sell activity
  console.log('4. Analyzing positions for sell activity...\n');

  const trackers: WalletPositionTracker[] = [];
  const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

  for (const position of positions.slice(0, 5)) {
    console.log(`   Checking: ${position.title.slice(0, 50)}...`);

    try {
      // Get sell activity since 1 week ago
      const sellData = await detectSellActivity(
        sdk,
        traderToFollow.address,
        position.conditionId,
        oneWeekAgo
      );

      // Calculate peak value (current value + sells)
      const currentValue = position.currentValue || position.size * (position.curPrice || position.avgPrice);
      const peakValue = currentValue + sellData.totalSellAmount;

      // Calculate sell ratio
      const sellRatio = peakValue > 0 ? sellData.totalSellAmount / peakValue : 0;

      trackers.push({
        address: traderToFollow.address,
        position,
        entryTimestamp: oneWeekAgo, // Approximation
        peakValue,
        cumulativeSellAmount: sellData.totalSellAmount,
        sellRatio,
      });

      console.log(`     Current Value: $${currentValue.toFixed(2)}`);
      console.log(`     Cumulative Sells: $${sellData.totalSellAmount.toFixed(2)}`);
      console.log(`     Estimated Peak: $${peakValue.toFixed(2)}`);
      console.log(`     Sell Ratio: ${(sellRatio * 100).toFixed(1)}%`);

      // Check if 30% threshold is reached
      if (sellRatio >= 0.3) {
        console.log(`     ** EXIT SIGNAL: Sell ratio >= 30% **`);
      }
      console.log('');

    } catch (error) {
      console.log(`     Error: ${(error as Error).message}\n`);
    }
  }

  // 5. Summary
  console.log('=== Follow Wallet Summary ===\n');
  console.log(`Trader: ${traderToFollow.address.slice(0, 10)}...`);
  console.log(`Positions analyzed: ${trackers.length}\n`);

  const exitSignals = trackers.filter((t) => t.sellRatio >= 0.3);
  if (exitSignals.length > 0) {
    console.log(`EXIT SIGNALS (${exitSignals.length}):`);
    for (const signal of exitSignals) {
      console.log(`  - ${signal.position.title.slice(0, 40)}...`);
      console.log(`    Sell Ratio: ${(signal.sellRatio * 100).toFixed(1)}%`);
    }
  } else {
    console.log('No exit signals detected');
  }

  const holdingStrong = trackers.filter((t) => t.sellRatio < 0.1);
  if (holdingStrong.length > 0) {
    console.log(`\nSTRONG HOLDS (sell ratio < 10%):`);
    for (const hold of holdingStrong) {
      console.log(`  - ${hold.position.title.slice(0, 40)}...`);
      console.log(`    Outcome: ${hold.position.outcome}`);
      console.log(`    PnL: $${hold.position.cashPnl?.toFixed(2) || 'N/A'}`);
    }
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/06-services-demo.ts
================================================================================
/**
 * Example 6: Services Demo
 *
 * This example demonstrates the new service layer:
 * - WalletService for smart money analysis
 * - MarketService for K-Line and market signals
 *
 * Run: npx tsx examples/06-services-demo.ts
 */

import { PolymarketSDK, type KLineInterval } from '../src/index.js';

async function main() {
  console.log('=== Services Demo ===\n');

  const sdk = new PolymarketSDK();

  // ===== WalletService Demo =====
  console.log('--- WalletService Demo ---\n');

  // 1. Get top traders
  console.log('1. Getting top traders...');
  const topTraders = await sdk.wallets.getTopTraders(5);
  console.log(`   Found ${topTraders.length} top traders\n`);

  for (const trader of topTraders.slice(0, 3)) {
    console.log(`   Rank #${trader.rank}: ${trader.address.slice(0, 10)}...`);
    console.log(`   PnL: $${trader.pnl.toLocaleString()}`);
    console.log(`   Volume: $${trader.volume.toLocaleString()}\n`);
  }

  // 2. Get wallet profile
  if (topTraders.length > 0) {
    console.log('2. Getting wallet profile for top trader...');
    const profile = await sdk.wallets.getWalletProfile(topTraders[0].address);
    console.log(`   Address: ${profile.address.slice(0, 10)}...`);
    console.log(`   Total PnL: $${profile.totalPnL.toFixed(2)}`);
    console.log(`   Smart Score: ${profile.smartScore}/100`);
    console.log(`   Position Count: ${profile.positionCount}`);
    console.log(`   Last Active: ${profile.lastActiveAt.toLocaleString()}\n`);
  }

  // 3. Discover active wallets
  console.log('3. Discovering active wallets from recent trades...');
  const activeWallets = await sdk.wallets.discoverActiveWallets(5);
  console.log(`   Found ${activeWallets.length} active wallets:\n`);
  for (const wallet of activeWallets) {
    console.log(`   - ${wallet.address.slice(0, 10)}...: ${wallet.tradeCount} trades`);
  }

  // ===== MarketService Demo =====
  console.log('\n--- MarketService Demo ---\n');

  // 4. Get trending market
  console.log('4. Getting trending market...');
  const trendingMarkets = await sdk.markets.getTrendingMarkets(1);
  if (trendingMarkets.length === 0) {
    console.log('No trending markets found');
    return;
  }

  const market = trendingMarkets[0];
  console.log(`   Market: ${market.question.slice(0, 60)}...`);
  console.log(`   Condition ID: ${market.conditionId}\n`);

  // 5. Get unified market data
  console.log('5. Getting unified market data...');
  const unifiedMarket = await sdk.markets.getMarket(market.conditionId);
  console.log(`   Source: ${unifiedMarket.source}`);
  const yesToken = unifiedMarket.tokens.find(t => t.outcome === 'Yes');
  const noToken = unifiedMarket.tokens.find(t => t.outcome === 'No');
  console.log(`   YES Price: ${yesToken?.price}`);
  console.log(`   NO Price: ${noToken?.price}`);
  console.log(`   Volume 24hr: $${unifiedMarket.volume24hr?.toLocaleString() || 'N/A'}\n`);

  // 6. Get K-Lines
  console.log('6. Getting K-Line data...');
  const interval: KLineInterval = '1h';
  const klines = await sdk.markets.getKLines(market.conditionId, interval, { limit: 100 });
  console.log(`   Generated ${klines.length} candles (${interval} interval)\n`);

  if (klines.length > 0) {
    console.log('   Last 3 candles:');
    for (const candle of klines.slice(-3)) {
      const date = new Date(candle.timestamp).toLocaleString();
      console.log(`   [${date}] O:${candle.open.toFixed(3)} H:${candle.high.toFixed(3)} L:${candle.low.toFixed(3)} C:${candle.close.toFixed(3)} V:$${candle.volume.toFixed(0)}`);
    }
  }

  // 7. Get Dual K-Lines
  console.log('\n7. Getting dual K-Lines (YES + NO)...');
  const dualKlines = await sdk.markets.getDualKLines(market.conditionId, interval, { limit: 100 });
  console.log(`   YES Candles: ${dualKlines.yes.length}`);
  console.log(`   NO Candles: ${dualKlines.no.length}`);

  if (dualKlines.spreadAnalysis && dualKlines.spreadAnalysis.length > 0) {
    console.log('\n   Spread Analysis (last 3):');
    for (const point of dualKlines.spreadAnalysis.slice(-3)) {
      const date = new Date(point.timestamp).toLocaleString();
      console.log(`   [${date}] YES:${point.yesPrice.toFixed(3)} + NO:${point.noPrice.toFixed(3)} = ${point.spread.toFixed(4)} ${point.arbOpportunity}`);
    }
  }

  // 8. Detect market signals
  console.log('\n8. Detecting market signals...');
  const signals = await sdk.markets.detectMarketSignals(market.conditionId);
  console.log(`   Found ${signals.length} signals:\n`);
  for (const signal of signals.slice(0, 5)) {
    console.log(`   - Type: ${signal.type}, Severity: ${signal.severity}`);
  }

  // 9. Check for arbitrage
  console.log('\n9. Checking for arbitrage...');
  const arb = await sdk.markets.detectArbitrage(market.conditionId, 0.001);
  if (arb) {
    console.log(`   Arbitrage found!`);
    console.log(`   Type: ${arb.type}, Profit: ${(arb.profit * 100).toFixed(3)}%`);
    console.log(`   Action: ${arb.action}`);
  } else {
    console.log('   No arbitrage opportunity found');
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/07-realtime-websocket.ts
================================================================================
/**
 * Example 7: Real-time WebSocket
 *
 * This example demonstrates real-time price updates using RealtimeServiceV2:
 * - Connection management
 * - Market data subscriptions (orderbook, prices, trades)
 * - Crypto price subscriptions (BTC, ETH)
 *
 * Run: npx tsx examples/07-realtime-websocket.ts
 */

import { PolymarketSDK, RealtimeServiceV2 } from '../src/index.js';

async function main() {
  console.log('=== Real-time WebSocket Demo (V2) ===\n');

  const sdk = new PolymarketSDK();

  // 1. Get a trending market to subscribe to
  console.log('1. Getting trending market...');
  const trendingMarkets = await sdk.markets.getTrendingMarkets(1);
  if (trendingMarkets.length === 0) {
    console.log('No trending markets found');
    return;
  }

  const market = trendingMarkets[0];
  console.log(`   Market: ${market.question.slice(0, 60)}...`);
  console.log(`   Condition ID: ${market.conditionId}\n`);

  // 2. Get market details for token IDs
  console.log('2. Getting market details...');
  const unifiedMarket = await sdk.markets.getMarket(market.conditionId);
  const yesToken = unifiedMarket.tokens.find(t => t.outcome === 'Yes');
  const noToken = unifiedMarket.tokens.find(t => t.outcome === 'No');
  const yesTokenId = yesToken?.tokenId || '';
  const noTokenId = noToken?.tokenId || '';
  console.log(`   YES Token: ${yesTokenId.slice(0, 20)}...`);
  console.log(`   NO Token: ${noTokenId.slice(0, 20)}...`);
  console.log(`   Current YES Price: ${yesToken?.price}`);
  console.log(`   Current NO Price: ${noToken?.price}\n`);

  if (!yesTokenId || !noTokenId) {
    console.log('No token IDs available for this market');
    return;
  }

  // 3. Create RealtimeServiceV2 and connect
  console.log('3. Connecting to WebSocket...');
  const realtime = new RealtimeServiceV2({ debug: false });

  // Wait for connection
  await new Promise<void>((resolve, reject) => {
    const timeout = setTimeout(() => reject(new Error('Connection timeout')), 10000);

    realtime.once('connected', () => {
      clearTimeout(timeout);
      console.log('   Connected!\n');
      resolve();
    });

    realtime.connect();
  });

  // 4. Subscribe to market data
  console.log('4. Subscribing to market updates...');
  let updateCount = 0;
  const maxUpdates = 10;

  const subscription = realtime.subscribeMarket(yesTokenId, noTokenId, {
    onOrderbook: (book) => {
      updateCount++;
      const side = book.assetId === yesTokenId ? 'YES' : 'NO';
      const bestBid = book.bids[0];
      const bestAsk = book.asks[0];
      console.log(`   [${new Date().toLocaleTimeString()}] ${side} Book: Bid ${bestBid?.price.toFixed(4)} (${bestBid?.size.toFixed(0)}) | Ask ${bestAsk?.price.toFixed(4)} (${bestAsk?.size.toFixed(0)})`);
    },
    onPriceUpdate: (update) => {
      const side = update.assetId === yesTokenId ? 'YES' : 'NO';
      console.log(`   [${new Date().toLocaleTimeString()}] ${side} Price: ${update.price.toFixed(4)} (mid: ${update.midpoint.toFixed(4)}, spread: ${update.spread.toFixed(4)})`);
    },
    onLastTrade: (trade) => {
      const side = trade.assetId === yesTokenId ? 'YES' : 'NO';
      console.log(`   [${new Date().toLocaleTimeString()}] ${side} Trade: ${trade.side} ${trade.size} @ ${trade.price.toFixed(4)}`);
    },
    onPairUpdate: (update) => {
      const spread = update.spread;
      const arbSignal = spread < 0.99 ? 'ARB!' : spread > 1.01 ? 'ARB!' : 'OK';
      console.log(`   [${new Date().toLocaleTimeString()}] PAIR: YES ${update.yes.price.toFixed(4)} + NO ${update.no.price.toFixed(4)} = ${spread.toFixed(4)} [${arbSignal}]`);
    },
    onError: (error) => {
      console.error(`   Error: ${error.message}`);
    },
  });

  console.log(`   Subscription ID: ${subscription.id}`);
  console.log(`   Subscribed to: ${subscription.tokenIds.length} tokens`);
  console.log(`\n   Waiting for updates (max ${maxUpdates})...\n`);

  // 5. Optionally subscribe to crypto prices (BTC, ETH)
  console.log('5. Subscribing to crypto prices...');
  const cryptoSub = realtime.subscribeCryptoPrices(['BTCUSDT', 'ETHUSDT'], {
    onPrice: (price) => {
      console.log(`   [${new Date().toLocaleTimeString()}] ${price.symbol}: $${price.price.toFixed(2)}`);
    },
  });
  console.log(`   Crypto subscription ID: ${cryptoSub.id}\n`);

  // 6. Wait for some updates
  await new Promise<void>((resolve) => {
    const interval = setInterval(() => {
      if (updateCount >= maxUpdates) {
        clearInterval(interval);
        resolve();
      }
    }, 500);

    // Timeout after 30 seconds
    setTimeout(() => {
      clearInterval(interval);
      resolve();
    }, 30000);
  });

  // 7. Check cached prices
  console.log('\n6. Cached prices:');
  const prices = realtime.getAllPrices();
  for (const [assetId, price] of prices) {
    const side = assetId === yesTokenId ? 'YES' : 'NO';
    console.log(`   ${side}: ${price.price.toFixed(4)}`);
  }

  // 8. Cleanup
  console.log('\n7. Cleaning up...');
  subscription.unsubscribe();
  cryptoSub.unsubscribe();
  realtime.disconnect();
  console.log('   Disconnected');

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: examples/08-trading-orders.ts
================================================================================
/**
 * Example 08: Trading Orders
 *
 * Demonstrates trading functionality using TradingService and MarketService:
 * - Market data fetching via MarketService (getMarket, getProcessedOrderbook, getPricesHistory)
 * - Limit orders (GTC, GTD)
 * - Market orders (FOK, FAK)
 * - Order management
 * - Price utilities
 * - Rewards tracking
 *
 * NOTE: This example does NOT execute real trades.
 * Uncomment the order sections to test with real funds.
 */

import {
  TradingService,
  RateLimiter,
  PolymarketSDK,
  roundPrice,
  validatePrice,
  calculateBuyAmount,
  checkArbitrage,
  formatUSDC,
  createUnifiedCache,
  type TickSize,
} from '../src/index.js';

// Test wallet private key (empty wallet for safety)
const PRIVATE_KEY = process.env.POLYMARKET_PRIVATE_KEY || '0xYOUR_PRIVATE_KEY_HERE';

async function main() {
  console.log('=== Polymarket Trading Examples (TradingService) ===\n');

  // Initialize SDK and TradingService
  const sdk = new PolymarketSDK();
  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: PRIVATE_KEY,
  });

  // ===== 1. Find an Active Market =====
  console.log('1. Finding active markets...\n');

  const markets = await sdk.gammaApi.getMarkets({
    closed: false,
    active: true,
    limit: 5,
  });

  if (markets.length === 0) {
    console.log('   No active markets found');
    return;
  }

  const gammaMarket = markets[0];
  console.log(`   Market: ${gammaMarket.question?.slice(0, 60)}...`);
  console.log(`   Condition ID: ${gammaMarket.conditionId}`);

  // Get market details using TradingService
  try {
    await tradingService.initialize();
  } catch {
    console.log('   TradingService initialization skipped (no valid private key)');
    console.log('   Using SDK for market data...\n');
  }

  // Get market data from CLOB via MarketService (no private key required)
  const market = await sdk.markets.getClobMarket(gammaMarket.conditionId);
  const yesToken = market.tokens.find((t) => t.outcome === 'Yes');
  const noToken = market.tokens.find((t) => t.outcome === 'No');

  if (!yesToken || !noToken) {
    console.log('   Could not find tokens');
    return;
  }

  console.log(`   YES Token: ${yesToken.tokenId.slice(0, 20)}...`);
  console.log(`   NO Token: ${noToken.tokenId.slice(0, 20)}...`);
  console.log(`   YES Price: $${yesToken.price}`);
  console.log(`   NO Price: $${noToken.price}`);

  // ===== 2. Price Utilities Demo =====
  console.log('\n2. Price Utilities Demo\n');

  // Get tick size for the market
  const tickSize: TickSize = '0.01'; // Most markets use 0.01

  // Round prices to tick size
  const rawPrice = 0.523;
  console.log(`   Raw price: ${rawPrice}`);
  console.log(`   Rounded (floor): ${roundPrice(rawPrice, tickSize, 'floor')}`);
  console.log(`   Rounded (ceil): ${roundPrice(rawPrice, tickSize, 'ceil')}`);
  console.log(`   Rounded (round): ${roundPrice(rawPrice, tickSize, 'round')}`);

  // Validate prices
  const validation = validatePrice(0.525, tickSize);
  console.log(`   Price 0.525 valid: ${validation.valid}`);

  const invalidValidation = validatePrice(0.5233, tickSize);
  console.log(`   Price 0.5233 valid: ${invalidValidation.valid}`);
  if (!invalidValidation.valid) {
    console.log(`   Error: ${invalidValidation.error}`);
  }

  // Calculate order amounts
  const price = 0.52;
  const size = 100;
  const amount = calculateBuyAmount(price, size);
  console.log(`\n   Order: BUY ${size} YES @ $${price}`);
  console.log(`   Cost: ${formatUSDC(amount)}`);

  // ===== 3. Arbitrage Detection =====
  console.log('\n3. Arbitrage Detection\n');

  // Get current orderbook via MarketService (no private key required)
  const orderbook = await sdk.markets.getProcessedOrderbook(gammaMarket.conditionId);

  console.log(`   YES: Bid $${orderbook.yes.bid} / Ask $${orderbook.yes.ask}`);
  console.log(`   NO:  Bid $${orderbook.no.bid} / Ask $${orderbook.no.ask}`);

  const arb = checkArbitrage(
    orderbook.yes.ask,
    orderbook.no.ask,
    orderbook.yes.bid,
    orderbook.no.bid
  );

  if (arb) {
    console.log(`\n   ARBITRAGE DETECTED!`);
    console.log(`   Type: ${arb.type}`);
    console.log(`   Profit: ${formatUSDC(arb.profit)}`);
  } else {
    console.log(`   No arbitrage opportunity`);
    console.log(`   Long cost: $${(orderbook.yes.ask + orderbook.no.ask).toFixed(4)}`);
    console.log(`   Short revenue: $${(orderbook.yes.bid + orderbook.no.bid).toFixed(4)}`);
  }

  // ===== 3.5 Price History Demo =====
  console.log('\n3.5. Price History (MarketService)\n');

  try {
    const priceHistory = await sdk.markets.getPricesHistory({
      tokenId: yesToken.tokenId,
      interval: '1d',
    });
    console.log(`   Got ${priceHistory.length} price points for YES token`);
    if (priceHistory.length > 0) {
      const latest = priceHistory[priceHistory.length - 1];
      console.log(`   Latest: ${new Date(latest.timestamp * 1000).toLocaleDateString()} @ $${latest.price.toFixed(4)}`);
    }
  } catch (e) {
    console.log(`   Price history unavailable: ${e}`);
  }

  // ===== 4. Trading Service Status =====
  console.log('\n4. TradingService Status...\n');

  if (!tradingService.isInitialized()) {
    console.log(`   Initialization skipped (no valid private key)`);
    console.log(`   Set POLYMARKET_PRIVATE_KEY to test trading`);
    return;
  }

  console.log(`   Wallet: ${tradingService.getAddress()}`);
  console.log(`   Initialized: ${tradingService.isInitialized()}`);

  const creds = tradingService.getCredentials();
  if (creds) {
    console.log(`   API Key: ${creds.key.slice(0, 20)}...`);
  }

  // ===== 5. Get Existing Orders and Trades =====
  console.log('\n5. Getting existing orders and trades...\n');

  const openOrders = await tradingService.getOpenOrders();
  console.log(`   Open orders: ${openOrders.length}`);

  const trades = await tradingService.getTrades();
  console.log(`   Total trades: ${trades.length}`);

  if (trades.length > 0) {
    console.log('\n   Recent trades:');
    for (const t of trades.slice(0, 3)) {
      console.log(`   - ${t.side} ${t.size} @ $${t.price.toFixed(4)}`);
    }
  }

  // ===== 6. Order Types Demo =====
  console.log('\n6. Order Types (Not Executed)\n');

  console.log('   --- LIMIT ORDERS ---');
  console.log('   GTC (Good-Til-Cancelled):');
  console.log('   - Stays on book until filled or cancelled');
  console.log('   - Best for passive orders at your target price');
  console.log(`
   tradingService.createLimitOrder({
     tokenId: '${yesToken.tokenId.slice(0, 20)}...',
     side: 'BUY',
     price: 0.45,
     size: 10,
     orderType: 'GTC',
   });
`);

  console.log('   GTD (Good-Til-Date):');
  console.log('   - Auto-expires at specified timestamp');
  console.log('   - Good for time-sensitive strategies');
  console.log(`
   tradingService.createLimitOrder({
     tokenId: '${yesToken.tokenId.slice(0, 20)}...',
     side: 'BUY',
     price: 0.45,
     size: 10,
     orderType: 'GTD',
     expiration: Math.floor(Date.now() / 1000) + 3600, // 1 hour
   });
`);

  console.log('   --- MARKET ORDERS ---');
  console.log('   FOK (Fill-Or-Kill):');
  console.log('   - Must fill entirely or not at all');
  console.log('   - Best for guaranteed execution');
  console.log(`
   tradingService.createMarketOrder({
     tokenId: '${yesToken.tokenId.slice(0, 20)}...',
     side: 'BUY',
     amount: 10, // $10 USDC for BUY
     orderType: 'FOK',
   });
`);

  console.log('   FAK (Fill-And-Kill):');
  console.log('   - Fill what you can, cancel the rest');
  console.log('   - Good for partial fills');
  console.log(`
   tradingService.createMarketOrder({
     tokenId: '${yesToken.tokenId.slice(0, 20)}...',
     side: 'SELL',
     amount: 10, // 10 shares for SELL
     orderType: 'FAK',
   });
`);

  // ===== 7. Rewards Demo =====
  console.log('\n7. Rewards (Market Making Incentives)\n');

  try {
    // Get current reward programs
    const rewards = await tradingService.getCurrentRewards();
    console.log(`   Active reward programs: ${rewards.length}`);

    if (rewards.length > 0) {
      const reward = rewards[0];
      console.log(`\n   Example reward market:`);
      console.log(`   - Question: ${reward.question?.slice(0, 50)}...`);
      console.log(`   - Max Spread: ${reward.rewardsMaxSpread}`);
      console.log(`   - Min Size: ${reward.rewardsMinSize}`);

      if (reward.rewardsConfig.length > 0) {
        const config = reward.rewardsConfig[0];
        console.log(`   - Rate/Day: ${config.ratePerDay}`);
        console.log(`   - Total Pool: ${config.totalRewards}`);
      }
    }

    // Check if orders are scoring (need actual order IDs)
    if (openOrders.length > 0) {
      const orderId = openOrders[0].id;
      const isScoring = await tradingService.isOrderScoring(orderId);
      console.log(`\n   Order ${orderId.slice(0, 20)}... scoring: ${isScoring}`);
    }

    // Get yesterday's earnings
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dateStr = yesterday.toISOString().split('T')[0];

    const earnings = await tradingService.getEarningsForDay(dateStr);
    const totalEarnings = earnings.reduce((sum, e) => sum + e.earnings, 0);
    console.log(`\n   Earnings for ${dateStr}:`);
    console.log(`   Total: ${formatUSDC(totalEarnings)}`);
  } catch (error) {
    console.log(`   Rewards data not available (requires valid trading history)`);
  }

  // ===== 8. Balance Check =====
  console.log('\n8. Balance Check\n');

  try {
    const balance = await tradingService.getBalanceAllowance('COLLATERAL');
    console.log(`   USDC Balance: ${balance.balance}`);
    console.log(`   USDC Allowance: ${balance.allowance}`);
  } catch (error) {
    console.log(`   Balance check failed (requires initialized wallet)`);
  }

  console.log('\n=== Example Complete ===');
  console.log('\nTo execute real trades:');
  console.log('1. Set POLYMARKET_PRIVATE_KEY environment variable');
  console.log('2. Deposit USDC to your Polymarket proxy wallet');
  console.log('3. Uncomment the order placement code in this file');
}

main().catch(console.error);

================================================================================
// File: examples/09-rewards-tracking.ts
================================================================================
/**
 * Example 09: Market Maker Rewards Tracking
 *
 * Demonstrates how to:
 * - Find high-reward markets
 * - Check if orders are scoring
 * - Track daily earnings
 * - Optimize for maximum rewards
 *
 * NOTE: Requires a wallet with trading history to see earnings.
 */

import {
  TradingService,
  RateLimiter,
  PolymarketSDK,
  formatUSDC,
  createUnifiedCache,
} from '../src/index.js';

// Test wallet private key
const PRIVATE_KEY = process.env.POLYMARKET_PRIVATE_KEY || '0xYOUR_PRIVATE_KEY_HERE';

async function main() {
  console.log('=== Polymarket Rewards Tracking (TradingService) ===\n');

  const sdk = new PolymarketSDK();
  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: PRIVATE_KEY,
  });

  // ===== 1. Get Markets with Active Rewards =====
  console.log('1. Finding markets with active rewards...\n');

  try {
    await tradingService.initialize();
    console.log(`   Wallet: ${tradingService.getAddress()}\n`);

    const rewards = await tradingService.getCurrentRewards();
    console.log(`   Found ${rewards.length} markets with active rewards\n`);

    if (rewards.length > 0) {
      console.log('   Top 5 reward markets:');
      console.log('   ' + '─'.repeat(70));

      for (const reward of rewards.slice(0, 5)) {
        console.log(`\n   Market: ${reward.question?.slice(0, 50)}...`);
        console.log(`   Slug: ${reward.marketSlug}`);
        console.log(`   Max Spread: ${reward.rewardsMaxSpread}`);
        console.log(`   Min Size: ${reward.rewardsMinSize}`);

        if (reward.rewardsConfig.length > 0) {
          const config = reward.rewardsConfig[0];
          console.log(`   Daily Rate: ${config.ratePerDay}`);
          console.log(`   Total Pool: ${config.totalRewards}`);
          console.log(`   Period: ${config.startDate} to ${config.endDate}`);
        }

        // Show token prices
        if (reward.tokens.length > 0) {
          const yesToken = reward.tokens.find(t => t.outcome === 'Yes');
          const noToken = reward.tokens.find(t => t.outcome === 'No');
          if (yesToken && noToken) {
            console.log(`   YES Price: $${yesToken.price.toFixed(2)} | NO Price: $${noToken.price.toFixed(2)}`);
          }
        }
      }
      console.log('\n   ' + '─'.repeat(70));
    }

    // ===== 2. Check Order Scoring Status =====
    console.log('\n2. Checking if orders are scoring...\n');

    const openOrders = await tradingService.getOpenOrders();
    console.log(`   Open orders: ${openOrders.length}`);

    if (openOrders.length > 0) {
      console.log('\n   Order scoring status:');

      // Check first 5 orders
      for (const order of openOrders.slice(0, 5)) {
        const isScoring = await tradingService.isOrderScoring(order.id);
        const status = isScoring ? 'SCORING' : 'NOT SCORING';
        console.log(`   - ${order.side} ${order.originalSize} @ $${order.price.toFixed(4)}: ${status}`);
      }

      // Batch check
      if (openOrders.length > 1) {
        const orderIds = openOrders.slice(0, 5).map(o => o.id);
        const scoringStatus = await tradingService.areOrdersScoring(orderIds);
        const scoringCount = Object.values(scoringStatus).filter(Boolean).length;
        console.log(`\n   Summary: ${scoringCount}/${orderIds.length} orders are scoring`);
      }
    } else {
      console.log('   No open orders. Place limit orders to earn rewards.');
    }

    // ===== 3. Track Earnings =====
    console.log('\n3. Tracking earnings...\n');

    // Get last 7 days of earnings
    const dates: string[] = [];
    for (let i = 1; i <= 7; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      dates.push(date.toISOString().split('T')[0]);
    }

    console.log('   Daily earnings (last 7 days):');
    console.log('   ' + '-'.repeat(40));

    let totalWeeklyEarnings = 0;

    for (const date of dates) {
      try {
        const earnings = await tradingService.getEarningsForDay(date);
        const dayTotal = earnings.reduce((sum, e) => sum + e.earnings, 0);
        totalWeeklyEarnings += dayTotal;

        if (dayTotal > 0) {
          console.log(`   ${date}: ${formatUSDC(dayTotal)}`);
        } else {
          console.log(`   ${date}: $0.00`);
        }
      } catch {
        console.log(`   ${date}: (no data)`);
      }
    }

    console.log('   ' + '-'.repeat(40));
    console.log(`   Weekly Total: ${formatUSDC(totalWeeklyEarnings)}`);

    // ===== 4. Check Balance =====
    console.log('\n4. Account balance...\n');

    try {
      const balance = await tradingService.getBalanceAllowance('COLLATERAL');
      console.log(`   USDC Balance: ${balance.balance}`);
      console.log(`   USDC Allowance: ${balance.allowance}`);
    } catch {
      console.log('   Balance check not available');
    }

    // ===== 5. Reward Optimization Tips =====
    console.log('\n5. Reward Optimization Tips\n');
    console.log('   ┌─────────────────────────────────────────────────────────────┐');
    console.log('   │ How to maximize market making rewards:                       │');
    console.log('   ├─────────────────────────────────────────────────────────────┤');
    console.log('   │ 1. Keep orders within max_spread of the midpoint            │');
    console.log('   │ 2. Maintain minimum size (check rewardsMinSize)             │');
    console.log('   │ 3. Quote both sides (YES and NO) for higher score           │');
    console.log('   │ 4. Stay active throughout the day (rewards sample minutely) │');
    console.log('   │ 5. Focus on markets with higher daily rates                 │');
    console.log('   │ 6. Avoid wide spreads - tighter = higher score              │');
    console.log('   └─────────────────────────────────────────────────────────────┘');

  } catch (error) {
    console.log(`   Initialization failed: ${error}`);
    console.log('   Set POLYMARKET_PRIVATE_KEY to access rewards data');
  }

  console.log('\n=== Example Complete ===');
}

main().catch(console.error);

================================================================================
// File: examples/10-ctf-operations.ts
================================================================================
/**
 * Example 10: CTF (Conditional Token Framework) Operations
 *
 * Demonstrates on-chain CTF operations:
 * - Split: USDC → YES + NO tokens
 * - Merge: YES + NO → USDC (for arbitrage)
 * - Redeem: Winning tokens → USDC (after resolution)
 * - Balance queries and gas estimation
 *
 * ⚠️ CRITICAL: Polymarket CTF uses USDC.e (bridged), NOT native USDC!
 *
 * | Token         | Address                                    | CTF Compatible |
 * |---------------|--------------------------------------------|----------------|
 * | USDC.e        | 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 | ✅ Yes         |
 * | Native USDC   | 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359 | ❌ No          |
 *
 * Common Mistake:
 * - Your wallet shows USDC balance in block explorers/wallets
 * - But CTF operations fail with "Insufficient USDC balance"
 * - This is because you have native USDC, not USDC.e
 *
 * Solution:
 * - Swap native USDC to USDC.e: SwapService.swap('USDC', 'USDC_E', amount)
 * - Or use SwapService.transferUsdcE() when funding wallets
 * - Use CTFClient.checkReadyForCTF() to verify before operations
 *
 * IMPORTANT: These are real on-chain transactions!
 * - Require MATIC for gas fees
 * - Require USDC.e (NOT native USDC) for split operations
 * - Test on small amounts first
 *
 * Set environment variables:
 * - POLYMARKET_PRIVATE_KEY: Your wallet private key
 * - POLYGON_RPC_URL: (optional) Custom RPC URL
 */

import {
  CTFClient,
  PolymarketSDK,
  RateLimiter,
  CTF_CONTRACT,
  USDC_CONTRACT,
  formatUSDC,
  checkArbitrage,
} from '../src/index.js';

// Configuration
const PRIVATE_KEY = process.env.POLYMARKET_PRIVATE_KEY || '0xYOUR_PRIVATE_KEY_HERE';
const RPC_URL = process.env.POLYGON_RPC_URL || 'https://polygon-rpc.com';

async function main() {
  console.log('=== Polymarket CTF Operations ===\n');

  // Check if private key is set
  if (PRIVATE_KEY === '0xYOUR_PRIVATE_KEY_HERE') {
    console.log('WARNING: No private key set!');
    console.log('Set POLYMARKET_PRIVATE_KEY environment variable.');
    console.log('\nThis example will show CTF concepts without executing transactions.\n');
    await demonstrateConcepts();
    return;
  }

  // Initialize clients
  const ctf = new CTFClient({
    privateKey: PRIVATE_KEY,
    rpcUrl: RPC_URL,
  });

  const sdk = new PolymarketSDK();
  const rateLimiter = new RateLimiter();

  console.log(`Wallet: ${ctf.getAddress()}`);
  console.log(`CTF Contract: ${CTF_CONTRACT}`);
  console.log(`USDC Contract: ${USDC_CONTRACT}\n`);

  // ===== 1. Check CTF Readiness =====
  console.log('1. Checking CTF readiness (USDC.e + MATIC)...\n');

  try {
    const readiness = await ctf.checkReadyForCTF('10'); // Check for at least $10 USDC.e
    console.log(`   USDC.e Balance: $${readiness.usdcEBalance} (required for CTF)`);
    console.log(`   Native USDC:    $${readiness.nativeUsdcBalance} (NOT usable for CTF)`);
    console.log(`   MATIC Balance:  ${readiness.maticBalance} (for gas)`);
    console.log(`   CTF Ready:      ${readiness.ready ? '✅ Yes' : '❌ No'}`);
    if (readiness.suggestion) {
      console.log(`\n   ⚠️  ${readiness.suggestion}`);
    }
  } catch (error) {
    console.log(`   Error checking readiness: ${error}`);
  }

  // ===== 2. Find an Active Market =====
  console.log('\n2. Finding an active market with arbitrage potential...\n');

  const markets = await sdk.gammaApi.getMarkets({
    closed: false,
    active: true,
    limit: 10,
  });

  if (markets.length === 0) {
    console.log('   No active markets found');
    return;
  }

  // Find market with smallest spread (potential arb)
  let bestMarket = null;
  let bestOrderbook = null;

  for (const market of markets) {
    try {
      const orderbook = await sdk.markets.getProcessedOrderbook(market.conditionId);
      const askSum = orderbook.summary.askSum;

      console.log(`   ${market.question?.slice(0, 40)}...`);
      console.log(`   Ask Sum: ${askSum.toFixed(4)} | Long Arb: ${(orderbook.summary.longArbProfit * 100).toFixed(2)}%`);

      if (!bestOrderbook || askSum < bestOrderbook.summary.askSum) {
        bestMarket = market;
        bestOrderbook = orderbook;
      }
    } catch {
      // Skip markets without orderbook
    }
  }

  if (!bestMarket || !bestOrderbook) {
    console.log('   No suitable markets found');
    return;
  }

  console.log(`\n   Selected: ${bestMarket.question?.slice(0, 50)}...`);
  console.log(`   Condition ID: ${bestMarket.conditionId}`);

  // ===== 3. Check Token Balances =====
  console.log('\n3. Checking token balances...\n');

  try {
    const balances = await ctf.getPositionBalance(bestMarket.conditionId);
    console.log(`   YES Balance: ${balances.yesBalance}`);
    console.log(`   NO Balance: ${balances.noBalance}`);
    console.log(`   YES Position ID: ${balances.yesPositionId.slice(0, 20)}...`);
    console.log(`   NO Position ID: ${balances.noPositionId.slice(0, 20)}...`);
  } catch (error) {
    console.log(`   Error checking balances: ${error}`);
  }

  // ===== 4. Check Market Resolution =====
  console.log('\n4. Checking market resolution status...\n');

  try {
    const resolution = await ctf.getMarketResolution(bestMarket.conditionId);
    console.log(`   Is Resolved: ${resolution.isResolved}`);
    if (resolution.isResolved) {
      console.log(`   Winning Outcome: ${resolution.winningOutcome}`);
      console.log(`   Payout Numerators: [${resolution.payoutNumerators.join(', ')}]`);
      console.log(`   Payout Denominator: ${resolution.payoutDenominator}`);
    }
  } catch (error) {
    console.log(`   Error checking resolution: ${error}`);
  }

  // ===== 5. Arbitrage Analysis =====
  console.log('\n5. Arbitrage Analysis...\n');

  const arb = checkArbitrage(
    bestOrderbook.yes.ask,
    bestOrderbook.no.ask,
    bestOrderbook.yes.bid,
    bestOrderbook.no.bid
  );

  if (arb) {
    console.log(`   ARBITRAGE DETECTED!`);
    console.log(`   Type: ${arb.type.toUpperCase()}`);
    console.log(`   Profit: ${(arb.profit * 100).toFixed(2)}%`);

    if (arb.type === 'long') {
      console.log(`\n   Strategy (Long Arb):`);
      console.log(`   1. Buy YES @ $${bestOrderbook.yes.ask.toFixed(4)}`);
      console.log(`   2. Buy NO @ $${bestOrderbook.no.ask.toFixed(4)}`);
      console.log(`   3. CTF Merge → 1 USDC per pair`);
      console.log(`   Total cost: $${bestOrderbook.summary.askSum.toFixed(4)} per pair`);
      console.log(`   Profit: $${arb.profit.toFixed(4)} per pair`);
    } else {
      console.log(`\n   Strategy (Short Arb):`);
      console.log(`   1. CTF Split $1 USDC → 1 YES + 1 NO`);
      console.log(`   2. Sell YES @ $${bestOrderbook.yes.bid.toFixed(4)}`);
      console.log(`   3. Sell NO @ $${bestOrderbook.no.bid.toFixed(4)}`);
      console.log(`   Total revenue: $${bestOrderbook.summary.bidSum.toFixed(4)} per pair`);
      console.log(`   Profit: $${arb.profit.toFixed(4)} per pair`);
    }
  } else {
    console.log(`   No arbitrage opportunity`);
    console.log(`   Ask Sum: $${bestOrderbook.summary.askSum.toFixed(4)} (need < $1 for long arb)`);
    console.log(`   Bid Sum: $${bestOrderbook.summary.bidSum.toFixed(4)} (need > $1 for short arb)`);
  }

  // ===== 6. Gas Estimation =====
  console.log('\n6. Gas Estimation...\n');

  try {
    const splitGas = await ctf.estimateSplitGas(bestMarket.conditionId, '100');
    const mergeGas = await ctf.estimateMergeGas(bestMarket.conditionId, '100');
    console.log(`   Split 100 USDC: ~${splitGas} gas`);
    console.log(`   Merge 100 pairs: ~${mergeGas} gas`);
    console.log(`   At ~30 gwei, costs ~$${(parseInt(splitGas) * 30 / 1e9 * 0.5).toFixed(4)} per operation`);
  } catch (error) {
    console.log(`   Error estimating gas: ${error}`);
  }

  // ===== 7. CTF Operation Examples (Not Executed) =====
  console.log('\n7. CTF Operation Examples (Not Executed)\n');

  console.log('   --- SPLIT (USDC → Tokens) ---');
  console.log(`
   // Split 100 USDC into 100 YES + 100 NO
   const splitResult = await ctf.split(conditionId, '100');
   console.log(\`TX: \${splitResult.txHash}\`);
   console.log(\`Created \${splitResult.yesTokens} YES + \${splitResult.noTokens} NO\`);
`);

  console.log('   --- MERGE (Tokens → USDC) ---');
  console.log(`
   // Merge 100 YES + 100 NO → 100 USDC
   const mergeResult = await ctf.merge(conditionId, '100');
   console.log(\`TX: \${mergeResult.txHash}\`);
   console.log(\`Received \${mergeResult.usdcReceived} USDC\`);
`);

  console.log('   --- REDEEM (After Resolution) ---');
  console.log(`
   // Redeem winning tokens after market resolves
   const redeemResult = await ctf.redeem(conditionId);
   console.log(\`TX: \${redeemResult.txHash}\`);
   console.log(\`Redeemed \${redeemResult.tokensRedeemed} \${redeemResult.outcome}\`);
   console.log(\`Received \${redeemResult.usdcReceived} USDC\`);
`);

  // ===== 8. Full Arbitrage Flow =====
  console.log('8. Full Arbitrage Flow Example\n');

  console.log(`
   // Assuming long arbitrage opportunity exists
   // 1. Buy YES tokens via TradingService
   const yesOrder = await tradingService.createMarketOrder({
     tokenId: yesTokenId,
     side: 'BUY',
     amount: 100, // $100 USDC
     orderType: 'FOK',
   });

   // 2. Buy NO tokens via TradingService
   const noOrder = await tradingService.createMarketOrder({
     tokenId: noTokenId,
     side: 'BUY',
     amount: 100, // $100 USDC
     orderType: 'FOK',
   });

   // 3. Merge tokens via CTFClient
   // Calculate min(yesTokens, noTokens) to merge
   const tokensToMerge = Math.min(yesTokensReceived, noTokensReceived);
   const mergeResult = await ctf.merge(conditionId, tokensToMerge.toString());

   // 4. Profit = USDC received - total spent
   console.log(\`Profit: \${mergeResult.usdcReceived - totalSpent}\`);
`);

  console.log('\n=== Example Complete ===');
}

async function demonstrateConcepts() {
  console.log('--- CTF Concepts Demonstration ---\n');

  console.log('Polymarket uses the Gnosis Conditional Token Framework (CTF).\n');

  console.log('Core Operations:');
  console.log('┌─────────────────────────────────────────────────────────────┐');
  console.log('│ SPLIT:  $1 USDC  →  1 YES token  +  1 NO token             │');
  console.log('│ MERGE:  1 YES + 1 NO  →  $1 USDC                           │');
  console.log('│ REDEEM: After resolution, winning tokens → $1 USDC each    │');
  console.log('└─────────────────────────────────────────────────────────────┘\n');

  console.log('Arbitrage Use Cases:');
  console.log('┌─────────────────────────────────────────────────────────────┐');
  console.log('│ LONG ARB (askSum < $1):                                     │');
  console.log('│   1. Buy YES @ $0.48 + NO @ $0.50 = $0.98 cost             │');
  console.log('│   2. CTF Merge → $1 USDC                                   │');
  console.log('│   3. Profit: $0.02 per pair (2%)                           │');
  console.log('├─────────────────────────────────────────────────────────────┤');
  console.log('│ SHORT ARB (bidSum > $1):                                    │');
  console.log('│   1. CTF Split $1 → 1 YES + 1 NO                           │');
  console.log('│   2. Sell YES @ $0.52 + NO @ $0.50 = $1.02 revenue         │');
  console.log('│   3. Profit: $0.02 per pair (2%)                           │');
  console.log('└─────────────────────────────────────────────────────────────┘\n');

  console.log('Market Making Use Case:');
  console.log('┌─────────────────────────────────────────────────────────────┐');
  console.log('│ If you sell too many YES tokens and need inventory:        │');
  console.log('│   1. CTF Split $1000 → 1000 YES + 1000 NO                  │');
  console.log('│   2. Sell the NO tokens on market                          │');
  console.log('│   3. Use YES tokens to continue market making              │');
  console.log('└─────────────────────────────────────────────────────────────┘\n');

  console.log('Contract Addresses (Polygon):');
  console.log(`  CTF:  ${CTF_CONTRACT}`);
  console.log(`  USDC: ${USDC_CONTRACT}\n`);

  console.log('Gas Costs:');
  console.log('  Split/Merge/Redeem: ~200,000-300,000 gas');
  console.log('  At ~30 gwei, ~$0.003-0.005 per operation\n');

  console.log('⚠️  IMPORTANT: USDC.e vs Native USDC');
  console.log('┌─────────────────────────────────────────────────────────────┐');
  console.log('│ Polymarket CTF ONLY accepts USDC.e (bridged USDC)          │');
  console.log('│                                                             │');
  console.log('│ USDC.e:      0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 ✅  │');
  console.log('│ Native USDC: 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359 ❌  │');
  console.log('│                                                             │');
  console.log('│ If you have native USDC, swap to USDC.e first:             │');
  console.log('│   SwapService.swap("USDC", "USDC_E", amount)               │');
  console.log('│                                                             │');
  console.log('│ When funding wallets for CTF, use:                         │');
  console.log('│   SwapService.transferUsdcE(to, amount)                    │');
  console.log('└─────────────────────────────────────────────────────────────┘\n');

  console.log('To run actual CTF operations:');
  console.log('  1. Set POLYMARKET_PRIVATE_KEY environment variable');
  console.log('  2. Ensure wallet has USDC.e on Polygon (NOT native USDC!)');
  console.log('  3. Ensure wallet has MATIC for gas');
  console.log('  4. Run this example again\n');
}

main().catch(console.error);

================================================================================
// File: examples/11-live-arbitrage-scan.ts
================================================================================
/**
 * Example 12: Live Arbitrage Scan
 *
 * This script scans real Polymarket markets for arbitrage opportunities.
 * It uses only read operations (no trading) to safely test the arbitrage detection.
 *
 * Features demonstrated:
 * - Real market data fetching
 * - Arbitrage opportunity detection
 * - Gas cost estimation
 * - Pre-flight checks simulation
 *
 * Run with:
 *   pnpm example:live-arb
 */

import { PolymarketSDK, checkArbitrage } from '../src/index.js';

async function main() {
  console.log('=== Live Arbitrage Market Scan ===\n');
  console.log('Scanning real Polymarket markets for arbitrage opportunities...\n');

  // Initialize SDK (no credentials needed for read operations)
  const sdk = new PolymarketSDK();

  // ===== 1. Fetch Active Markets =====
  console.log('1. Fetching active markets...\n');

  const markets = await sdk.gammaApi.getMarkets({
    closed: false,
    active: true,
    limit: 50,
  });

  console.log(`   Found ${markets.length} active markets\n`);

  // ===== 2. Analyze Each Market for Arbitrage =====
  console.log('2. Analyzing markets for arbitrage opportunities...\n');

  const opportunities: Array<{
    question: string;
    slug: string;
    conditionId: string;
    type: 'long' | 'short';
    yesAsk: number;
    noAsk: number;
    yesBid: number;
    noBid: number;
    askSum: number;
    bidSum: number;
    longArbProfit: number;
    shortArbProfit: number;
    spread: number;
    volume24h: number;
  }> = [];

  let analyzed = 0;
  let errors = 0;

  for (const market of markets) {
    if (!market.conditionId) continue;

    try {
      const orderbook = await sdk.markets.getProcessedOrderbook(market.conditionId);

      analyzed++;

      // Check for any arbitrage
      const arb = checkArbitrage(
        orderbook.yes.ask,
        orderbook.no.ask,
        orderbook.yes.bid,
        orderbook.no.bid
      );

      // Store all markets for analysis (even with negative arb profit)
      // This helps us understand market efficiency
      if (orderbook.yes.ask > 0 && orderbook.no.ask > 0) {
        opportunities.push({
          question: market.question?.slice(0, 60) || 'Unknown',
          slug: market.slug || '',
          conditionId: market.conditionId,
          type: arb?.type || (orderbook.summary.longArbProfit > orderbook.summary.shortArbProfit ? 'long' : 'short'),
          yesAsk: orderbook.yes.ask,
          noAsk: orderbook.no.ask,
          yesBid: orderbook.yes.bid,
          noBid: orderbook.no.bid,
          askSum: orderbook.summary.askSum,
          bidSum: orderbook.summary.bidSum,
          longArbProfit: orderbook.summary.longArbProfit,
          shortArbProfit: orderbook.summary.shortArbProfit,
          spread: orderbook.summary.yesSpread,
          volume24h: market.volume24hr || 0,
        });
      }

      // Progress indicator
      if (analyzed % 10 === 0) {
        process.stdout.write(`   Analyzed ${analyzed}/${markets.length} markets...\r`);
      }
    } catch {
      errors++;
    }
  }

  console.log(`\n   Completed: ${analyzed} markets analyzed, ${errors} errors\n`);

  // ===== 3. Sort and Display Results =====
  console.log('3. Top Arbitrage Opportunities:\n');

  // Sort by best opportunity (max of long or short profit)
  opportunities.sort((a, b) => {
    const aMax = Math.max(a.longArbProfit, a.shortArbProfit);
    const bMax = Math.max(b.longArbProfit, b.shortArbProfit);
    return bMax - aMax;
  });

  // Display top 10
  const top10 = opportunities.slice(0, 10);

  if (top10.length === 0) {
    console.log('   No markets found with significant spread');
  } else {
    console.log('   ┌────────────────────────────────────────────────────────────────┐');
    console.log('   │ Market Analysis (Top 10 by potential profit)                  │');
    console.log('   ├────────────────────────────────────────────────────────────────┤');

    for (const opp of top10) {
      const maxProfit = Math.max(opp.longArbProfit, opp.shortArbProfit);
      const arbType = opp.longArbProfit > opp.shortArbProfit ? 'LONG' : 'SHORT';
      const isProfitable = maxProfit > 0;

      console.log(`   │ ${opp.question.padEnd(60)} │`);
      console.log(`   │                                                                │`);
      console.log(`   │   YES: ask=${opp.yesAsk.toFixed(4)} bid=${opp.yesBid.toFixed(4)}                               │`);
      console.log(`   │   NO:  ask=${opp.noAsk.toFixed(4)} bid=${opp.noBid.toFixed(4)}                               │`);
      console.log(`   │   Sum: askSum=${opp.askSum.toFixed(4)} bidSum=${opp.bidSum.toFixed(4)}                      │`);
      console.log(`   │   ${arbType} Profit: ${(maxProfit * 100).toFixed(2)}% ${isProfitable ? '✅' : '❌'}                                     │`);
      console.log(`   │   24h Volume: $${opp.volume24h.toLocaleString()}                                       │`);
      console.log(`   ├────────────────────────────────────────────────────────────────┤`);
    }

    console.log('   └────────────────────────────────────────────────────────────────┘');
  }

  // ===== 4. Check for Actual Profitable Opportunities =====
  console.log('\n4. Profitable Opportunities (> 0% profit):\n');

  const profitable = opportunities.filter(
    (opp) => opp.longArbProfit > 0 || opp.shortArbProfit > 0
  );

  if (profitable.length === 0) {
    console.log('   No profitable arbitrage opportunities found.');
    console.log('   This is normal - markets are usually efficient.\n');
    console.log('   ┌─────────────────────────────────────────────────────────────────┐');
    console.log('   │ Why no arbitrage?                                               │');
    console.log('   │                                                                 │');
    console.log('   │ 1. Market makers actively close arbitrage gaps                  │');
    console.log('   │ 2. Gas costs (~$0.01-0.05) eat into small profits              │');
    console.log('   │ 3. Trading fees reduce effective profit                        │');
    console.log('   │ 4. Opportunities disappear in milliseconds                     │');
    console.log('   │                                                                 │');
    console.log('   │ Successful arbitrage requires:                                  │');
    console.log('   │ - Very fast execution                                          │');
    console.log('   │ - Optimized gas usage                                          │');
    console.log('   │ - Significant capital ($1000+)                                 │');
    console.log('   └─────────────────────────────────────────────────────────────────┘');
  } else {
    console.log(`   Found ${profitable.length} profitable opportunities:\n`);

    for (const opp of profitable) {
      const arbType = opp.longArbProfit > opp.shortArbProfit ? 'LONG' : 'SHORT';
      const profit = Math.max(opp.longArbProfit, opp.shortArbProfit);

      console.log(`   🎯 ${arbType} ARB: ${(profit * 100).toFixed(2)}% profit`);
      console.log(`      Market: ${opp.question}`);
      console.log(`      Condition ID: ${opp.conditionId}`);

      if (arbType === 'LONG') {
        console.log(`      Strategy: Buy YES@${opp.yesAsk.toFixed(4)} + NO@${opp.noAsk.toFixed(4)} = ${opp.askSum.toFixed(4)} → Merge for $1`);
      } else {
        console.log(`      Strategy: Split $1 → Sell YES@${opp.yesBid.toFixed(4)} + NO@${opp.noBid.toFixed(4)} = ${opp.bidSum.toFixed(4)}`);
      }
      console.log('');
    }
  }

  // ===== 5. Market Efficiency Analysis =====
  console.log('\n5. Market Efficiency Summary:\n');

  if (opportunities.length === 0) {
    console.log('   No markets analyzed with valid orderbooks.\n');
  } else {
    const avgAskSum = opportunities.reduce((sum, o) => sum + o.askSum, 0) / opportunities.length;
    const avgBidSum = opportunities.reduce((sum, o) => sum + o.bidSum, 0) / opportunities.length;
    const avgSpread = opportunities.reduce((sum, o) => sum + o.spread, 0) / opportunities.length;

    const closestToLongArb = opportunities.reduce((closest, o) =>
      Math.abs(1 - o.askSum) < Math.abs(1 - closest.askSum) ? o : closest
    );

    const closestToShortArb = opportunities.reduce((closest, o) =>
      Math.abs(1 - o.bidSum) < Math.abs(1 - closest.bidSum) ? o : closest
    );

    console.log(`   Average Ask Sum: ${avgAskSum.toFixed(4)} (ideal for long arb: < 1.0)`);
    console.log(`   Average Bid Sum: ${avgBidSum.toFixed(4)} (ideal for short arb: > 1.0)`);
    console.log(`   Average Spread:  ${(avgSpread * 100).toFixed(2)}%`);
    console.log('');
    console.log(`   Closest to Long Arb:  ${closestToLongArb.question.slice(0, 40)}...`);
    console.log(`                         askSum = ${closestToLongArb.askSum.toFixed(4)}, profit = ${(closestToLongArb.longArbProfit * 100).toFixed(2)}%`);
    console.log('');
    console.log(`   Closest to Short Arb: ${closestToShortArb.question.slice(0, 40)}...`);
    console.log(`                         bidSum = ${closestToShortArb.bidSum.toFixed(4)}, profit = ${(closestToShortArb.shortArbProfit * 100).toFixed(2)}%`);
  }

  console.log('\n=== Scan Complete ===\n');
}

main().catch(console.error);

================================================================================
// File: examples/12-trending-arb-monitor.ts
================================================================================
/**
 * Example 13: Trending Markets Arbitrage Monitor
 *
 * Real-time monitoring of trending Polymarket markets for arbitrage opportunities.
 *
 * IMPORTANT: Understanding Polymarket Orderbook
 * =============================================
 * Polymarket 订单簿的关键特性：买 YES @ P = 卖 NO @ (1-P)
 * 因此同一订单会在两个订单簿中出现
 *
 * 正确的套利计算必须使用"有效价格"：
 * - effectiveBuyYes = min(YES.ask, 1 - NO.bid)
 * - effectiveBuyNo = min(NO.ask, 1 - YES.bid)
 * - effectiveSellYes = max(YES.bid, 1 - NO.ask)
 * - effectiveSellNo = max(NO.bid, 1 - YES.ask)
 *
 * 详细文档见: docs/01-polymarket-orderbook-arbitrage.md
 *
 * Features:
 * - Fetches trending markets from Gamma API
 * - Continuously monitors orderbooks for arb opportunities
 * - Uses correct effective price calculations
 * - Detailed logging for debugging and analysis
 * - Configurable scan interval and profit thresholds
 *
 * Run with:
 *   pnpm example:trending-arb
 *
 * Environment variables:
 *   SCAN_INTERVAL_MS - Scan interval in ms (default: 5000)
 *   MIN_PROFIT_THRESHOLD - Minimum profit % (default: 0.1)
 *   MAX_MARKETS - Max markets to monitor (default: 20)
 */

import { PolymarketSDK, checkArbitrage, getEffectivePrices } from '../src/index.js';

// ===== Configuration =====
const CONFIG = {
  scanIntervalMs: parseInt(process.env.SCAN_INTERVAL_MS || '5000'),
  minProfitThreshold: parseFloat(process.env.MIN_PROFIT_THRESHOLD || '0.1') / 100, // Convert % to decimal
  maxMarkets: parseInt(process.env.MAX_MARKETS || '20'),
  refreshMarketsIntervalMs: 60000, // Refresh trending markets every minute
  maxCycles: parseInt(process.env.MAX_CYCLES || '0'), // 0 = unlimited
};

// ===== Logging Utilities =====
function log(level: 'INFO' | 'WARN' | 'ERROR' | 'DEBUG' | 'SUCCESS', message: string, data?: unknown) {
  const timestamp = new Date().toISOString();
  const prefix = {
    'INFO': '📋',
    'WARN': '⚠️',
    'ERROR': '❌',
    'DEBUG': '🔍',
    'SUCCESS': '✅',
  }[level];

  console.log(`[${timestamp}] ${prefix} [${level}] ${message}`);
  if (data !== undefined) {
    if (typeof data === 'object') {
      console.log(JSON.stringify(data, null, 2));
    } else {
      console.log(`   → ${data}`);
    }
  }
}

function logSeparator(title?: string) {
  if (title) {
    console.log(`\n${'═'.repeat(20)} ${title} ${'═'.repeat(20)}`);
  } else {
    console.log('─'.repeat(60));
  }
}

// ===== Types =====
interface MonitoredMarket {
  conditionId: string;
  question: string;
  slug: string;
  volume24h: number;
  lastUpdate: number;
  lastEffectiveLongCost?: number;
  lastEffectiveShortRevenue?: number;
  scanCount: number;
  errorCount: number;
}

interface ScanResult {
  timestamp: number;
  market: MonitoredMarket;
  yesAsk: number;
  noAsk: number;
  yesBid: number;
  noBid: number;
  // Effective prices (考虑镜像订单)
  effectiveBuyYes: number;
  effectiveBuyNo: number;
  effectiveSellYes: number;
  effectiveSellNo: number;
  effectiveLongCost: number;
  effectiveShortRevenue: number;
  longArbProfit: number;
  shortArbProfit: number;
  yesSpread: number;
  hasOpportunity: boolean;
  opportunityType?: 'long' | 'short';
}

// ===== Monitor State =====
let markets: MonitoredMarket[] = [];
let scanCount = 0;
let opportunitiesFound = 0;
let totalScans = 0;
let lastMarketRefresh = 0;

// ===== Main Functions =====

async function fetchTrendingMarkets(sdk: PolymarketSDK): Promise<MonitoredMarket[]> {
  log('INFO', `Fetching top ${CONFIG.maxMarkets} trending markets...`);

  try {
    const trendingMarkets = await sdk.gammaApi.getTrendingMarkets(CONFIG.maxMarkets);

    const monitored: MonitoredMarket[] = trendingMarkets
      .filter(m => m.conditionId)
      .map(m => ({
        conditionId: m.conditionId,
        question: m.question || 'Unknown',
        slug: m.slug || '',
        volume24h: m.volume24hr || 0,
        lastUpdate: Date.now(),
        scanCount: 0,
        errorCount: 0,
      }));

    log('SUCCESS', `Loaded ${monitored.length} trending markets`);

    // Log market details
    monitored.forEach((m, i) => {
      log('DEBUG', `  ${i + 1}. ${m.question.slice(0, 50)}...`, {
        conditionId: m.conditionId.slice(0, 20) + '...',
        volume24h: `$${m.volume24h.toLocaleString()}`,
      });
    });

    return monitored;
  } catch (error) {
    log('ERROR', 'Failed to fetch trending markets', error instanceof Error ? error.message : error);
    return [];
  }
}

async function scanMarket(sdk: PolymarketSDK, market: MonitoredMarket): Promise<ScanResult | null> {
  try {
    const orderbook = await sdk.markets.getProcessedOrderbook(market.conditionId);

    market.scanCount++;
    market.lastUpdate = Date.now();
    market.lastEffectiveLongCost = orderbook.summary.effectiveLongCost;
    market.lastEffectiveShortRevenue = orderbook.summary.effectiveShortRevenue;

    const { effectivePrices } = orderbook.summary;

    // 使用正确的有效价格检测套利
    const arb = checkArbitrage(
      orderbook.yes.ask,
      orderbook.no.ask,
      orderbook.yes.bid,
      orderbook.no.bid
    );

    const hasOpportunity = arb !== null && arb.profit > CONFIG.minProfitThreshold;

    return {
      timestamp: Date.now(),
      market,
      yesAsk: orderbook.yes.ask,
      noAsk: orderbook.no.ask,
      yesBid: orderbook.yes.bid,
      noBid: orderbook.no.bid,
      // 有效价格
      effectiveBuyYes: effectivePrices.effectiveBuyYes,
      effectiveBuyNo: effectivePrices.effectiveBuyNo,
      effectiveSellYes: effectivePrices.effectiveSellYes,
      effectiveSellNo: effectivePrices.effectiveSellNo,
      effectiveLongCost: orderbook.summary.effectiveLongCost,
      effectiveShortRevenue: orderbook.summary.effectiveShortRevenue,
      longArbProfit: orderbook.summary.longArbProfit,
      shortArbProfit: orderbook.summary.shortArbProfit,
      yesSpread: orderbook.summary.yesSpread,
      hasOpportunity,
      opportunityType: arb?.type,
    };
  } catch (error) {
    market.errorCount++;
    log('WARN', `Scan failed for ${market.question.slice(0, 30)}...`, error instanceof Error ? error.message : 'Unknown');
    return null;
  }
}

async function runScanCycle(sdk: PolymarketSDK): Promise<void> {
  scanCount++;
  const cycleStart = Date.now();

  logSeparator(`SCAN CYCLE #${scanCount}`);
  log('INFO', `Scanning ${markets.length} markets...`);

  const results: ScanResult[] = [];
  let successCount = 0;
  let errorCount = 0;

  for (const market of markets) {
    const result = await scanMarket(sdk, market);
    totalScans++;

    if (result) {
      successCount++;
      results.push(result);

      // Log each market scan result
      const profitIndicator = result.hasOpportunity ? '🎯' :
                              result.longArbProfit > -0.01 ? '📈' :
                              result.shortArbProfit > -0.01 ? '📉' : '⏸️';

      log('DEBUG', `${profitIndicator} ${market.question.slice(0, 40)}...`, {
        // 有效价格计算
        effectiveLongCost: result.effectiveLongCost.toFixed(4),
        effectiveShortRevenue: result.effectiveShortRevenue.toFixed(4),
        longArb: `${(result.longArbProfit * 100).toFixed(2)}%`,
        shortArb: `${(result.shortArbProfit * 100).toFixed(2)}%`,
        yesSpread: `${(result.yesSpread * 100).toFixed(2)}%`,
      });
    } else {
      errorCount++;
    }
  }

  // Find opportunities
  const opportunities = results.filter(r => r.hasOpportunity);

  if (opportunities.length > 0) {
    opportunitiesFound += opportunities.length;

    logSeparator('🚨 OPPORTUNITIES FOUND');

    for (const opp of opportunities) {
      log('SUCCESS', `${opp.opportunityType?.toUpperCase()} ARB OPPORTUNITY`, {
        market: opp.market.question,
        conditionId: opp.market.conditionId,
        type: opp.opportunityType,
        profit: `${(Math.max(opp.longArbProfit, opp.shortArbProfit) * 100).toFixed(3)}%`,
        effectivePrices: {
          buyYes: opp.effectiveBuyYes.toFixed(4),
          buyNo: opp.effectiveBuyNo.toFixed(4),
          sellYes: opp.effectiveSellYes.toFixed(4),
          sellNo: opp.effectiveSellNo.toFixed(4),
        },
        costs: {
          effectiveLongCost: opp.effectiveLongCost.toFixed(4),
          effectiveShortRevenue: opp.effectiveShortRevenue.toFixed(4),
        },
      });

      // Log execution strategy
      if (opp.opportunityType === 'long') {
        log('INFO', '📌 Strategy: Buy YES + Buy NO → Merge → Profit', {
          step1: `Buy YES @ ${opp.effectiveBuyYes.toFixed(4)}`,
          step2: `Buy NO @ ${opp.effectiveBuyNo.toFixed(4)}`,
          step3: 'Merge tokens → 1 USDC',
          profit: `${(opp.longArbProfit * 100).toFixed(3)}% per unit`,
        });
      } else {
        log('INFO', '📌 Strategy: Split USDC → Sell YES + Sell NO → Profit', {
          step1: 'Split 1 USDC → 1 YES + 1 NO',
          step2: `Sell YES @ ${opp.effectiveSellYes.toFixed(4)}`,
          step3: `Sell NO @ ${opp.effectiveSellNo.toFixed(4)}`,
          profit: `${(opp.shortArbProfit * 100).toFixed(3)}% per unit`,
        });
      }
    }
  }

  // Cycle summary
  const cycleTime = Date.now() - cycleStart;
  log('INFO', `Cycle #${scanCount} complete`, {
    duration: `${cycleTime}ms`,
    scanned: successCount,
    errors: errorCount,
    opportunities: opportunities.length,
  });

  // Show best spreads (closest to arb)
  if (results.length > 0) {
    const sortedByLongArb = [...results].sort((a, b) => b.longArbProfit - a.longArbProfit);
    const sortedByShortArb = [...results].sort((a, b) => b.shortArbProfit - a.shortArbProfit);

    log('DEBUG', 'Best Long Arb Candidates (by effective cost):', {
      '1st': `${sortedByLongArb[0].market.question.slice(0, 30)}... → cost=${sortedByLongArb[0].effectiveLongCost.toFixed(4)} → ${(sortedByLongArb[0].longArbProfit * 100).toFixed(2)}%`,
      '2nd': sortedByLongArb[1] ? `${sortedByLongArb[1].market.question.slice(0, 30)}... → cost=${sortedByLongArb[1].effectiveLongCost.toFixed(4)} → ${(sortedByLongArb[1].longArbProfit * 100).toFixed(2)}%` : 'N/A',
    });

    log('DEBUG', 'Best Short Arb Candidates (by effective revenue):', {
      '1st': `${sortedByShortArb[0].market.question.slice(0, 30)}... → rev=${sortedByShortArb[0].effectiveShortRevenue.toFixed(4)} → ${(sortedByShortArb[0].shortArbProfit * 100).toFixed(2)}%`,
      '2nd': sortedByShortArb[1] ? `${sortedByShortArb[1].market.question.slice(0, 30)}... → rev=${sortedByShortArb[1].effectiveShortRevenue.toFixed(4)} → ${(sortedByShortArb[1].shortArbProfit * 100).toFixed(2)}%` : 'N/A',
    });

    // Show spread analysis
    const avgSpread = results.reduce((sum, r) => sum + r.yesSpread, 0) / results.length;
    log('DEBUG', 'Market Efficiency:', {
      avgYesSpread: `${(avgSpread * 100).toFixed(2)}%`,
      interpretation: 'Spread = transaction cost, markets are efficient when spread > 0',
    });
  }
}

async function maybeRefreshMarkets(sdk: PolymarketSDK): Promise<void> {
  const now = Date.now();
  if (now - lastMarketRefresh > CONFIG.refreshMarketsIntervalMs) {
    log('INFO', 'Refreshing trending markets list...');
    const newMarkets = await fetchTrendingMarkets(sdk);
    if (newMarkets.length > 0) {
      markets = newMarkets;
      lastMarketRefresh = now;
    }
  }
}

async function main(): Promise<void> {
  console.clear();
  logSeparator('TRENDING MARKETS ARBITRAGE MONITOR');

  log('INFO', 'Configuration', {
    scanInterval: `${CONFIG.scanIntervalMs}ms`,
    minProfitThreshold: `${CONFIG.minProfitThreshold * 100}%`,
    maxMarkets: CONFIG.maxMarkets,
    refreshInterval: `${CONFIG.refreshMarketsIntervalMs / 1000}s`,
  });

  log('INFO', 'Understanding Arbitrage Calculation:', {
    note: 'Uses effective prices considering mirror orders',
    longArb: 'Profit when effectiveLongCost < 1.0',
    shortArb: 'Profit when effectiveShortRevenue > 1.0',
    docs: 'docs/01-polymarket-orderbook-arbitrage.md',
  });

  // Initialize SDK
  log('INFO', 'Initializing PolymarketSDK...');
  const sdk = new PolymarketSDK();
  log('SUCCESS', 'SDK initialized');

  // Fetch initial markets
  markets = await fetchTrendingMarkets(sdk);
  lastMarketRefresh = Date.now();

  if (markets.length === 0) {
    log('ERROR', 'No markets to monitor. Exiting.');
    process.exit(1);
  }

  logSeparator('STARTING MONITOR LOOP');
  log('INFO', `Press Ctrl+C to stop. Scanning every ${CONFIG.scanIntervalMs / 1000}s...`);

  // Monitor loop
  const runLoop = async () => {
    try {
      await maybeRefreshMarkets(sdk);
      await runScanCycle(sdk);
    } catch (error) {
      log('ERROR', 'Scan cycle error', error instanceof Error ? error.message : error);
    }

    // Check if we've reached max cycles
    if (CONFIG.maxCycles > 0 && scanCount >= CONFIG.maxCycles) {
      logSeparator('MAX CYCLES REACHED');
      log('INFO', 'Final Statistics', {
        totalCycles: scanCount,
        totalScans,
        opportunitiesFound,
      });
      process.exit(0);
    }

    // Schedule next scan
    setTimeout(runLoop, CONFIG.scanIntervalMs);
  };

  // Start loop
  await runLoop();

  // Handle shutdown
  process.on('SIGINT', () => {
    logSeparator('MONITOR SHUTDOWN');
    log('INFO', 'Final Statistics', {
      totalCycles: scanCount,
      totalScans,
      opportunitiesFound,
      runtime: `${Math.round((Date.now() - lastMarketRefresh) / 1000)}s`,
    });
    process.exit(0);
  });
}

main().catch(error => {
  log('ERROR', 'Fatal error', error);
  process.exit(1);
});

================================================================================
// File: examples/13-arbitrage-service.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Example 13: ArbitrageService - Complete Workflow
 *
 * Demonstrates the full arbitrage workflow:
 * 1. Scan markets for opportunities
 * 2. Start real-time monitoring
 * 3. Auto-execute arbitrage
 * 4. Stop and clear positions
 *
 * Environment variables:
 *   POLY_PRIVKEY - Private key for trading (optional for scan-only mode)
 *
 * Run with:
 *   pnpm example:arb-service
 *
 * Or scan-only (no trading):
 *   npx tsx examples/13-arbitrage-service.ts --scan-only
 */

import { ArbitrageService } from '../src/index.js';

// Parse arguments
const args = process.argv.slice(2);
const SCAN_ONLY = args.includes('--scan-only');
const RUN_DURATION = parseInt(args.find(a => a.startsWith('--duration='))?.split('=')[1] || '60') * 1000; // default 60s

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║              ArbitrageService - Complete Workflow              ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log();

  const privateKey = process.env.POLY_PRIVKEY;

  if (!privateKey && !SCAN_ONLY) {
    console.log('No POLY_PRIVKEY provided. Running in scan-only mode.\n');
  }

  // ========== Initialize ArbitrageService ==========
  const arbService = new ArbitrageService({
    privateKey: SCAN_ONLY ? undefined : privateKey,
    profitThreshold: 0.005,  // 0.5% minimum profit
    minTradeSize: 5,         // $5 minimum
    maxTradeSize: 100,       // $100 maximum
    autoExecute: !SCAN_ONLY && !!privateKey,
    enableLogging: true,

    // Rebalancer config
    enableRebalancer: !SCAN_ONLY && !!privateKey,
    minUsdcRatio: 0.2,
    maxUsdcRatio: 0.8,
    targetUsdcRatio: 0.5,
    imbalanceThreshold: 5,
    rebalanceInterval: 10000,
    rebalanceCooldown: 30000,

    // Execution safety
    sizeSafetyFactor: 0.8,
    autoFixImbalance: true,
  });

  // ========== Set up event listeners ==========
  arbService.on('opportunity', (opp) => {
    console.log(`\n🎯 ${opp.type.toUpperCase()} ARB: ${opp.profitPercent.toFixed(2)}%`);
    console.log(`   ${opp.description}`);
    console.log(`   Recommended size: ${opp.recommendedSize.toFixed(2)}, Est profit: $${opp.estimatedProfit.toFixed(2)}`);
  });

  arbService.on('execution', (result) => {
    if (result.success) {
      console.log(`\n✅ Execution succeeded!`);
      console.log(`   Type: ${result.type}, Size: ${result.size.toFixed(2)}`);
      console.log(`   Profit: $${result.profit.toFixed(2)}`);
      console.log(`   Time: ${result.executionTimeMs}ms`);
    } else {
      console.log(`\n❌ Execution failed: ${result.error}`);
    }
  });

  arbService.on('rebalance', (result) => {
    if (result.success) {
      console.log(`\n🔄 Rebalance: ${result.action.type} ${result.action.amount.toFixed(2)}`);
      console.log(`   Reason: ${result.action.reason}`);
    } else {
      console.log(`\n⚠️ Rebalance failed: ${result.error}`);
    }
  });

  arbService.on('balanceUpdate', (balance) => {
    console.log(`\n💰 Balance: USDC=${balance.usdc.toFixed(2)}, YES=${balance.yesTokens.toFixed(2)}, NO=${balance.noTokens.toFixed(2)}`);
  });

  arbService.on('error', (error) => {
    console.error(`\n🚨 Error: ${error.message}`);
  });

  // ========== Step 1: Scan Markets ==========
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('Step 1: Scanning markets for arbitrage opportunities...');
  console.log('═══════════════════════════════════════════════════════════════\n');

  const scanResults = await arbService.scanMarkets(
    { minVolume24h: 5000, limit: 50 },
    0.003  // 0.3% min profit for scanning
  );

  const opportunities = scanResults.filter(r => r.arbType !== 'none');

  console.log(`\nFound ${opportunities.length} opportunities out of ${scanResults.length} markets scanned\n`);

  if (opportunities.length > 0) {
    console.log('Top 5 opportunities:');
    console.log('┌──────────────────────────────────────────────────────────────────┐');
    for (const r of opportunities.slice(0, 5)) {
      console.log(`│ ${r.market.name.slice(0, 50).padEnd(50)} │`);
      console.log(`│   ${r.arbType.toUpperCase()} +${r.profitPercent.toFixed(2)}%  Size: ${r.availableSize.toFixed(0)}  Vol: $${r.volume24h.toLocaleString().padEnd(10)} │`);
      console.log(`├──────────────────────────────────────────────────────────────────┤`);
    }
    console.log('└──────────────────────────────────────────────────────────────────┘');
  }

  if (SCAN_ONLY || opportunities.length === 0) {
    console.log('\n✅ Scan complete.');
    if (SCAN_ONLY) {
      console.log('   (Running in scan-only mode, not starting arbitrage)');
    }
    if (opportunities.length === 0) {
      console.log('   (No profitable opportunities found)');
    }
    return;
  }

  // ========== Step 2: Start Arbitrage ==========
  console.log('\n═══════════════════════════════════════════════════════════════');
  console.log('Step 2: Starting arbitrage on best market...');
  console.log('═══════════════════════════════════════════════════════════════\n');

  const best = opportunities[0];
  console.log(`Selected: ${best.market.name}`);
  console.log(`Type: ${best.arbType.toUpperCase()}, Profit: +${best.profitPercent.toFixed(2)}%\n`);

  await arbService.start(best.market);

  // ========== Step 3: Run for duration ==========
  console.log('\n═══════════════════════════════════════════════════════════════');
  console.log(`Step 3: Running for ${RUN_DURATION / 1000} seconds...`);
  console.log('═══════════════════════════════════════════════════════════════\n');
  console.log('Monitoring for arbitrage opportunities...');
  console.log('(Press Ctrl+C to stop early)\n');

  // Handle graceful shutdown
  let stopped = false;
  const shutdown = async () => {
    if (stopped) return;
    stopped = true;
    console.log('\n\nShutting down...');
    await cleanup();
    process.exit(0);
  };

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);

  // Wait for duration
  await new Promise(resolve => setTimeout(resolve, RUN_DURATION));

  // ========== Step 4: Stop and Clear ==========
  async function cleanup() {
    console.log('\n═══════════════════════════════════════════════════════════════');
    console.log('Step 4: Stopping and clearing positions...');
    console.log('═══════════════════════════════════════════════════════════════\n');

    await arbService.stop();

    // Print stats
    const stats = arbService.getStats();
    console.log('Session Statistics:');
    console.log(`  Opportunities detected: ${stats.opportunitiesDetected}`);
    console.log(`  Executions attempted: ${stats.executionsAttempted}`);
    console.log(`  Executions succeeded: ${stats.executionsSucceeded}`);
    console.log(`  Total profit: $${stats.totalProfit.toFixed(2)}`);
    console.log(`  Running time: ${(stats.runningTimeMs / 1000).toFixed(0)}s`);

    // Clear positions
    if (privateKey) {
      console.log('\nClearing positions...');
      const clearResult = await arbService.clearPositions(best.market, false);

      console.log(`\nPosition status:`);
      console.log(`  Market status: ${clearResult.marketStatus}`);
      console.log(`  YES balance: ${clearResult.yesBalance.toFixed(4)}`);
      console.log(`  NO balance: ${clearResult.noBalance.toFixed(4)}`);
      console.log(`  Expected recovery: $${clearResult.totalUsdcRecovered.toFixed(2)}`);

      if (clearResult.actions.length > 0) {
        console.log(`\nPlanned actions:`);
        for (const action of clearResult.actions) {
          console.log(`  - ${action.type}: ${action.amount.toFixed(4)} → ~$${action.usdcResult.toFixed(2)}`);
        }
        console.log('\n(Run with --execute-clear to actually clear positions)');
      }
    }

    console.log('\n✅ Done!');
  }

  await cleanup();
}

main().catch(console.error);

================================================================================
// File: package.json
================================================================================
{
  "name": "@catalyst-team/poly-sdk",
  "version": "0.4.3",
  "private": false,
  "license": "MIT",
  "description": "TypeScript SDK for Polymarket - prediction markets trading, smart money analysis, and market data",
  "type": "module",
  "main": "./dist/src/index.js",
  "types": "./dist/src/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/src/index.d.ts",
      "import": "./dist/src/index.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "pnpm run build",
    "dev": "tsc --watch",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "example:basic": "tsx examples/01-basic-usage.ts",
    "example:smart-money": "tsx examples/02-smart-money.ts",
    "example:market-analysis": "tsx examples/03-market-analysis.ts",
    "example:kline": "tsx examples/04-kline-aggregation.ts",
    "example:follow-wallet": "tsx examples/05-follow-wallet-strategy.ts",
    "example:services": "tsx examples/06-services-demo.ts",
    "example:realtime": "tsx examples/07-realtime-websocket.ts",
    "example:trading": "tsx examples/08-trading-orders.ts",
    "example:rewards": "tsx examples/09-rewards-tracking.ts",
    "example:ctf": "tsx examples/10-ctf-operations.ts",
    "example:live-arb": "tsx examples/11-live-arbitrage-scan.ts",
    "example:trending-arb": "tsx examples/12-trending-arb-monitor.ts",
    "example:arb-service": "tsx examples/13-arbitrage-service.ts"
  },
  "keywords": [
    "polymarket",
    "prediction-markets",
    "trading",
    "crypto",
    "defi",
    "smart-money"
  ],
  "author": "Catalyst Team",
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@polymarket/clob-client": "^5.1.3",
    "@polymarket/real-time-data-client": "^1.4.0",
    "@catalyst-team/cache": "^0.2.0",
    "@types/ws": "^8.18.1",
    "bottleneck": "^2.19.5",
    "ethers": "5",
    "isomorphic-ws": "^5.0.0",
    "ws": "^8.18.3"
  },
  "devDependencies": {
    "tsx": "^4.7.0",
    "typescript": "^5.7.2",
    "vitest": "^2.1.8"
  }
}

================================================================================
// File: scripts/api-verification/01-gamma-api.ts
================================================================================
/**
 * Gamma API 验证脚本
 *
 * 目的：实际调用 Gamma API，记录真实返回结构
 * 原则：Don't trust, verify
 */

const GAMMA_API = 'https://gamma-api.polymarket.com';

interface ApiEndpoint {
  name: string;
  url: string;
  description: string;
}

const endpoints: ApiEndpoint[] = [
  {
    name: 'markets',
    url: `${GAMMA_API}/markets?limit=2&active=true`,
    description: '获取市场列表',
  },
  {
    name: 'markets-by-slug',
    url: `${GAMMA_API}/markets?slug=will-donald-trump-win-the-2024-us-presidential-election`,
    description: '按 slug 获取市场',
  },
  {
    name: 'events',
    url: `${GAMMA_API}/events?limit=2&active=true`,
    description: '获取事件列表',
  },
];

async function verifyEndpoint(endpoint: ApiEndpoint): Promise<void> {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`📡 ${endpoint.name}: ${endpoint.description}`);
  console.log(`URL: ${endpoint.url}`);
  console.log('='.repeat(80));

  try {
    const response = await fetch(endpoint.url);
    const data = await response.json();

    console.log(`\n✅ Status: ${response.status}`);
    console.log(`📦 Response Type: ${Array.isArray(data) ? 'Array' : typeof data}`);

    if (Array.isArray(data) && data.length > 0) {
      console.log(`📊 Array Length: ${data.length}`);
      console.log('\n🔍 First Item Structure:');
      console.log(JSON.stringify(data[0], null, 2));

      // 列出所有字段
      console.log('\n📋 All Fields in First Item:');
      const fields = Object.keys(data[0]).sort();
      fields.forEach((field, i) => {
        const value = data[0][field];
        const type = Array.isArray(value) ? 'array' : typeof value;
        const preview = type === 'string' ? `"${String(value).slice(0, 50)}..."` :
                       type === 'array' ? `[${value.length} items]` :
                       JSON.stringify(value);
        console.log(`  ${i + 1}. ${field}: ${type} = ${preview}`);
      });
    } else {
      console.log('\n🔍 Response:');
      console.log(JSON.stringify(data, null, 2));
    }
  } catch (error) {
    console.log(`\n❌ Error: ${error}`);
  }
}

async function main(): Promise<void> {
  console.log('🚀 Gamma API 验证开始');
  console.log('Base URL:', GAMMA_API);
  console.log('Time:', new Date().toISOString());

  for (const endpoint of endpoints) {
    await verifyEndpoint(endpoint);
  }

  console.log('\n\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/02-clob-api.ts
================================================================================
/**
 * CLOB API 验证脚本
 *
 * 目的：实际调用 CLOB API，记录真实返回结构
 * 原则：Don't trust, verify
 */

const CLOB_API = 'https://clob.polymarket.com';

interface ApiEndpoint {
  name: string;
  url: string;
  description: string;
}

// 使用 Trump 2024 市场作为测试用例
const TRUMP_CONDITION_ID = '0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917';
const TRUMP_YES_TOKEN_ID = '21742633143463906290569050155826241533067272736897614950488156847949938836455';

const endpoints: ApiEndpoint[] = [
  {
    name: 'markets-list',
    url: `${CLOB_API}/markets?limit=2`,
    description: '获取市场列表',
  },
  {
    name: 'market-by-condition-id',
    url: `${CLOB_API}/markets/${TRUMP_CONDITION_ID}`,
    description: '按 conditionId 获取单个市场',
  },
  {
    name: 'orderbook',
    url: `${CLOB_API}/book?token_id=${TRUMP_YES_TOKEN_ID}`,
    description: '获取订单簿',
  },
  {
    name: 'midpoint',
    url: `${CLOB_API}/midpoint?token_id=${TRUMP_YES_TOKEN_ID}`,
    description: '获取中间价',
  },
  {
    name: 'price',
    url: `${CLOB_API}/price?token_id=${TRUMP_YES_TOKEN_ID}&side=BUY`,
    description: '获取最优价格',
  },
  {
    name: 'spread',
    url: `${CLOB_API}/spread?token_id=${TRUMP_YES_TOKEN_ID}`,
    description: '获取买卖价差',
  },
  {
    name: 'tick-size',
    url: `${CLOB_API}/tick-size?token_id=${TRUMP_YES_TOKEN_ID}`,
    description: '获取最小价格单位',
  },
  {
    name: 'neg-risk',
    url: `${CLOB_API}/neg-risk?token_id=${TRUMP_YES_TOKEN_ID}`,
    description: '获取 neg-risk 信息',
  },
];

async function verifyEndpoint(endpoint: ApiEndpoint): Promise<void> {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`📡 ${endpoint.name}: ${endpoint.description}`);
  console.log(`URL: ${endpoint.url}`);
  console.log('='.repeat(80));

  try {
    const response = await fetch(endpoint.url);
    const data = await response.json();

    console.log(`\n✅ Status: ${response.status}`);
    console.log(`📦 Response Type: ${Array.isArray(data) ? 'Array' : typeof data}`);

    if (Array.isArray(data) && data.length > 0) {
      console.log(`📊 Array Length: ${data.length}`);
      console.log('\n🔍 First Item Structure:');
      console.log(JSON.stringify(data[0], null, 2));

      // 列出所有字段
      console.log('\n📋 All Fields in First Item:');
      const fields = Object.keys(data[0]).sort();
      fields.forEach((field, i) => {
        const value = data[0][field];
        const type = Array.isArray(value) ? 'array' : typeof value;
        const preview = type === 'string' ? `"${String(value).slice(0, 50)}..."` :
                       type === 'array' ? `[${value.length} items]` :
                       JSON.stringify(value);
        console.log(`  ${i + 1}. ${field}: ${type} = ${preview}`);
      });
    } else if (typeof data === 'object' && data !== null) {
      console.log('\n🔍 Response Structure:');
      console.log(JSON.stringify(data, null, 2));

      // 列出所有字段
      console.log('\n📋 All Fields:');
      const fields = Object.keys(data).sort();
      fields.forEach((field, i) => {
        const value = data[field];
        const type = Array.isArray(value) ? 'array' : typeof value;
        const preview = type === 'string' ? `"${String(value).slice(0, 50)}..."` :
                       type === 'array' ? `[${value.length} items]` :
                       type === 'object' ? `{...}` :
                       JSON.stringify(value);
        console.log(`  ${i + 1}. ${field}: ${type} = ${preview}`);
      });
    } else {
      console.log('\n🔍 Response:');
      console.log(JSON.stringify(data, null, 2));
    }
  } catch (error) {
    console.log(`\n❌ Error: ${error}`);
  }
}

async function main(): Promise<void> {
  console.log('🚀 CLOB API 验证开始');
  console.log('Base URL:', CLOB_API);
  console.log('Time:', new Date().toISOString());
  console.log('\nTest Market: Trump 2024 Presidential Election');
  console.log('Condition ID:', TRUMP_CONDITION_ID);
  console.log('YES Token ID:', TRUMP_YES_TOKEN_ID);

  for (const endpoint of endpoints) {
    await verifyEndpoint(endpoint);
  }

  console.log('\n\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/03-data-api.ts
================================================================================
/**
 * Data API 验证脚本
 *
 * 目的：实际调用 Data API，记录真实返回结构
 * 原则：Don't trust, verify
 */

const DATA_API = 'https://data-api.polymarket.com';

interface ApiEndpoint {
  name: string;
  url: string;
  description: string;
}

// 使用 simonbanza 作为测试用户
const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';
// Trump 2024 市场
const TRUMP_CONDITION_ID = '0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917';
const TRUMP_YES_TOKEN_ID = '21742633143463906290569050155826241533067272736897614950488156847949938836455';

const endpoints: ApiEndpoint[] = [
  // === Wallet 数据 ===
  {
    name: 'positions',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&limit=5`,
    description: '获取用户持仓',
  },
  {
    name: 'value',
    url: `${DATA_API}/value?user=${TEST_ADDRESS}`,
    description: '获取用户账户价值',
  },
  {
    name: 'leaderboard',
    url: `${DATA_API}/leaderboard?limit=5`,
    description: '获取排行榜',
  },

  // === 行为数据 ===
  {
    name: 'activity',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5`,
    description: '获取用户活动',
  },
  {
    name: 'trades-by-user',
    url: `${DATA_API}/trades?user=${TEST_ADDRESS}&limit=5`,
    description: '获取用户交易记录',
  },
  {
    name: 'trades-by-market',
    url: `${DATA_API}/trades?market=${TRUMP_CONDITION_ID}&limit=5`,
    description: '获取市场交易记录',
  },

  // === 市场数据 ===
  {
    name: 'holders',
    url: `${DATA_API}/holders?market=${TRUMP_CONDITION_ID}&limit=5`,
    description: '获取市场持仓者',
  },
  {
    name: 'timeseries',
    url: `${DATA_API}/timeseries?market=${TRUMP_CONDITION_ID}&fidelity=60`,
    description: '获取价格时序数据',
  },
  {
    name: 'prices-history',
    url: `${DATA_API}/prices-history?market=${TRUMP_CONDITION_ID}&interval=max`,
    description: '获取历史价格',
  },
];

async function verifyEndpoint(endpoint: ApiEndpoint): Promise<void> {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`📡 ${endpoint.name}: ${endpoint.description}`);
  console.log(`URL: ${endpoint.url}`);
  console.log('='.repeat(80));

  try {
    const response = await fetch(endpoint.url);

    if (!response.ok) {
      console.log(`\n❌ Status: ${response.status} ${response.statusText}`);
      const text = await response.text();
      console.log(`Response: ${text.slice(0, 500)}`);
      return;
    }

    const data = await response.json();

    console.log(`\n✅ Status: ${response.status}`);
    console.log(`📦 Response Type: ${Array.isArray(data) ? 'Array' : typeof data}`);

    if (Array.isArray(data) && data.length > 0) {
      console.log(`📊 Array Length: ${data.length}`);
      console.log('\n🔍 First Item Structure:');
      console.log(JSON.stringify(data[0], null, 2));

      // 列出所有字段
      console.log('\n📋 All Fields in First Item:');
      const fields = Object.keys(data[0]).sort();
      fields.forEach((field, i) => {
        const value = data[0][field];
        const type = Array.isArray(value) ? 'array' : typeof value;
        const preview = type === 'string' ? `"${String(value).slice(0, 50)}..."` :
                       type === 'array' ? `[${value.length} items]` :
                       type === 'object' && value !== null ? `{...}` :
                       JSON.stringify(value);
        console.log(`  ${i + 1}. ${field}: ${type} = ${preview}`);
      });
    } else if (typeof data === 'object' && data !== null) {
      console.log('\n🔍 Response Structure:');
      console.log(JSON.stringify(data, null, 2));

      // 列出所有字段
      console.log('\n📋 All Fields:');
      const fields = Object.keys(data).sort();
      fields.forEach((field, i) => {
        const value = data[field];
        const type = Array.isArray(value) ? 'array' : typeof value;
        const preview = type === 'string' ? `"${String(value).slice(0, 50)}..."` :
                       type === 'array' ? `[${value.length} items]` :
                       type === 'object' && value !== null ? `{...}` :
                       JSON.stringify(value);
        console.log(`  ${i + 1}. ${field}: ${type} = ${preview}`);
      });
    } else {
      console.log('\n🔍 Response:');
      console.log(JSON.stringify(data, null, 2));
    }
  } catch (error) {
    console.log(`\n❌ Error: ${error}`);
  }
}

async function main(): Promise<void> {
  console.log('🚀 Data API 验证开始');
  console.log('Base URL:', DATA_API);
  console.log('Time:', new Date().toISOString());
  console.log('\nTest User: simonbanza');
  console.log('Address:', TEST_ADDRESS);
  console.log('Test Market: Trump 2024 Presidential Election');

  for (const endpoint of endpoints) {
    await verifyEndpoint(endpoint);
  }

  console.log('\n\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/04-data-api-params.ts
================================================================================
/**
 * Data API 参数验证脚本
 *
 * 目的：验证文档中提到的 API 参数是否真正可用
 * 原则：Don't trust, verify
 *
 * 验证内容：
 * - Activity: start, end, offset, sortBy, sortDirection, market
 * - Positions: limit, offset, sortBy, sortDirection, market, sizeThreshold, redeemable
 * - Trades: user, side, takerOnly
 * - Value: 端点是否可用
 * - Holders: 端点是否可用
 */

const DATA_API = 'https://data-api.polymarket.com';

// 测试用户: simonbanza (活跃交易者)
const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';
// Trump 2024 市场
const TRUMP_CONDITION_ID = '0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917';

interface TestCase {
  name: string;
  url: string;
  description: string;
  expectedParams: string[];
}

// ===== P0: 关键功能验证 =====

const p0Tests: TestCase[] = [
  // Activity start/end
  {
    name: 'activity-with-start',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&start=1733961600`, // 2024-12-12 00:00:00 UTC
    description: 'Activity 带 start 时间戳过滤',
    expectedParams: ['start'],
  },
  {
    name: 'activity-with-end',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&end=1734048000`, // 2024-12-13 00:00:00 UTC
    description: 'Activity 带 end 时间戳过滤',
    expectedParams: ['end'],
  },
  {
    name: 'activity-with-range',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&start=1733961600&end=1734048000`,
    description: 'Activity 带时间范围',
    expectedParams: ['start', 'end'],
  },
  // Activity offset
  {
    name: 'activity-with-offset',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&offset=10`,
    description: 'Activity 带 offset 分页',
    expectedParams: ['offset'],
  },
  // Positions limit/offset
  {
    name: 'positions-with-limit',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&limit=5`,
    description: 'Positions 带 limit',
    expectedParams: ['limit'],
  },
  {
    name: 'positions-with-offset',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&limit=5&offset=0`,
    description: 'Positions 带 offset',
    expectedParams: ['offset'],
  },
];

// ===== P1: 重要功能验证 =====

const p1Tests: TestCase[] = [
  // Positions sortBy
  {
    name: 'positions-sortby-cashpnl',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&sortBy=CASHPNL`,
    description: 'Positions 按现金 PnL 排序',
    expectedParams: ['sortBy'],
  },
  {
    name: 'positions-sortby-percentpnl',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&sortBy=PERCENTPNL`,
    description: 'Positions 按百分比 PnL 排序',
    expectedParams: ['sortBy'],
  },
  {
    name: 'positions-sort-direction',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&sortBy=CASHPNL&sortDirection=ASC`,
    description: 'Positions 排序方向',
    expectedParams: ['sortBy', 'sortDirection'],
  },
  // Activity/Positions market filter
  {
    name: 'activity-with-market',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&market=${TRUMP_CONDITION_ID}`,
    description: 'Activity 按市场过滤',
    expectedParams: ['market'],
  },
  {
    name: 'positions-with-market',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&market=${TRUMP_CONDITION_ID}`,
    description: 'Positions 按市场过滤',
    expectedParams: ['market'],
  },
  // Value endpoint
  {
    name: 'value-endpoint',
    url: `${DATA_API}/value?user=${TEST_ADDRESS}`,
    description: 'Value 端点 - 获取账户价值',
    expectedParams: [],
  },
  // Positions redeemable/mergeable
  {
    name: 'positions-redeemable',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&redeemable=true`,
    description: 'Positions 只返回可赎回的',
    expectedParams: ['redeemable'],
  },
  {
    name: 'positions-size-threshold',
    url: `${DATA_API}/positions?user=${TEST_ADDRESS}&sizeThreshold=100`,
    description: 'Positions 最小仓位过滤',
    expectedParams: ['sizeThreshold'],
  },
];

// ===== P2: 增强功能验证 =====

const p2Tests: TestCase[] = [
  // Holders endpoint
  {
    name: 'holders-endpoint',
    url: `${DATA_API}/holders?market=${TRUMP_CONDITION_ID}&limit=5`,
    description: 'Holders 端点 - 获取市场持仓者',
    expectedParams: [],
  },
  // Trades with user
  {
    name: 'trades-with-user',
    url: `${DATA_API}/trades?user=${TEST_ADDRESS}&limit=5`,
    description: 'Trades 按用户过滤',
    expectedParams: ['user'],
  },
  // Activity sortBy/sortDirection
  {
    name: 'activity-sortby',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&sortBy=CASH`,
    description: 'Activity 按金额排序',
    expectedParams: ['sortBy'],
  },
  {
    name: 'activity-sort-direction',
    url: `${DATA_API}/activity?user=${TEST_ADDRESS}&limit=5&sortDirection=ASC`,
    description: 'Activity 排序方向',
    expectedParams: ['sortDirection'],
  },
];

async function runTest(test: TestCase): Promise<{
  name: string;
  success: boolean;
  status: number;
  dataCount?: number;
  error?: string;
  firstItem?: unknown;
}> {
  try {
    const response = await fetch(test.url);
    const status = response.status;

    if (!response.ok) {
      const text = await response.text().catch(() => '');
      return {
        name: test.name,
        success: false,
        status,
        error: text.slice(0, 200),
      };
    }

    const data = await response.json();

    return {
      name: test.name,
      success: true,
      status,
      dataCount: Array.isArray(data) ? data.length : 1,
      firstItem: Array.isArray(data) ? data[0] : data,
    };
  } catch (error) {
    return {
      name: test.name,
      success: false,
      status: 0,
      error: String(error),
    };
  }
}

async function runTestSuite(name: string, tests: TestCase[]): Promise<void> {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`🧪 ${name}`);
  console.log('='.repeat(80));

  const results = [];

  for (const test of tests) {
    console.log(`\n📡 ${test.name}: ${test.description}`);
    console.log(`   URL: ${test.url.slice(0, 100)}...`);

    const result = await runTest(test);
    results.push(result);

    if (result.success) {
      console.log(`   ✅ Status: ${result.status}, Count: ${result.dataCount}`);
      if (result.firstItem) {
        const preview = JSON.stringify(result.firstItem).slice(0, 150);
        console.log(`   📦 First: ${preview}...`);
      }
    } else {
      console.log(`   ❌ Status: ${result.status}`);
      console.log(`   ⚠️ Error: ${result.error}`);
    }
  }

  // Summary
  const passed = results.filter((r) => r.success).length;
  const failed = results.filter((r) => !r.success).length;

  console.log(`\n📊 Summary: ${passed}/${tests.length} passed, ${failed} failed`);

  if (failed > 0) {
    console.log('\n❌ Failed tests:');
    results.filter((r) => !r.success).forEach((r) => {
      console.log(`   - ${r.name}: ${r.error?.slice(0, 100)}`);
    });
  }
}

async function main(): Promise<void> {
  console.log('🚀 Data API 参数验证开始');
  console.log('Time:', new Date().toISOString());
  console.log('\nTest User: simonbanza');
  console.log('Address:', TEST_ADDRESS);
  console.log('Test Market: Trump 2024');

  // Run P0 tests
  await runTestSuite('P0: 关键功能 (时间过滤 + 分页)', p0Tests);

  // Run P1 tests
  await runTestSuite('P1: 重要功能 (排序 + 过滤 + Value)', p1Tests);

  // Run P2 tests
  await runTestSuite('P2: 增强功能 (Holders + Trades)', p2Tests);

  console.log('\n\n✅ 验证完成');
  console.log('\n📝 下一步: 根据验证结果更新 SDK 实现');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/05-verify-params-effective.ts
================================================================================
/**
 * 详细验证 - 确认参数确实生效（不只是返回 200）
 */

const DATA_API = 'https://data-api.polymarket.com';

// 获取一个有活动的用户 - 从排行榜
async function getActiveUser(): Promise<string> {
  const resp = await fetch(`${DATA_API}/v1/leaderboard?limit=1`);
  const data = await resp.json() as Array<{ proxyWallet: string }>;
  return data[0]?.proxyWallet || '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';
}

interface ActivityItem {
  timestamp: number;
  [key: string]: unknown;
}

interface PositionItem {
  curCashPnl: number;
  [key: string]: unknown;
}

interface TradeItem {
  proxyWallet: string;
  [key: string]: unknown;
}

async function main(): Promise<void> {
  // 1. 获取活跃用户
  const user = await getActiveUser();
  console.log('Testing with active user:', user);

  console.log('\n=== 1. 验证 offset 分页 ===');
  // 获取前5条
  const page1 = await fetch(`${DATA_API}/activity?user=${user}&limit=5`).then((r) =>
    r.json()
  ) as ActivityItem[];
  console.log('Page 1 (offset=0, limit=5):', page1.length, 'items');
  if (page1.length > 0) {
    console.log('  First item timestamp:', page1[0]?.timestamp);
  }

  // 获取 offset=5 的5条
  const page2 = await fetch(
    `${DATA_API}/activity?user=${user}&limit=5&offset=5`
  ).then((r) => r.json()) as ActivityItem[];
  console.log('Page 2 (offset=5, limit=5):', page2.length, 'items');
  if (page2.length > 0) {
    console.log('  First item timestamp:', page2[0]?.timestamp);
  }

  // 验证两页不重复
  if (page1.length > 0 && page2.length > 0) {
    const page1LastTs = page1[page1.length - 1]?.timestamp;
    const page2FirstTs = page2[0]?.timestamp;
    console.log('  Page1 last:', page1LastTs, '-> Page2 first:', page2FirstTs);
    console.log(
      '  ✅ Offset 验证:',
      page1LastTs !== page2FirstTs ? '不同数据，有效' : '⚠️ 可能重复'
    );
  }

  console.log('\n=== 2. 验证 start/end 时间过滤 ===');
  // 获取所有 (无时间过滤)
  const allActivity = await fetch(
    `${DATA_API}/activity?user=${user}&limit=20`
  ).then((r) => r.json()) as ActivityItem[];
  console.log('Without time filter:', allActivity.length, 'items');

  if (allActivity.length > 0) {
    const timestamps = allActivity.map((a) => a.timestamp);
    const minTs = Math.min(...timestamps);
    const maxTs = Math.max(...timestamps);
    console.log(
      '  Time range:',
      new Date(minTs * 1000).toISOString(),
      'to',
      new Date(maxTs * 1000).toISOString()
    );

    // 用中间时间点过滤
    const midTs = Math.floor((minTs + maxTs) / 2);
    console.log(
      '  Mid timestamp:',
      midTs,
      '=',
      new Date(midTs * 1000).toISOString()
    );

    // start = midTs (只要之后的)
    const afterMid = await fetch(
      `${DATA_API}/activity?user=${user}&limit=20&start=${midTs}`
    ).then((r) => r.json()) as ActivityItem[];
    console.log('  With start=' + midTs + ':', afterMid.length, 'items');

    // end = midTs (只要之前的)
    const beforeMid = await fetch(
      `${DATA_API}/activity?user=${user}&limit=20&end=${midTs}`
    ).then((r) => r.json()) as ActivityItem[];
    console.log('  With end=' + midTs + ':', beforeMid.length, 'items');

    console.log(
      '  ✅ Time filter 验证:',
      afterMid.length < allActivity.length ||
        beforeMid.length < allActivity.length
        ? '有效 (返回数量减少)'
        : '⚠️ 可能无效'
    );
  }

  console.log('\n=== 3. 验证 Positions 排序 ===');
  const positions = await fetch(`${DATA_API}/positions?user=${user}`).then((r) =>
    r.json()
  ) as PositionItem[];
  console.log('Positions count:', positions.length);

  if (positions.length > 1) {
    // 按 CASHPNL 排序
    const sortedAsc = await fetch(
      `${DATA_API}/positions?user=${user}&sortBy=CASHPNL&sortDirection=ASC`
    ).then((r) => r.json()) as PositionItem[];
    const sortedDesc = await fetch(
      `${DATA_API}/positions?user=${user}&sortBy=CASHPNL&sortDirection=DESC`
    ).then((r) => r.json()) as PositionItem[];

    if (sortedAsc.length > 0 && sortedDesc.length > 0) {
      console.log('  ASC first PnL:', sortedAsc[0]?.curCashPnl);
      console.log('  DESC first PnL:', sortedDesc[0]?.curCashPnl);
      console.log(
        '  ✅ Sort 验证:',
        sortedAsc[0]?.curCashPnl !== sortedDesc[0]?.curCashPnl
          ? '有效 (顺序不同)'
          : '⚠️ 可能无效'
      );
    }
  }

  console.log('\n=== 4. 验证 Value 端点 ===');
  const value = await fetch(`${DATA_API}/value?user=${user}`).then((r) =>
    r.json()
  ) as Record<string, unknown>;
  console.log('Value response:', JSON.stringify(value));
  console.log(
    '  ✅ Value 端点:',
    value && 'value' in value ? '有效' : '⚠️ 可能无效'
  );

  console.log('\n=== 5. 验证 Trades user 参数 ===');
  const trades = await fetch(`${DATA_API}/trades?user=${user}&limit=5`).then(
    (r) => r.json()
  ) as TradeItem[];
  console.log('Trades by user:', trades.length, 'items');
  if (trades.length > 0) {
    console.log('  First trade user:', trades[0]?.proxyWallet);
    console.log(
      '  ✅ Trades user 验证:',
      trades[0]?.proxyWallet?.toLowerCase() === user.toLowerCase()
        ? '有效 (用户匹配)'
        : '⚠️ 用户不匹配'
    );
  }

  console.log('\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/06-test-new-features.ts
================================================================================
/**
 * 测试 P0/P1/P2 新功能
 *
 * 验证 DataApiClient 新增的参数支持是否正确工作
 */

import { DataApiClient } from '../../src/clients/data-api.js';
import { RateLimiter } from '../../src/core/rate-limiter.js';
import { createUnifiedCache } from '../../src/core/unified-cache.js';

const DATA_API = 'https://data-api.polymarket.com';

async function main(): Promise<void> {
  console.log('🧪 测试 P0/P1/P2 新功能\n');

  // 初始化客户端
  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const client = new DataApiClient(rateLimiter, cache);

  // 获取活跃用户
  const leaderboard = await client.getLeaderboard({ limit: 1 });
  const user = leaderboard.entries[0]?.address;
  console.log('测试用户:', user);

  // ===== P0 测试 =====
  console.log('\n=== P0: 时间过滤 + 分页 ===');

  // 1. Activity offset 分页
  console.log('\n📌 Activity offset 分页:');
  const page1 = await client.getActivity(user, { limit: 5 });
  const page2 = await client.getActivity(user, { limit: 5, offset: 5 });
  console.log(`  Page 1: ${page1.length} items, first ts: ${page1[0]?.timestamp}`);
  console.log(`  Page 2: ${page2.length} items, first ts: ${page2[0]?.timestamp}`);
  console.log(`  ✅ Offset 分页: ${page1[0]?.timestamp !== page2[0]?.timestamp ? '有效' : '⚠️ 可能无效'}`);

  // 2. Activity start/end 时间过滤
  console.log('\n📌 Activity start/end 时间过滤:');
  const allActivity = await client.getActivity(user, { limit: 20 });
  if (allActivity.length > 0) {
    const timestamps = allActivity.map((a) => Math.floor(a.timestamp / 1000)); // 转回秒
    const midTs = Math.floor((Math.min(...timestamps) + Math.max(...timestamps)) / 2);

    const afterMid = await client.getActivity(user, { limit: 20, start: midTs });
    const beforeMid = await client.getActivity(user, { limit: 20, end: midTs });

    console.log(`  All: ${allActivity.length}, After mid: ${afterMid.length}, Before mid: ${beforeMid.length}`);
    console.log(`  ✅ 时间过滤: ${afterMid.length < allActivity.length || beforeMid.length < allActivity.length ? '有效' : '⚠️ 可能无效'}`);
  }

  // 3. Positions limit/offset
  console.log('\n📌 Positions limit/offset:');
  const pos1 = await client.getPositions(user, { limit: 5 });
  const pos2 = await client.getPositions(user, { limit: 5, offset: 5 });
  console.log(`  Page 1: ${pos1.length} positions`);
  console.log(`  Page 2: ${pos2.length} positions`);
  console.log(`  ✅ Positions 分页: ${pos1.length > 0 || pos2.length > 0 ? '有效' : '无数据'}`);

  // ===== P1 测试 =====
  console.log('\n=== P1: 排序 + Value ===');

  // 4. Positions sortBy
  console.log('\n📌 Positions sortBy CASHPNL:');
  const posAsc = await client.getPositions(user, { sortBy: 'CASHPNL', sortDirection: 'ASC', limit: 3 });
  const posDesc = await client.getPositions(user, { sortBy: 'CASHPNL', sortDirection: 'DESC', limit: 3 });
  if (posAsc.length > 0 && posDesc.length > 0) {
    console.log(`  ASC first: ${posAsc[0]?.title?.slice(0, 30)} = $${posAsc[0]?.cashPnl?.toFixed(2)}`);
    console.log(`  DESC first: ${posDesc[0]?.title?.slice(0, 30)} = $${posDesc[0]?.cashPnl?.toFixed(2)}`);
    console.log(`  ✅ 排序: ${(posAsc[0]?.cashPnl ?? 0) < (posDesc[0]?.cashPnl ?? 0) ? '有效' : '⚠️ 可能无效'}`);
  }

  // 5. Value 端点
  console.log('\n📌 Value 端点:');
  const value = await client.getAccountValue(user);
  console.log(`  User: ${value.user}`);
  console.log(`  Value: $${value.value.toLocaleString()}`);
  console.log(`  ✅ Value 端点: ${value.value > 0 ? '有效' : '⚠️ 值为0'}`);

  // ===== P2 测试 =====
  console.log('\n=== P2: Trades user + Holders ===');

  // 6. Trades user 参数
  console.log('\n📌 Trades user 参数:');
  const userTrades = await client.getTradesByUser(user, { limit: 5 });
  console.log(`  User trades: ${userTrades.length} items`);
  if (userTrades.length > 0) {
    console.log(`  First trade: ${userTrades[0]?.title?.slice(0, 30)} @ $${userTrades[0]?.price?.toFixed(3)}`);
    console.log(`  ✅ Trades user: ${userTrades[0]?.proxyWallet?.toLowerCase() === user.toLowerCase() ? '有效' : '⚠️ 用户不匹配'}`);
  }

  // 7. Holders 端点 (可能超时)
  console.log('\n📌 Holders 端点:');
  try {
    // 用一个较小的市场测试
    const markets = await client.getPositions(user, { limit: 1 });
    if (markets.length > 0) {
      const conditionId = markets[0].conditionId;
      console.log(`  Testing market: ${conditionId.slice(0, 20)}...`);
      const holders = await client.getMarketHolders({ market: conditionId, limit: 5 });
      console.log(`  Holders: ${holders.length} items`);
      console.log(`  ✅ Holders 端点: 有效`);
    }
  } catch (error) {
    console.log(`  ⚠️ Holders 端点: ${String(error).slice(0, 50)}`);
  }

  // ===== 额外测试: getAllActivity =====
  console.log('\n=== 额外: getAllActivity 自动分页 ===');
  const dayAgo = Math.floor(Date.now() / 1000) - 86400;
  const allRecentActivity = await client.getAllActivity(user, { start: dayAgo }, 100);
  console.log(`  最近24小时活动: ${allRecentActivity.length} items`);

  console.log('\n✅ 所有测试完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/11-test-subgraph-client.ts
================================================================================
/**
 * 测试 SubgraphClient 功能
 */

import { SubgraphClient } from '../../src/clients/subgraph.js';
import { RateLimiter } from '../../src/core/rate-limiter.js';
import { createUnifiedCache } from '../../src/core/unified-cache.js';

const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';

async function main(): Promise<void> {
  console.log('🧪 测试 SubgraphClient\n');

  // 初始化
  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const client = new SubgraphClient(rateLimiter, cache);

  // ===== PnL Subgraph =====
  console.log('='.repeat(60));
  console.log('📊 1. PnL Subgraph');
  console.log('='.repeat(60));

  // getUserPositions
  console.log('\n📌 getUserPositions:');
  const positions = await client.getUserPositions(TEST_ADDRESS, { first: 3 });
  console.log(`  Found ${positions.length} positions`);
  if (positions.length > 0) {
    console.log(`  First: tokenId=${positions[0].tokenId.slice(0, 20)}... realizedPnl=${positions[0].realizedPnl}`);
  }

  // getConditions
  console.log('\n📌 getConditions:');
  const conditions = await client.getConditions({ first: 3 });
  console.log(`  Found ${conditions.length} conditions`);
  if (conditions.length > 0) {
    console.log(`  First: id=${conditions[0].id.slice(0, 20)}... resolved=${conditions[0].payoutNumerators.length > 0}`);
  }

  // isConditionResolved
  if (conditions.length > 0) {
    console.log('\n📌 isConditionResolved:');
    const isResolved = await client.isConditionResolved(conditions[0].id);
    console.log(`  Condition ${conditions[0].id.slice(0, 20)}... resolved=${isResolved}`);
  }

  // ===== Activity Subgraph =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 2. Activity Subgraph');
  console.log('='.repeat(60));

  // getRecentRedemptions
  console.log('\n📌 getRecentRedemptions:');
  const redemptions = await client.getRecentRedemptions({ first: 5 });
  console.log(`  Found ${redemptions.length} recent redemptions`);
  if (redemptions.length > 0) {
    const r = redemptions[0];
    console.log(`  Latest: redeemer=${r.redeemer.slice(0, 10)}... payout=${r.payout} ts=${r.timestamp}`);
  }

  // getSplits
  console.log('\n📌 getSplits (any user):');
  const splits = await client.getSplits('0x0000000000000000000000000000000000000000', { first: 1 });
  // Use recent redemptions to find an active user
  if (redemptions.length > 0) {
    const activeUser = redemptions[0].redeemer;
    const userSplits = await client.getSplits(activeUser, { first: 3 });
    console.log(`  User ${activeUser.slice(0, 10)}... has ${userSplits.length} splits`);
  }

  // ===== OI Subgraph =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 3. OI Subgraph');
  console.log('='.repeat(60));

  // getTopMarketsByOI
  console.log('\n📌 getTopMarketsByOI:');
  const topMarkets = await client.getTopMarketsByOI({ first: 5 });
  console.log(`  Found ${topMarkets.length} markets`);
  topMarkets.slice(0, 3).forEach((m, i) => {
    const oiUsd = (BigInt(m.amount) / BigInt(1e6)).toString();
    console.log(`  ${i + 1}. ${m.id.slice(0, 20)}... OI=$${Number(oiUsd).toLocaleString()}`);
  });

  // getGlobalOpenInterest
  console.log('\n📌 getGlobalOpenInterest:');
  const globalOI = await client.getGlobalOpenInterest();
  const globalOIUsd = (BigInt(globalOI) / BigInt(1e6)).toString();
  console.log(`  Global OI: $${Number(globalOIUsd).toLocaleString()}`);

  // getMarketOpenInterest
  if (topMarkets.length > 0) {
    console.log('\n📌 getMarketOpenInterest:');
    const marketOI = await client.getMarketOpenInterest(topMarkets[0].id);
    if (marketOI) {
      const oiUsd = (BigInt(marketOI.amount) / BigInt(1e6)).toString();
      console.log(`  Market ${marketOI.id.slice(0, 20)}... OI=$${Number(oiUsd).toLocaleString()}`);
    }
  }

  // ===== Orderbook Subgraph =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 4. Orderbook Subgraph');
  console.log('='.repeat(60));

  // getOrderFilledEvents
  console.log('\n📌 getOrderFilledEvents:');
  const fills = await client.getOrderFilledEvents({ first: 5 });
  console.log(`  Found ${fills.length} recent fills`);
  if (fills.length > 0) {
    const f = fills[0];
    console.log(`  Latest: maker=${f.maker.slice(0, 10)}... taker=${f.taker.slice(0, 10)}...`);
    console.log(`          makerFilled=${f.makerAmountFilled} takerFilled=${f.takerAmountFilled}`);
  }

  // getMakerFills
  if (fills.length > 0) {
    console.log('\n📌 getMakerFills:');
    const makerFills = await client.getMakerFills(fills[0].maker, { first: 3 });
    console.log(`  Maker ${fills[0].maker.slice(0, 10)}... has ${makerFills.length} fills`);
  }

  // ===== 综合测试 =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 5. 综合测试: getUserActivitySummary');
  console.log('='.repeat(60));

  // 使用一个活跃用户
  if (fills.length > 0) {
    const activeUser = fills[0].maker;
    console.log(`\n📌 User: ${activeUser}`);

    const summary = await client.getUserActivitySummary(activeUser);
    console.log(`  Positions: ${summary.positions.length}`);
    console.log(`  Splits: ${summary.splits.length}`);
    console.log(`  Merges: ${summary.merges.length}`);
    console.log(`  Redemptions: ${summary.redemptions.length}`);
    console.log(`  Maker Fills: ${summary.makerFills.length}`);
    console.log(`  Taker Fills: ${summary.takerFills.length}`);
  }

  // ===== 缓存测试 =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 6. 缓存测试');
  console.log('='.repeat(60));

  console.log('\n📌 第一次请求 (无缓存):');
  const start1 = Date.now();
  await client.getGlobalOpenInterest();
  console.log(`  耗时: ${Date.now() - start1}ms`);

  console.log('\n📌 第二次请求 (有缓存):');
  const start2 = Date.now();
  await client.getGlobalOpenInterest();
  console.log(`  耗时: ${Date.now() - start2}ms`);

  console.log('\n✅ SubgraphClient 测试完成');
}

main().catch(console.error);

================================================================================
// File: scripts/api-verification/12-test-period-leaderboard.ts
================================================================================
/**
 * 测试时间段排行榜功能
 * - getLeaderboardByPeriod: 按时间段获取排行榜
 * - getWalletStatsByPeriod: 按时间段获取单个钱包统计
 */

import { PolymarketSDK } from '../../src/index.js';

const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';

async function main(): Promise<void> {
  console.log('🧪 测试时间段排行榜功能\n');

  const sdk = new PolymarketSDK();

  // ===== 1. 测试时间段排行榜 =====
  console.log('='.repeat(60));
  console.log('📊 1. 时间段排行榜 (getLeaderboardByPeriod)');
  console.log('='.repeat(60));

  const periods = ['day', 'week', 'month'] as const;

  for (const period of periods) {
    console.log(`\n📌 Period: ${period}`);
    const start = Date.now();

    try {
      const leaderboard = await sdk.wallets.getLeaderboardByPeriod(period, 5);
      console.log(`  ⏱️ 耗时: ${Date.now() - start}ms`);
      console.log(`  📈 Top ${leaderboard.length} traders:`);

      leaderboard.forEach((entry, i) => {
        console.log(`    ${i + 1}. ${entry.address.slice(0, 10)}... Volume: $${entry.volume.toLocaleString(undefined, { maximumFractionDigits: 2 })}`);
        console.log(`       Trades: ${entry.tradeCount} | Maker: $${entry.makerVolume.toFixed(2)} | Taker: $${entry.takerVolume.toFixed(2)}`);
      });
    } catch (error) {
      console.log(`  ❌ Error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // ===== 2. 测试单个钱包时间段统计 =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 2. 钱包时间段统计 (getWalletStatsByPeriod)');
  console.log('='.repeat(60));

  console.log(`\n📌 Wallet: ${TEST_ADDRESS}`);

  for (const period of periods) {
    console.log(`\n  📅 Period: ${period}`);
    const start = Date.now();

    try {
      const stats = await sdk.wallets.getWalletStatsByPeriod(TEST_ADDRESS, period);
      console.log(`    ⏱️ 耗时: ${Date.now() - start}ms`);
      console.log(`    📈 Volume: $${stats.volume.toLocaleString(undefined, { maximumFractionDigits: 2 })}`);
      console.log(`    📊 Trades: ${stats.tradeCount} (Maker: ${stats.makerCount}, Taker: ${stats.takerCount})`);
      console.log(`    🔄 On-chain: Splits: ${stats.splitCount}, Merges: ${stats.mergeCount}, Redemptions: ${stats.redemptionCount}`);
      if (stats.redemptionPayout > 0) {
        console.log(`    💰 Redemption Payout: $${stats.redemptionPayout.toFixed(2)}`);
      }
    } catch (error) {
      console.log(`    ❌ Error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // ===== 3. 对比全时间排行榜 =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 3. 对比: 全时间 vs 本周排行榜');
  console.log('='.repeat(60));

  try {
    const [allTime, weekly] = await Promise.all([
      sdk.dataApi\.fetchLeaderboard({ limit: 5 }),
      sdk.wallets.getLeaderboardByPeriod('week', 5),
    ]);

    console.log('\n📌 全时间排行榜 (Data API):');
    allTime.entries.forEach((e, i) => {
      console.log(`  ${i + 1}. ${e.address.slice(0, 10)}... PnL: $${e.pnl.toLocaleString()}`);
    });

    console.log('\n📌 本周排行榜 (Subgraph):');
    weekly.forEach((e, i) => {
      console.log(`  ${i + 1}. ${e.address.slice(0, 10)}... Volume: $${e.volume.toLocaleString(undefined, { maximumFractionDigits: 2 })}`);
    });
  } catch (error) {
    console.log(`❌ Error: ${error instanceof Error ? error.message : String(error)}`);
  }

  // ===== 4. 缓存测试 =====
  console.log('\n' + '='.repeat(60));
  console.log('📊 4. 缓存测试');
  console.log('='.repeat(60));

  console.log('\n📌 第一次请求 (无缓存):');
  const start1 = Date.now();
  await sdk.wallets.getLeaderboardByPeriod('day', 3);
  console.log(`  ⏱️ 耗时: ${Date.now() - start1}ms`);

  console.log('\n📌 第二次请求 (有缓存):');
  const start2 = Date.now();
  await sdk.wallets.getLeaderboardByPeriod('day', 3);
  console.log(`  ⏱️ 耗时: ${Date.now() - start2}ms`);

  console.log('\n✅ 测试完成');
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/approve-erc1155.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Approve ERC1155 for selling YES/NO tokens
 *
 * This sets setApprovalForAll on the Conditional Tokens contract
 * to allow the exchanges to transfer your YES/NO tokens.
 */

import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = match ? match[1].trim() : '';

if (!PRIVATE_KEY) {
  console.error('PRIVATE_KEY not found');
  process.exit(1);
}

// Contract addresses
const CONDITIONAL_TOKENS = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';
const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';

const ERC1155_ABI = [
  'function setApprovalForAll(address operator, bool approved) external',
  'function isApprovedForAll(address account, address operator) view returns (bool)',
];

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║       ERC1155 APPROVAL FOR SELLING YES/NO TOKENS                ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  const rpcs = [
    'https://polygon-bor-rpc.publicnode.com',
    'https://polygon.drpc.org',
    'https://polygon-rpc.com',
  ];

  for (const rpc of rpcs) {
    console.log(`Trying RPC: ${rpc}`);
    try {
      const provider = new ethers.providers.JsonRpcProvider({
        url: rpc,
        timeout: 30000,
      });

      const network = await provider.getNetwork();
      console.log(`Connected to chain ${network.chainId}`);

      const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
      console.log(`Wallet: ${wallet.address}`);
      console.log('');

      const conditionalTokens = new ethers.Contract(CONDITIONAL_TOKENS, ERC1155_ABI, wallet);

      const operators = [
        { name: 'CTF Exchange', address: CTF_EXCHANGE },
        { name: 'Neg Risk CTF Exchange', address: NEG_RISK_CTF_EXCHANGE },
      ];

      // Check current approvals
      console.log('─── Current ERC1155 Approvals ───');
      let needsApproval = [];

      for (const op of operators) {
        const isApproved = await conditionalTokens.isApprovedForAll(wallet.address, op.address);
        console.log(`${op.name}: ${isApproved ? '✅ Approved' : '❌ Not Approved'}`);
        if (!isApproved) {
          needsApproval.push(op);
        }
      }
      console.log('');

      if (needsApproval.length === 0) {
        console.log('✅ All ERC1155 approvals are set!');
        return;
      }

      // Approve missing operators
      console.log('─── Setting Approvals ───');
      const gasPrice = await provider.getGasPrice();
      const adjustedGas = gasPrice.mul(2);
      console.log(`Gas price: ${ethers.utils.formatUnits(adjustedGas, 'gwei')} Gwei`);
      console.log('');

      for (const op of needsApproval) {
        console.log(`Approving ${op.name}...`);
        try {
          const tx = await conditionalTokens.setApprovalForAll(op.address, true, {
            gasPrice: adjustedGas,
            gasLimit: 100000,
          });
          console.log(`  TX: ${tx.hash}`);
          const receipt = await tx.wait();
          console.log(`  ✅ Confirmed in block ${receipt.blockNumber}`);
        } catch (error: any) {
          console.log(`  ❌ Failed: ${error.message}`);
        }
      }

      console.log('');
      console.log('─── Verifying Approvals ───');
      for (const op of operators) {
        const isApproved = await conditionalTokens.isApprovedForAll(wallet.address, op.address);
        console.log(`${op.name}: ${isApproved ? '✅ Approved' : '❌ Not Approved'}`);
      }

      return;
    } catch (error: any) {
      console.log(`Failed: ${error.message}`);
      console.log('');
    }
  }

  console.log('❌ All RPCs failed!');
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/approve-neg-risk-erc1155.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Check and Approve ERC1155 for Neg Risk Adapter
 *
 * 检查并授权 Neg Risk Adapter 的 ERC1155 转账权限
 * 这可能是 SELL 订单在 Neg Risk 市场失败的原因
 */

import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = match ? match[1].trim() : '';

if (!PRIVATE_KEY) {
  console.error('PRIVATE_KEY not found');
  process.exit(1);
}

// Contract addresses
const CONDITIONAL_TOKENS = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';
const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';
const NEG_RISK_ADAPTER = '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296';

const ERC1155_ABI = [
  'function setApprovalForAll(address operator, bool approved) external',
  'function isApprovedForAll(address account, address operator) view returns (bool)',
  'function balanceOf(address account, uint256 id) view returns (uint256)',
];

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║   NEG RISK ERC1155 AUTHORIZATION CHECK                          ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  const rpcs = [
    'https://polygon-bor-rpc.publicnode.com',
    'https://polygon.drpc.org',
    'https://polygon-rpc.com',
  ];

  for (const rpc of rpcs) {
    console.log(`Trying RPC: ${rpc}`);
    try {
      const provider = new ethers.providers.JsonRpcProvider({
        url: rpc,
        timeout: 30000,
      });

      const network = await provider.getNetwork();
      console.log(`Connected to chain ${network.chainId}`);

      const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
      console.log(`Wallet: ${wallet.address}`);
      console.log('');

      const conditionalTokens = new ethers.Contract(CONDITIONAL_TOKENS, ERC1155_ABI, wallet);

      // All operators to check
      const operators = [
        { name: 'CTF Exchange', address: CTF_EXCHANGE },
        { name: 'Neg Risk CTF Exchange', address: NEG_RISK_CTF_EXCHANGE },
        { name: 'Neg Risk Adapter', address: NEG_RISK_ADAPTER },
      ];

      // Check current approvals
      console.log('─── Current ERC1155 Approvals (Conditional Tokens) ───');
      let needsApproval = [];

      for (const op of operators) {
        const isApproved = await conditionalTokens.isApprovedForAll(wallet.address, op.address);
        console.log(`${op.name}: ${isApproved ? '✅ Approved' : '❌ Not Approved'}`);
        if (!isApproved) {
          needsApproval.push(op);
        }
      }
      console.log('');

      // Check token balances (YES and NO for NVIDIA market)
      const yesTokenId = '94850533403292240972948844256810904078895883844462287088135166537739765648754';
      const noTokenId = '69263280792958981516606123639467754139758192236863611059536531765186180114584';

      console.log('─── Token Balances ───');
      const yesBalance = await conditionalTokens.balanceOf(wallet.address, yesTokenId);
      const noBalance = await conditionalTokens.balanceOf(wallet.address, noTokenId);
      console.log(`YES Token: ${ethers.utils.formatUnits(yesBalance, 6)} tokens`);
      console.log(`NO Token: ${ethers.utils.formatUnits(noBalance, 6)} tokens`);
      console.log('');

      if (needsApproval.length === 0) {
        console.log('✅ All ERC1155 approvals are set!');
        console.log('');
        console.log('If SELL orders are still failing, the issue might be:');
        console.log('1. Neg Risk market uses wrapped tokens through the Adapter');
        console.log('2. The CLOB might require a different approval mechanism');
        console.log('3. Check if tokens need to be "unwrapped" before selling');
        return;
      }

      // Approve missing operators
      console.log('─── Setting Approvals ───');
      const gasPrice = await provider.getGasPrice();
      const adjustedGas = gasPrice.mul(2);
      console.log(`Gas price: ${ethers.utils.formatUnits(adjustedGas, 'gwei')} Gwei`);
      console.log('');

      for (const op of needsApproval) {
        console.log(`Approving ${op.name}...`);
        try {
          const tx = await conditionalTokens.setApprovalForAll(op.address, true, {
            gasPrice: adjustedGas,
            gasLimit: 100000,
          });
          console.log(`  TX: ${tx.hash}`);
          const receipt = await tx.wait();
          console.log(`  ✅ Confirmed in block ${receipt.blockNumber}`);
        } catch (error: any) {
          console.log(`  ❌ Failed: ${error.message}`);
        }
      }

      console.log('');
      console.log('─── Verifying Approvals ───');
      for (const op of operators) {
        const isApproved = await conditionalTokens.isApprovedForAll(wallet.address, op.address);
        console.log(`${op.name}: ${isApproved ? '✅ Approved' : '❌ Not Approved'}`);
      }

      return;
    } catch (error: any) {
      console.log(`Failed: ${error.message}`);
      console.log('');
    }
  }

  console.log('❌ All RPCs failed!');
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/approve-neg-risk.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Simple script to approve Neg Risk Adapter
 */

import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = match ? match[1].trim() : '';

if (!PRIVATE_KEY) {
  console.error('PRIVATE_KEY not found');
  process.exit(1);
}

const USDC_E = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const NEG_RISK_ADAPTER = '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296';

const ERC20_ABI = [
  'function approve(address spender, uint256 amount) returns (bool)',
  'function allowance(address owner, address spender) view returns (uint256)',
];

async function main() {
  console.log('Approving Neg Risk Adapter...');

  // Try multiple RPCs
  const rpcs = [
    'https://polygon-bor-rpc.publicnode.com',
    'https://polygon.drpc.org',
    'https://polygon-rpc.com',
  ];

  for (const rpc of rpcs) {
    console.log(`\nTrying RPC: ${rpc}`);
    try {
      const provider = new ethers.providers.JsonRpcProvider({
        url: rpc,
        timeout: 30000,
      });

      // Test connection
      const network = await provider.getNetwork();
      console.log(`Connected to chain ${network.chainId}`);

      const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
      console.log(`Wallet: ${wallet.address}`);

      const usdc = new ethers.Contract(USDC_E, ERC20_ABI, wallet);

      // Check current allowance
      const currentAllowance = await usdc.allowance(wallet.address, NEG_RISK_ADAPTER);
      console.log(`Current allowance: ${ethers.utils.formatUnits(currentAllowance, 6)} USDC`);

      if (currentAllowance.gt(ethers.utils.parseUnits('1000000000', 6))) {
        console.log('✅ Already approved!');
        return;
      }

      // Get gas price
      const gasPrice = await provider.getGasPrice();
      const adjustedGas = gasPrice.mul(2); // 2x for safety
      console.log(`Gas price: ${ethers.utils.formatUnits(adjustedGas, 'gwei')} Gwei`);

      // Approve
      console.log('Sending approval transaction...');
      const tx = await usdc.approve(NEG_RISK_ADAPTER, ethers.constants.MaxUint256, {
        gasPrice: adjustedGas,
        gasLimit: 100000,
      });

      console.log(`TX Hash: ${tx.hash}`);
      console.log('Waiting for confirmation...');

      const receipt = await tx.wait();
      console.log(`✅ Confirmed in block ${receipt.blockNumber}`);

      // Verify
      const newAllowance = await usdc.allowance(wallet.address, NEG_RISK_ADAPTER);
      console.log(`New allowance: Unlimited`);

      return;
    } catch (error: any) {
      console.log(`Failed: ${error.message}`);
    }
  }

  console.log('\n❌ All RPCs failed!');
  console.log('Please approve manually on Polygonscan:');
  console.log('https://polygonscan.com/token/0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174#writeContract');
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/check-all-allowances.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Check all Polymarket contract allowances
 */

import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key from dashboard-api .env
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = match ? match[1].trim() : '';

if (!PRIVATE_KEY) {
  console.error('Error: PRIVATE_KEY not found in .env');
  process.exit(1);
}

// Contract addresses on Polygon
const USDC_E_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';
const NEG_RISK_ADAPTER = '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296';

// Additional contracts that might need approval
const CONDITIONAL_TOKENS = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';

const ERC20_ABI = [
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)',
];

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║       POLYMARKET ALLOWANCE CHECKER (ALL CONTRACTS)              ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  // Use multiple RPC providers for reliability
  const rpcUrls = [
    'https://polygon-mainnet.g.alchemy.com/v2/demo',
    'https://polygon.llamarpc.com',
    'https://polygon-rpc.com',
  ];

  let provider: ethers.providers.JsonRpcProvider | null = null;
  for (const rpcUrl of rpcUrls) {
    try {
      const p = new ethers.providers.JsonRpcProvider(rpcUrl);
      await p.getNetwork(); // Test connection
      provider = p;
      console.log(`Using RPC: ${rpcUrl}`);
      break;
    } catch (e) {
      console.log(`RPC failed: ${rpcUrl}`);
    }
  }

  if (!provider) {
    console.error('All RPC providers failed!');
    process.exit(1);
  }
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
  const address = wallet.address;
  const usdc = new ethers.Contract(USDC_E_ADDRESS, ERC20_ABI, wallet);

  console.log(`Wallet: ${address}`);
  console.log('');

  // Check USDC balance
  const balance = await usdc.balanceOf(address);
  console.log(`USDC.e Balance: ${(parseFloat(balance.toString()) / 1e6).toFixed(6)} USDC`);
  console.log('');

  // Check all allowances
  console.log('─── Contract Allowances ───');

  const contracts = [
    { name: 'CTF Exchange', address: CTF_EXCHANGE },
    { name: 'Neg Risk CTF Exchange', address: NEG_RISK_CTF_EXCHANGE },
    { name: 'Neg Risk Adapter', address: NEG_RISK_ADAPTER },
    { name: 'Conditional Tokens', address: CONDITIONAL_TOKENS },
  ];

  let needsApproval = [];

  for (const contract of contracts) {
    const allowance = await usdc.allowance(address, contract.address);
    const allowanceNum = parseFloat(allowance.toString()) / 1e6;
    const isUnlimited = allowanceNum > 1e12;
    const status = isUnlimited ? '✅ Unlimited' : allowanceNum > 0 ? `⚠️ ${allowanceNum.toFixed(2)}` : '❌ None';
    console.log(`${contract.name}: ${status}`);
    if (!isUnlimited) {
      needsApproval.push(contract);
    }
  }

  console.log('');

  if (needsApproval.length > 0) {
    console.log('─── Approval Needed ───');
    console.log('The following contracts need unlimited approval:');
    for (const contract of needsApproval) {
      console.log(`  - ${contract.name} (${contract.address})`);
    }
    console.log('');
    console.log('Run with --approve flag to approve all:');
    console.log('  npx tsx scripts/check-all-allowances.ts --approve');
    console.log('');

    if (process.argv.includes('--approve')) {
      console.log('─── Approving Contracts ───');
      const MAX_UINT256 = ethers.constants.MaxUint256;

      // Get current gas price and add buffer for Polygon
      const gasPrice = await provider.getGasPrice();
      const adjustedGasPrice = gasPrice.mul(150).div(100); // 1.5x current gas price
      console.log(`Using gas price: ${(adjustedGasPrice.toNumber() / 1e9).toFixed(2)} Gwei`);

      for (const contract of needsApproval) {
        console.log(`Approving ${contract.name}...`);
        try {
          const tx = await usdc.approve(contract.address, MAX_UINT256, { gasPrice: adjustedGasPrice });
          console.log(`  TX: ${tx.hash}`);
          await tx.wait();
          console.log(`  ✓ Approved`);
        } catch (error: any) {
          console.log(`  ✗ Failed: ${error.message}`);
        }
      }
      console.log('');
      console.log('✅ Done! Please re-run without --approve to verify.');
    }
  } else {
    console.log('✅ All contracts have unlimited approval!');
    console.log('');
    console.log('If orders are still failing, the issue may be:');
    console.log('1. Polymarket requires a deposit via their UI to create a trading account');
    console.log('2. Or there may be a different issue with the API key');
  }
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/check-allowance.ts
================================================================================
/**
 * Check and Set USDC.e Allowance for Polymarket Trading
 *
 * Usage:
 *   # Check current allowance
 *   POLY_PRIVKEY=0x... npx tsx scripts/check-allowance.ts
 *
 *   # Approve unlimited allowance
 *   POLY_PRIVKEY=0x... npx tsx scripts/check-allowance.ts approve
 */

import { TradingService, RateLimiter, createUnifiedCache } from '../../src/index.js';

const PRIVATE_KEY = process.env.POLY_PRIVKEY || '';

async function main() {
  if (!PRIVATE_KEY) {
    console.error('Error: Set POLY_PRIVKEY environment variable');
    process.exit(1);
  }

  const command = process.argv[2] || 'check';

  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║       POLYMARKET ALLOWANCE CHECKER                              ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: PRIVATE_KEY,
    chainId: 137,
  });

  await tradingService.initialize();
  console.log(`Wallet: ${tradingService.getAddress()}`);
  console.log('');

  // Check current balance and allowance
  console.log('─── Current Status ───');
  const { balance, allowance } = await tradingService.getBalanceAllowance('COLLATERAL');

  const balanceUsdc = parseFloat(balance) / 1e6;
  const allowanceUsdc = allowance ? parseFloat(allowance) / 1e6 : Infinity;

  console.log(`USDC.e Balance:   ${balanceUsdc.toFixed(6)} USDC`);
  console.log(`USDC.e Allowance: ${allowance === 'unlimited' || allowanceUsdc > 1e12 ? 'Unlimited' : allowanceUsdc.toFixed(6) + ' USDC'}`);
  console.log('');

  // Check if allowance is sufficient
  if (allowanceUsdc < balanceUsdc) {
    console.log('⚠️  Warning: Allowance is less than balance!');
    console.log('   This may cause "not enough balance / allowance" errors.');
    console.log('   Run with "approve" argument to fix.');
    console.log('');
  }

  if (command === 'approve') {
    console.log('─── Approving Unlimited Allowance ───');
    console.log('This will approve unlimited USDC.e spending for Polymarket.');
    console.log('');

    try {
      // Get the underlying CLOB client to access approve methods
      const client = (tradingService as unknown as { clobClient: { approveCollateral: () => Promise<unknown> } }).clobClient;

      if (client && typeof client.approveCollateral === 'function') {
        console.log('Sending approval transaction...');
        const result = await client.approveCollateral();
        console.log('Approval result:', result);
      } else {
        // Manual approval using ethers
        console.log('Using direct contract call...');

        const { ethers } = await import('ethers');
        const provider = new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
        const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

        // USDC.e contract on Polygon
        const USDC_E_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
        // CTF Exchange contract (where orders are executed)
        const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
        // Neg Risk CTF Exchange
        const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';

        const ERC20_ABI = [
          'function approve(address spender, uint256 amount) returns (bool)',
          'function allowance(address owner, address spender) view returns (uint256)',
        ];

        const usdc = new ethers.Contract(USDC_E_ADDRESS, ERC20_ABI, wallet);
        const MAX_UINT256 = ethers.constants.MaxUint256;

        // Approve both exchanges
        console.log('');
        console.log('1. Approving CTF Exchange...');
        const tx1 = await usdc.approve(CTF_EXCHANGE, MAX_UINT256);
        console.log(`   TX: ${tx1.hash}`);
        await tx1.wait();
        console.log('   ✓ Confirmed');

        console.log('');
        console.log('2. Approving Neg Risk CTF Exchange...');
        const tx2 = await usdc.approve(NEG_RISK_CTF_EXCHANGE, MAX_UINT256);
        console.log(`   TX: ${tx2.hash}`);
        await tx2.wait();
        console.log('   ✓ Confirmed');
      }

      console.log('');
      console.log('✅ Approval complete!');

      // Re-check allowance
      const { allowance: newAllowance } = await tradingService.getBalanceAllowance('COLLATERAL');
      console.log(`New Allowance: ${newAllowance === 'unlimited' ? 'Unlimited' : newAllowance}`);

    } catch (error) {
      console.error('❌ Approval failed:', (error as Error).message);
    }
  } else {
    console.log('─── Commands ───');
    console.log('  check   - Check current allowance (default)');
    console.log('  approve - Approve unlimited allowance for trading');
    console.log('');
    console.log('Example: POLY_PRIVKEY=0x... npx tsx scripts/check-allowance.ts approve');
  }
}

main().catch(console.error);

================================================================================
// File: scripts/approvals/check-ctf-approval.ts
================================================================================
/**
 * Check and Set CTF Token Approvals for Polymarket Trading
 *
 * The CLOB Exchange requires approval for CTF tokens (ERC1155) in addition to USDC.e.
 * Without CTF token approval, orders fail with "not enough balance / allowance".
 *
 * Usage:
 *   POLY_PRIVKEY=0x... npx tsx scripts/check-ctf-approval.ts
 *   POLY_PRIVKEY=0x... npx tsx scripts/check-ctf-approval.ts approve
 */

import { ethers } from 'ethers';

const PRIVATE_KEY = process.env.POLY_PRIVKEY || '';
const RPC_URL = process.env.POLYGON_RPC_URL || 'https://polygon-mainnet.g.alchemy.com/v2/demo';

// Contracts
const USDC_E_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';
const CTF_TOKEN = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';  // Conditional Tokens (ERC1155)

const ERC20_ABI = [
  'function allowance(address owner, address spender) view returns (uint256)',
  'function balanceOf(address account) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)',
];

const ERC1155_ABI = [
  'function isApprovedForAll(address account, address operator) view returns (bool)',
  'function setApprovalForAll(address operator, bool approved)',
];

async function main() {
  if (!PRIVATE_KEY) {
    console.error('Error: Set POLY_PRIVKEY environment variable');
    process.exit(1);
  }

  const command = process.argv[2] || 'check';

  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║       POLYMARKET CTF APPROVAL CHECKER                          ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
  const address = wallet.address;

  console.log('Wallet:', address);
  console.log('');

  // Check USDC.e
  const usdc = new ethers.Contract(USDC_E_ADDRESS, ERC20_ABI, provider);
  const balance = await usdc.balanceOf(address);
  const ctfUsdcAllowance = await usdc.allowance(address, CTF_EXCHANGE);
  const negRiskUsdcAllowance = await usdc.allowance(address, NEG_RISK_CTF_EXCHANGE);

  console.log('─── USDC.e (Collateral) ───');
  const balanceUsdc = parseFloat(ethers.utils.formatUnits(balance, 6));
  console.log('Balance:              ' + balanceUsdc.toFixed(6) + ' USDC');
  console.log('CTF Exchange Allow:   ' + (ctfUsdcAllowance.gte(ethers.constants.MaxUint256.div(2)) ? 'Unlimited ✅' : ethers.utils.formatUnits(ctfUsdcAllowance, 6) + ' USDC'));
  console.log('Neg Risk CTF Allow:   ' + (negRiskUsdcAllowance.gte(ethers.constants.MaxUint256.div(2)) ? 'Unlimited ✅' : ethers.utils.formatUnits(negRiskUsdcAllowance, 6) + ' USDC'));
  console.log('');

  // Check CTF Token (ERC1155) approvals - THIS IS THE KEY!
  const ctfToken = new ethers.Contract(CTF_TOKEN, ERC1155_ABI, provider);
  const ctfApproved = await ctfToken.isApprovedForAll(address, CTF_EXCHANGE);
  const negRiskApproved = await ctfToken.isApprovedForAll(address, NEG_RISK_CTF_EXCHANGE);

  console.log('─── CTF Tokens (ERC1155 Position Tokens) ───');
  console.log('CTF Exchange:         ' + (ctfApproved ? '✅ Approved' : '❌ NOT APPROVED'));
  console.log('Neg Risk CTF:         ' + (negRiskApproved ? '✅ Approved' : '❌ NOT APPROVED'));
  console.log('');

  const needsApproval = !ctfApproved || !negRiskApproved ||
    ctfUsdcAllowance.lt(ethers.constants.MaxUint256.div(2)) ||
    negRiskUsdcAllowance.lt(ethers.constants.MaxUint256.div(2));

  if (needsApproval) {
    console.log('⚠️  Missing approvals detected!');
    console.log('   Orders will fail with "not enough balance / allowance"');
    console.log('');
  }

  if (command === 'approve') {
    console.log('─── Approving All Required Contracts ───');
    console.log('');

    const usdcWithSigner = usdc.connect(wallet);
    const ctfTokenWithSigner = ctfToken.connect(wallet);

    // Get current gas price and add buffer
    const feeData = await provider.getFeeData();
    const gasPrice = feeData.gasPrice?.mul(2) || ethers.utils.parseUnits('50', 'gwei');
    console.log('Gas Price:', ethers.utils.formatUnits(gasPrice, 'gwei'), 'gwei');
    console.log('');

    // 1. Approve USDC.e for CTF Exchange
    if (ctfUsdcAllowance.lt(ethers.constants.MaxUint256.div(2))) {
      console.log('1. Approving USDC.e for CTF Exchange...');
      const tx1 = await usdcWithSigner.approve(CTF_EXCHANGE, ethers.constants.MaxUint256, { gasPrice });
      console.log('   TX:', tx1.hash);
      await tx1.wait();
      console.log('   ✅ Confirmed');
    } else {
      console.log('1. USDC.e CTF Exchange: Already approved ✓');
    }

    // 2. Approve USDC.e for Neg Risk CTF Exchange
    if (negRiskUsdcAllowance.lt(ethers.constants.MaxUint256.div(2))) {
      console.log('2. Approving USDC.e for Neg Risk CTF Exchange...');
      const tx2 = await usdcWithSigner.approve(NEG_RISK_CTF_EXCHANGE, ethers.constants.MaxUint256, { gasPrice });
      console.log('   TX:', tx2.hash);
      await tx2.wait();
      console.log('   ✅ Confirmed');
    } else {
      console.log('2. USDC.e Neg Risk CTF: Already approved ✓');
    }

    // 3. Approve CTF Tokens for CTF Exchange
    if (!ctfApproved) {
      console.log('3. Approving CTF Tokens for CTF Exchange...');
      const tx3 = await ctfTokenWithSigner.setApprovalForAll(CTF_EXCHANGE, true, { gasPrice });
      console.log('   TX:', tx3.hash);
      await tx3.wait();
      console.log('   ✅ Confirmed');
    } else {
      console.log('3. CTF Tokens CTF Exchange: Already approved ✓');
    }

    // 4. Approve CTF Tokens for Neg Risk CTF Exchange
    if (!negRiskApproved) {
      console.log('4. Approving CTF Tokens for Neg Risk CTF Exchange...');
      const tx4 = await ctfTokenWithSigner.setApprovalForAll(NEG_RISK_CTF_EXCHANGE, true, { gasPrice });
      console.log('   TX:', tx4.hash);
      await tx4.wait();
      console.log('   ✅ Confirmed');
    } else {
      console.log('4. CTF Tokens Neg Risk CTF: Already approved ✓');
    }

    console.log('');
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('✅ All approvals complete! You can now trade on Polymarket.');
    console.log('═══════════════════════════════════════════════════════════════');

  } else {
    console.log('─── Commands ───');
    console.log('  check   - Check current approvals (default)');
    console.log('  approve - Approve all contracts for trading');
    console.log('');
    console.log('Example: POLY_PRIVKEY=0x... npx tsx scripts/check-ctf-approval.ts approve');
  }
}

main().catch(console.error);

================================================================================
// File: scripts/arb/settle-position.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Settle Position - 市场结束后清算脚本
 *
 * 功能:
 * 1. 查看当前持仓 (YES + NO)
 * 2. Merge 所有配对的 tokens → 回收 USDC
 * 3. 显示剩余的单边 tokens（等市场结算后 redeem）
 *
 * 用法:
 *   # 查看持仓
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/settle-position.ts
 *
 *   # 执行 merge
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/settle-position.ts --merge
 *
 *   # 指定市场
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/settle-position.ts --merge --market map1
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/settle-position.ts --merge --market bo3
 */

import { CTFClient } from '../../src/index.js';

// ============== Market Configurations ==============
const MARKETS = {
  map1: {
    name: 'CS2: FaZe vs Passion UA - Map 1 Winner',
    conditionId: '0x8307e29e55c51624bf7dc2448f640902deda12a798bf4f9389f50effed5ca8e3',
    yesTokenId: '43483263124644478520592164117863889505064690344162739837819619686304683165329',
    noTokenId: '82507526040280959004054227385878378176592321458993996786469194286964091170010',
    outcomes: ['FaZe', 'Passion UA'],
  },
  map2: {
    name: 'CS2: FaZe vs Passion UA - Map 2 Winner',
    conditionId: '0x42b6312bfef1d4d996239fb2975a0201fed896beb9020c7117222cb9c63fb8a0',
    yesTokenId: '98500029478540181701955943314626655950009912089703692217392489784365890894034',
    noTokenId: '6600108613901488464286039277243478584438419930859899257744834420246596461241',
    outcomes: ['FaZe', 'Passion UA'],
  },
  bo3: {
    name: 'CS2: FaZe vs Passion UA (BO3)',
    conditionId: '0x5ac2e92a82ea41ec3a4d9332d323d8d198a8c9acc732b7e6373bd61f45e1df49',
    yesTokenId: '89062136554637645106569570664838812035010963361832797298254486917225439629146',
    noTokenId: '54956090965819006918015199317329813503156478664679332459223691084797135448319',
    outcomes: ['FaZe', 'Passion UA'],
  },
  cs2_b8_navi: {
    name: 'CS2: B8 vs Navi - Map 2 Winner',
    conditionId: '0xed4f4efc641b2cc65d172115527298780c2763e38392411080446d00624de188',
    yesTokenId: '98356217078946559304776425059619763149078508549007892630440851408503070133487',
    noTokenId: '9564639153871441133338469591798901837693814970886235799643024453135563888010',
    outcomes: ['B8', 'Natus Vincere'],
  },
};

// ============== Parse Arguments ==============
const args = process.argv.slice(2);
const EXECUTE_MERGE = args.includes('--merge');
const marketIdx = args.indexOf('--market');
const MARKET_KEY = marketIdx !== -1 ? args[marketIdx + 1] : 'all';

const PRIVATE_KEY = process.env.POLY_PRIVKEY || '';
const RPC_URL = process.env.POLYGON_RPC_URL || 'https://polygon-rpc.com';

// ============== Main ==============
async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║              SETTLE POSITION - 清算脚本                         ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log();

  if (!PRIVATE_KEY) {
    console.error('Error: POLY_PRIVKEY environment variable is required');
    process.exit(1);
  }

  // Initialize clients
  const ctf = new CTFClient({ privateKey: PRIVATE_KEY, rpcUrl: RPC_URL });

  console.log(`Wallet: ${ctf.getAddress()}`);
  console.log(`Mode: ${EXECUTE_MERGE ? 'MERGE (will execute)' : 'VIEW ONLY'}`);
  console.log();

  // Get USDC balance
  const usdcBalance = await ctf.getUsdcBalance();
  console.log(`USDC.e Balance: $${parseFloat(usdcBalance).toFixed(2)}`);
  console.log();

  // Process markets
  const marketsToProcess = MARKET_KEY === 'all'
    ? Object.entries(MARKETS)
    : [[MARKET_KEY, MARKETS[MARKET_KEY as keyof typeof MARKETS]]].filter(([_, m]) => m);

  if (marketsToProcess.length === 0) {
    console.error(`Unknown market: ${MARKET_KEY}`);
    console.log(`Available markets: ${Object.keys(MARKETS).join(', ')}`);
    process.exit(1);
  }

  let totalMerged = 0;
  let totalUnpairedYes = 0;
  let totalUnpairedNo = 0;

  for (const [key, market] of marketsToProcess) {
    if (!market) continue;

    console.log('═══════════════════════════════════════════════════════════════');
    console.log(`Market: ${market.name}`);
    console.log(`Condition: ${market.conditionId.slice(0, 20)}...`);
    console.log();

    // Get token balances
    const tokenIds = { yesTokenId: market.yesTokenId, noTokenId: market.noTokenId };
    const positions = await ctf.getPositionBalanceByTokenIds(market.conditionId, tokenIds);
    const yesBalance = parseFloat(positions.yesBalance);
    const noBalance = parseFloat(positions.noBalance);

    console.log(`  ${market.outcomes[0]} (YES): ${yesBalance.toFixed(6)}`);
    console.log(`  ${market.outcomes[1]} (NO):  ${noBalance.toFixed(6)}`);

    // Calculate pairs and unpaired
    const pairs = Math.min(yesBalance, noBalance);
    const unpairedYes = yesBalance - pairs;
    const unpairedNo = noBalance - pairs;

    console.log();
    console.log(`  Paired tokens: ${pairs.toFixed(6)} (can merge → $${pairs.toFixed(2)} USDC)`);

    if (unpairedYes > 0.001) {
      console.log(`  ⚠️ Unpaired YES: ${unpairedYes.toFixed(6)} (wait for market settlement to redeem if ${market.outcomes[0]} wins)`);
      totalUnpairedYes += unpairedYes;
    }
    if (unpairedNo > 0.001) {
      console.log(`  ⚠️ Unpaired NO: ${unpairedNo.toFixed(6)} (wait for market settlement to redeem if ${market.outcomes[1]} wins)`);
      totalUnpairedNo += unpairedNo;
    }

    // Execute merge if requested
    if (EXECUTE_MERGE && pairs >= 1) {
      const mergeAmount = Math.floor(pairs * 1e6) / 1e6;
      console.log();
      console.log(`  🔄 Merging ${mergeAmount.toFixed(6)} token pairs...`);

      try {
        // Use mergeByTokenIds to bypass the deprecated getPositionBalance check
        const result = await ctf.mergeByTokenIds(market.conditionId, tokenIds, mergeAmount.toString());
        console.log(`  ✅ Merge TX: ${result.txHash}`);
        console.log(`  ✅ Recovered: $${mergeAmount.toFixed(2)} USDC`);
        totalMerged += mergeAmount;
      } catch (error: any) {
        console.log(`  ❌ Merge failed: ${error.message}`);
      }
    } else if (pairs >= 1) {
      console.log();
      console.log(`  💡 Run with --merge to recover $${pairs.toFixed(2)} USDC`);
    }

    console.log();
  }

  // Summary
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('SUMMARY');
  console.log('═══════════════════════════════════════════════════════════════');

  if (EXECUTE_MERGE) {
    console.log(`Total Merged: $${totalMerged.toFixed(2)} USDC`);
    const newUsdcBalance = await ctf.getUsdcBalance();
    console.log(`New USDC.e Balance: $${parseFloat(newUsdcBalance).toFixed(2)}`);
  }

  if (totalUnpairedYes > 0.001 || totalUnpairedNo > 0.001) {
    console.log();
    console.log('Unpaired tokens (waiting for market settlement):');
    if (totalUnpairedYes > 0.001) {
      console.log(`  YES tokens: ${totalUnpairedYes.toFixed(6)}`);
    }
    if (totalUnpairedNo > 0.001) {
      console.log(`  NO tokens: ${totalUnpairedNo.toFixed(6)}`);
    }
    console.log();
    console.log('Note: Unpaired tokens can be redeemed after market settles');
    console.log('      - If your outcome wins: redeem for $1 per token');
    console.log('      - If your outcome loses: tokens have no value');
  }

  console.log();
}

main().catch(console.error);

================================================================================
// File: scripts/arb/token-rebalancer.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Token Rebalancer V2 - 动态平衡 USDC 和 Token 的持有量
 *
 * 核心功能:
 * 1. 维持 USDC + Token 的目标比例
 * 2. ⚠️ 关键：保持 YES 和 NO 数量一致，避免风险敞口
 *
 * 资金模型:
 * - 1 USDC split → 1 YES + 1 NO
 * - 1 YES + 1 NO merge → 1 USDC
 * - 所以 N YES + N NO 配对价值 = N USDC
 *
 * 策略 (以 50% USDC 为例, 1000u 总资金):
 * - 500 USDC (50%)
 * - 500 YES + 500 NO (配对价值 = 500 USDC)
 * - 总价值 = 500 + 500 = 1000 USDC
 *
 * - Token 不足时自动 Split 补充
 * - Token 过多时自动 Merge 回收
 * - YES ≠ NO 时，卖出多余的一方来平衡
 *
 * 用法:
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/token-rebalancer.ts [options]
 *
 * Options:
 *   --condition <id>       Condition ID
 *   --yes-token <id>       YES token ID
 *   --no-token <id>        NO token ID
 *   --total <amount>       Total capital in USDC (default: auto-detect)
 *   --usdc-ratio <n>       USDC ratio 0-1 (default: 0.5)
 *   --interval <ms>        Check interval in ms (default: 5000)
 *   --threshold <n>        Rebalance threshold 0-1 (default: 0.2)
 *   --imbalance-threshold  Max YES/NO difference before fix (default: 5)
 *   --dry-run              Show what would happen without executing
 */

import {
    CTFClient,
    TradingService,
    RateLimiter,
    createUnifiedCache,
  } from '../../src/index.js';
  
  // ============== Market Configuration ==============
  // Default: FaZe vs Passion UA - Map 2 Winner
  const DEFAULT_CONFIG = {
    conditionId: '0x42b6312bfef1d4d996239fb2975a0201fed896beb9020c7117222cb9c63fb8a0',
    yesTokenId: '98500029478540181701955943314626655950009912089703692217392489784365890894034',
    noTokenId: '6600108613901488464286039277243478584438419930859899257744834420246596461241',
    name: 'FaZe vs Passion UA - Map 2'
  };
  
  // ============== Parse Arguments ==============
  const args = process.argv.slice(2);
  
  function getArg(name: string, defaultValue?: string): string | undefined {
    const idx = args.indexOf(`--${name}`);
    if (idx !== -1 && args[idx + 1]) {
      return args[idx + 1];
    }
    return defaultValue;
  }
  
  const CONDITION_ID = getArg('condition', DEFAULT_CONFIG.conditionId)!;
  const YES_TOKEN_ID = getArg('yes-token', DEFAULT_CONFIG.yesTokenId)!;
  const NO_TOKEN_ID = getArg('no-token', DEFAULT_CONFIG.noTokenId)!;
  const TOTAL_CAPITAL = getArg('total') ? parseFloat(getArg('total')!) : undefined;
  const USDC_RATIO = parseFloat(getArg('usdc-ratio', '0.5')!);
  const CHECK_INTERVAL = parseInt(getArg('interval', '5000')!);
  const REBALANCE_THRESHOLD = parseFloat(getArg('threshold', '0.2')!);
  const IMBALANCE_THRESHOLD = parseFloat(getArg('imbalance-threshold', '5')!);
  const DRY_RUN = args.includes('--dry-run');
  
  // Token ratio: YES and NO should each equal the non-USDC portion
  // Because: 1 USDC = 1 YES + 1 NO, so paired tokens (N YES + N NO) = N USDC value
  // Example with 1000u total and 50% USDC:
  //   - 500 USDC
  //   - 500 YES + 500 NO (paired value = 500 USDC)
  //   - Total value = 500 + 500 = 1000 USDC
  const TOKEN_RATIO = 1 - USDC_RATIO;
  
  // Minimum amounts
  const MIN_REBALANCE_AMOUNT = 5;
  const MIN_SELL_AMOUNT = 5;
  
  // ============== State ==============
  interface Balance {
    usdc: number;
    yes: number;
    no: number;
    total: number;
  }
  
  type ActionType = 'split' | 'merge' | 'sell_yes' | 'sell_no' | 'none';
  
  interface RebalanceAction {
    type: ActionType;
    amount: number;
    reason: string;
    priority: number; // Higher = more urgent
  }
  
  // ============== Main ==============
  async function main() {
    console.log('╔════════════════════════════════════════════════════════════════╗');
    console.log('║              TOKEN REBALANCER V2 (with Risk Control)           ║');
    console.log('╚════════════════════════════════════════════════════════════════╝');
    console.log();
  
    // Initialize clients
    const privateKey = process.env.POLY_PRIVKEY;
    if (!privateKey) {
      console.error('Error: POLY_PRIVKEY environment variable is required');
      process.exit(1);
    }
  
    const ctf = new CTFClient({
      privateKey,
      rpcUrl: 'https://polygon-rpc.com',
    });
  
    // Initialize trading service for selling excess tokens
    const rateLimiter = new RateLimiter();
    const cache = createUnifiedCache();
    const tradingService = new TradingService(rateLimiter, cache, {
      privateKey,
      chainId: 137,
    });
    await tradingService.initialize();
  
    console.log(`Wallet: ${ctf.getAddress()}`);
    console.log(`Condition: ${CONDITION_ID.slice(0, 20)}...`);
    console.log(`Target: ${(USDC_RATIO * 100).toFixed(0)}% USDC + ${(TOKEN_RATIO * 100).toFixed(0)}% Tokens (${(TOKEN_RATIO * 100).toFixed(0)} YES + ${(TOKEN_RATIO * 100).toFixed(0)} NO paired)`);
    console.log(`Rebalance Threshold: ${(REBALANCE_THRESHOLD * 100).toFixed(0)}%`);
    console.log(`Imbalance Threshold: ${IMBALANCE_THRESHOLD} tokens (YES must equal NO)`);
    console.log(`Check Interval: ${CHECK_INTERVAL}ms`);
    console.log(`Mode: ${DRY_RUN ? 'DRY RUN (no execution)' : 'LIVE'}`);
    console.log();
  
    // Get initial balance
    const balance = await getBalance(ctf, tradingService);
    const totalCapital = TOTAL_CAPITAL || balance.total;
  
    console.log(`Total Capital: $${totalCapital.toFixed(2)}`);
    console.log(`Initial: USDC=${balance.usdc.toFixed(2)} YES=${balance.yes.toFixed(2)} NO=${balance.no.toFixed(2)}`);
  
    const initialImbalance = Math.abs(balance.yes - balance.no);
    if (initialImbalance > IMBALANCE_THRESHOLD) {
      console.log(`\n⚠️  WARNING: Token imbalance detected! YES-NO=${(balance.yes - balance.no).toFixed(2)}`);
      console.log(`   This creates risk exposure. Will auto-fix by selling excess tokens.`);
    }
  
    console.log();
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('Starting rebalancer loop...');
    console.log();
  
    // Main loop
    let lastActionTime = 0;
    const MIN_ACTION_INTERVAL = 10000; // Wait at least 10s between actions
    const CONFIRM_DELAY = 5000; // Wait 5s before confirming imbalance action
    const BALANCE_CHANGE_THRESHOLD = 1; // If balance changes by more than this, reset confirmation
    let pendingImbalanceAction: RebalanceAction | null = null;
    let pendingImbalanceTime = 0;
    let lastConfirmBalance: Balance | null = null;
  
    while (true) {
      try {
        const currentBalance = await getBalance(ctf, tradingService);
        const actions = calculateRebalanceActions(currentBalance, totalCapital);
  
        // Get highest priority action
        const action = actions.sort((a, b) => b.priority - a.priority)[0];
  
        // Display status
        const usdcPct = (currentBalance.usdc / totalCapital * 100).toFixed(1);
        const yesPct = (currentBalance.yes / totalCapital * 100).toFixed(1);
        const noPct = (currentBalance.no / totalCapital * 100).toFixed(1);
        const imbalance = currentBalance.yes - currentBalance.no;
        const imbalanceStr = imbalance >= 0 ? `+${imbalance.toFixed(1)}` : imbalance.toFixed(1);
  
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const statusLine = `[${timestamp}] USDC: $${currentBalance.usdc.toFixed(0)} (${usdcPct}%) | YES: ${currentBalance.yes.toFixed(0)} (${yesPct}%) | NO: ${currentBalance.no.toFixed(0)} (${noPct}%) | Δ: ${imbalanceStr} | ${action.type}`;
  
        process.stdout.write(`\r${statusLine.padEnd(130)}`);
  
        // Execute action if needed
        if (action.type !== 'none' && action.amount >= MIN_SELL_AMOUNT) {
          const now = Date.now();
          if (now - lastActionTime < MIN_ACTION_INTERVAL) {
            await sleep(CHECK_INTERVAL);
            continue;
          }
  
          // For imbalance actions (sell_yes/sell_no), require confirmation after delay
          // This prevents reacting to temporary imbalance during CLOB settlement
          if (action.type === 'sell_yes' || action.type === 'sell_no') {
            // Check if balance has changed significantly since last check
            const balanceChanged = lastConfirmBalance && (
              Math.abs(currentBalance.yes - lastConfirmBalance.yes) > BALANCE_CHANGE_THRESHOLD ||
              Math.abs(currentBalance.no - lastConfirmBalance.no) > BALANCE_CHANGE_THRESHOLD
            );
  
            if (!pendingImbalanceAction || pendingImbalanceAction.type !== action.type || balanceChanged) {
              // New imbalance detected or balance changed, (re)start waiting
              if (balanceChanged && pendingImbalanceAction) {
                console.log(`\n⚠️ Balance changed during confirmation, restarting ${CONFIRM_DELAY/1000}s wait...`);
              } else if (!pendingImbalanceAction) {
                console.log(`\n⏳ Imbalance detected (${action.type}), waiting ${CONFIRM_DELAY/1000}s to confirm...`);
              }
              pendingImbalanceAction = action;
              pendingImbalanceTime = now;
              lastConfirmBalance = { ...currentBalance };
              await sleep(CHECK_INTERVAL);
              continue;
            } else if (now - pendingImbalanceTime < CONFIRM_DELAY) {
              // Still waiting for confirmation
              await sleep(CHECK_INTERVAL);
              continue;
            }
            // Confirmed - imbalance persisted for CONFIRM_DELAY with stable balance, proceed with action
            console.log(`\n✓ Imbalance confirmed after ${CONFIRM_DELAY/1000}s delay (balance stable)`);
            pendingImbalanceAction = null;
            lastConfirmBalance = null;
          }
  
          console.log(); // New line for action log
          console.log(`\n🔄 Action: ${action.type.toUpperCase()} ${action.amount.toFixed(2)}`);
          console.log(`   Reason: ${action.reason}`);
          console.log(`   Priority: ${action.priority}`);
  
          if (!DRY_RUN) {
            try {
              let success = false;
  
              switch (action.type) {
                case 'split':
                  const splitResult = await ctf.split(CONDITION_ID, action.amount.toString());
                  console.log(`   ✅ Split TX: ${splitResult.txHash}`);
                  success = true;
                  break;
  
                case 'merge':
                  const mergeResult = await ctf.merge(CONDITION_ID, action.amount.toString());
                  console.log(`   ✅ Merge TX: ${mergeResult.txHash}`);
                  success = true;
                  break;
  
                case 'sell_yes':
                  const sellYesResult = await tradingService.createMarketOrder({
                    tokenId: YES_TOKEN_ID,
                    side: 'SELL',
                    amount: action.amount,
                    orderType: 'FOK',
                  });
                  if (sellYesResult.success) {
                    console.log(`   ✅ Sold ${action.amount.toFixed(2)} YES tokens`);
                    success = true;
                  } else {
                    console.log(`   ❌ Sell YES failed: ${sellYesResult.errorMsg || 'unknown error'}`);
                  }
                  break;
  
                case 'sell_no':
                  const sellNoResult = await tradingService.createMarketOrder({
                    tokenId: NO_TOKEN_ID,
                    side: 'SELL',
                    amount: action.amount,
                    orderType: 'FOK',
                  });
                  if (sellNoResult.success) {
                    console.log(`   ✅ Sold ${action.amount.toFixed(2)} NO tokens`);
                    success = true;
                  } else {
                    console.log(`   ❌ Sell NO failed: ${sellNoResult.errorMsg || 'unknown error'}`);
                  }
                  break;
              }
  
              if (success) {
                lastActionTime = now;
              }
            } catch (error: any) {
              console.log(`   ❌ Failed: ${error.message}`);
            }
          } else {
            console.log(`   [DRY RUN] Would execute ${action.type}`);
          }
          console.log();
        }
  
        await sleep(CHECK_INTERVAL);
      } catch (error: any) {
        console.error(`\nError: ${error.message}`);
        await sleep(CHECK_INTERVAL);
      }
    }
  }
  
  async function getBalance(ctf: CTFClient, _tradingService: TradingService): Promise<Balance> {
    // Get USDC.e balance
    const usdcBalance = await ctf.getUsdcBalance();
    const usdc = parseFloat(usdcBalance);
  
    // Get token balances using getPositionBalanceByTokenIds
    const tokenIds = { yesTokenId: YES_TOKEN_ID, noTokenId: NO_TOKEN_ID };
    const positions = await ctf.getPositionBalanceByTokenIds(CONDITION_ID, tokenIds);
  
    const yes = parseFloat(positions.yesBalance);
    const no = parseFloat(positions.noBalance);
  
    // Total = USDC + min(YES, NO) as paired tokens
    const pairedTokens = Math.min(yes, no);
    const total = usdc + pairedTokens;
  
    return { usdc, yes, no, total };
  }
  
  function calculateRebalanceActions(balance: Balance, totalCapital: number): RebalanceAction[] {
    const actions: RebalanceAction[] = [];
  
    const targetUsdc = totalCapital * USDC_RATIO;
    const targetToken = totalCapital * TOKEN_RATIO;
  
    const usdcDiff = balance.usdc - targetUsdc;
    const yesDiff = balance.yes - targetToken;
    const noDiff = balance.no - targetToken;
    const tokenImbalance = balance.yes - balance.no;
  
    // ============================================
    // PRIORITY 1: Fix YES/NO imbalance (HIGHEST)
    // This is critical for risk management!
    // ============================================
    if (Math.abs(tokenImbalance) > IMBALANCE_THRESHOLD) {
      if (tokenImbalance > 0) {
        // YES > NO, sell excess YES
        const sellAmount = Math.floor(Math.min(tokenImbalance, balance.yes * 0.5) * 1e6) / 1e6;
        if (sellAmount >= MIN_SELL_AMOUNT) {
          actions.push({
            type: 'sell_yes',
            amount: sellAmount,
            reason: `⚠️ RISK: YES > NO by ${tokenImbalance.toFixed(2)}. Selling excess YES to balance.`,
            priority: 100, // Highest priority
          });
        }
      } else {
        // NO > YES, sell excess NO
        const sellAmount = Math.floor(Math.min(-tokenImbalance, balance.no * 0.5) * 1e6) / 1e6;
        if (sellAmount >= MIN_SELL_AMOUNT) {
          actions.push({
            type: 'sell_no',
            amount: sellAmount,
            reason: `⚠️ RISK: NO > YES by ${(-tokenImbalance).toFixed(2)}. Selling excess NO to balance.`,
            priority: 100, // Highest priority
          });
        }
      }
    }
  
    // ============================================
    // PRIORITY 2: Merge excess paired tokens
    // ============================================
    const pairedTokens = Math.min(balance.yes, balance.no);
    const excessPairs = pairedTokens - targetToken;
  
    if (excessPairs > MIN_REBALANCE_AMOUNT && usdcDiff < 0) {
      const mergeAmount = Math.floor(Math.min(excessPairs * 0.5, Math.abs(usdcDiff)) * 100) / 100;
      if (mergeAmount >= MIN_REBALANCE_AMOUNT) {
        actions.push({
          type: 'merge',
          amount: mergeAmount,
          reason: `Excess token pairs (${pairedTokens.toFixed(0)} > ${targetToken.toFixed(0)}), USDC low`,
          priority: 50,
        });
      }
    }
  
    // ============================================
    // PRIORITY 3: Split to create more tokens
    // ============================================
    const usdcDeviation = Math.abs(usdcDiff) / targetUsdc;
  
    if (usdcDeviation > REBALANCE_THRESHOLD && usdcDiff > 0) {
      // Check if both tokens are low
      if (yesDiff < 0 && noDiff < 0) {
        const splitAmount = Math.floor(Math.min(
          usdcDiff * 0.5,
          Math.abs(Math.min(yesDiff, noDiff)),
          balance.usdc * 0.3
        ) * 100) / 100;
  
        if (splitAmount >= MIN_REBALANCE_AMOUNT) {
          actions.push({
            type: 'split',
            amount: splitAmount,
            reason: `USDC high (${(usdcDeviation * 100).toFixed(0)}% over), tokens low`,
            priority: 30,
          });
        }
      }
    }
  
    // Default: no action needed
    if (actions.length === 0) {
      actions.push({
        type: 'none',
        amount: 0,
        reason: 'Balanced',
        priority: 0,
      });
    }
  
    return actions;
  }
  
  function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // Run
  main().catch(console.error);

================================================================================
// File: scripts/archive/api-verification-history/07-subgraph-api.ts
================================================================================
/**
 * Polymarket Subgraph API 验证脚本
 *
 * 目的：验证 Goldsky Subgraph 端点是否可用，了解数据结构
 * 原则：Don't trust, verify
 *
 * Polymarket 有 5 个 Subgraph:
 * 1. Positions - 用户仓位、入场价、已实现 PnL
 * 2. PnL - 已实现/未实现 PnL、历史表现
 * 3. Activity - 交易、事件
 * 4. Orders - 订单簿分析
 * 5. Open Interest - 市场 OI
 */

// Goldsky Subgraph 端点
const SUBGRAPH_ENDPOINTS = {
  positions: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/positions-subgraph/0.0.7/gn',
  pnl: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn',
  activity: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/prod/gn',
  orders: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/orders-subgraph/prod/gn',
  openInterest: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/open-interest-subgraph/prod/gn',
};

// 测试用户
const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74'; // simonbanza

interface SubgraphTest {
  name: string;
  endpoint: string;
  query: string;
  description: string;
}

const tests: SubgraphTest[] = [
  // 1. Positions Subgraph
  {
    name: 'positions-schema',
    endpoint: SUBGRAPH_ENDPOINTS.positions,
    query: `{
      __schema {
        types {
          name
        }
      }
    }`,
    description: 'Positions Subgraph - 获取 schema 类型',
  },
  {
    name: 'positions-user',
    endpoint: SUBGRAPH_ENDPOINTS.positions,
    query: `{
      userPositions(
        where: { user: "${TEST_ADDRESS.toLowerCase()}" }
        first: 5
      ) {
        id
        user
        conditionId
        outcome
        balance
        avgPrice
        realizedPnl
        timestamp
      }
    }`,
    description: 'Positions Subgraph - 用户仓位',
  },

  // 2. PnL Subgraph
  {
    name: 'pnl-schema',
    endpoint: SUBGRAPH_ENDPOINTS.pnl,
    query: `{
      __schema {
        queryType {
          fields {
            name
          }
        }
      }
    }`,
    description: 'PnL Subgraph - 获取可用查询',
  },
  {
    name: 'pnl-user',
    endpoint: SUBGRAPH_ENDPOINTS.pnl,
    query: `{
      userPnLs(
        where: { user: "${TEST_ADDRESS.toLowerCase()}" }
        first: 5
        orderBy: timestamp
        orderDirection: desc
      ) {
        id
        user
        realizedPnl
        unrealizedPnl
        timestamp
      }
    }`,
    description: 'PnL Subgraph - 用户 PnL 历史',
  },

  // 3. Activity Subgraph
  {
    name: 'activity-schema',
    endpoint: SUBGRAPH_ENDPOINTS.activity,
    query: `{
      __schema {
        queryType {
          fields {
            name
          }
        }
      }
    }`,
    description: 'Activity Subgraph - 获取可用查询',
  },

  // 4. Orders Subgraph
  {
    name: 'orders-schema',
    endpoint: SUBGRAPH_ENDPOINTS.orders,
    query: `{
      __schema {
        queryType {
          fields {
            name
          }
        }
      }
    }`,
    description: 'Orders Subgraph - 获取可用查询',
  },

  // 5. Open Interest Subgraph
  {
    name: 'oi-schema',
    endpoint: SUBGRAPH_ENDPOINTS.openInterest,
    query: `{
      __schema {
        queryType {
          fields {
            name
          }
        }
      }
    }`,
    description: 'Open Interest Subgraph - 获取可用查询',
  },
];

async function runGraphQLQuery(
  endpoint: string,
  query: string
): Promise<{ success: boolean; data?: unknown; error?: string }> {
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query }),
    });

    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`,
      };
    }

    const result = await response.json();
    if (result.errors) {
      return {
        success: false,
        error: JSON.stringify(result.errors),
      };
    }

    return { success: true, data: result.data };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}

async function runTest(test: SubgraphTest): Promise<void> {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`📡 ${test.name}: ${test.description}`);
  console.log(`Endpoint: ${test.endpoint.slice(0, 80)}...`);
  console.log('='.repeat(80));

  const result = await runGraphQLQuery(test.endpoint, test.query);

  if (result.success) {
    console.log('✅ Success');
    console.log('📦 Response:');
    console.log(JSON.stringify(result.data, null, 2).slice(0, 1500));
  } else {
    console.log('❌ Failed');
    console.log(`⚠️ Error: ${result.error?.slice(0, 500)}`);
  }
}

async function main(): Promise<void> {
  console.log('🚀 Polymarket Subgraph API 验证开始');
  console.log('Time:', new Date().toISOString());
  console.log('\nTest User:', TEST_ADDRESS);
  console.log('\n📋 Subgraph Endpoints:');
  Object.entries(SUBGRAPH_ENDPOINTS).forEach(([name, url]) => {
    console.log(`  ${name}: ${url.slice(0, 70)}...`);
  });

  for (const test of tests) {
    await runTest(test);
  }

  console.log('\n\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/archive/api-verification-history/08-subgraph-explore.ts
================================================================================
/**
 * 深入探索 Polymarket Subgraph 结构
 *
 * 只测试可用的两个 Subgraph: positions 和 pnl
 */

const SUBGRAPH_ENDPOINTS = {
  positions: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/positions-subgraph/0.0.7/gn',
  pnl: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn',
};

const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';

async function query(endpoint: string, q: string): Promise<unknown> {
  const response = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: q }),
  });
  const result = await response.json();
  if (result.errors) {
    throw new Error(JSON.stringify(result.errors));
  }
  return result.data;
}

async function main(): Promise<void> {
  console.log('🔍 深入探索 Polymarket Subgraph\n');

  // ===== 1. Positions Subgraph =====
  console.log('='.repeat(80));
  console.log('📊 1. Positions Subgraph');
  console.log('='.repeat(80));

  // 获取可用查询
  console.log('\n📋 可用查询字段:');
  const posSchema = await query(SUBGRAPH_ENDPOINTS.positions, `{
    __schema {
      queryType {
        fields {
          name
          type { name kind }
          args { name type { name } }
        }
      }
    }
  }`);
  const posFields = (posSchema as { __schema: { queryType: { fields: Array<{ name: string; type: { name: string; kind: string }; args: Array<{ name: string; type: { name: string } }> }> } } }).__schema.queryType.fields;
  posFields.forEach((f: { name: string; type: { name: string; kind: string }; args: Array<{ name: string; type: { name: string } }> }) => {
    const args = f.args.map((a: { name: string; type: { name: string } }) => a.name).join(', ');
    console.log(`  - ${f.name}(${args}) -> ${f.type.name || f.type.kind}`);
  });

  // 查询 UserBalance 结构
  console.log('\n📋 UserBalance 字段:');
  const ubSchema = await query(SUBGRAPH_ENDPOINTS.positions, `{
    __type(name: "UserBalance") {
      fields {
        name
        type { name kind ofType { name } }
      }
    }
  }`);
  const ubFields = (ubSchema as { __type: { fields: Array<{ name: string; type: { name: string; kind: string; ofType?: { name: string } } }> } }).__type.fields;
  ubFields.forEach((f: { name: string; type: { name: string; kind: string; ofType?: { name: string } } }) => {
    console.log(`  - ${f.name}: ${f.type.name || f.type.ofType?.name || f.type.kind}`);
  });

  // 查询用户余额
  console.log('\n📋 查询用户余额 (UserBalance):');
  try {
    const userBalances = await query(SUBGRAPH_ENDPOINTS.positions, `{
      userBalances(
        where: { user: "${TEST_ADDRESS.toLowerCase()}" }
        first: 3
        orderBy: balance
        orderDirection: desc
      ) {
        id
        user
        tokenId
        balance
        avgPrice
        firstTxHash
        latestTxHash
        createdTimestamp
        lastUpdatedTimestamp
      }
    }`);
    console.log(JSON.stringify(userBalances, null, 2));
  } catch (e) {
    console.log('  ❌ Error:', String(e).slice(0, 200));
  }

  // 查询 NetUserBalance
  console.log('\n📋 NetUserBalance 字段:');
  const nubSchema = await query(SUBGRAPH_ENDPOINTS.positions, `{
    __type(name: "NetUserBalance") {
      fields {
        name
        type { name kind ofType { name } }
      }
    }
  }`);
  const nubFields = (nubSchema as { __type: { fields: Array<{ name: string; type: { name: string; kind: string; ofType?: { name: string } } }> } }).__type.fields;
  nubFields.forEach((f: { name: string; type: { name: string; kind: string; ofType?: { name: string } } }) => {
    console.log(`  - ${f.name}: ${f.type.name || f.type.ofType?.name || f.type.kind}`);
  });

  // ===== 2. PnL Subgraph =====
  console.log('\n' + '='.repeat(80));
  console.log('📊 2. PnL Subgraph');
  console.log('='.repeat(80));

  // 获取可用查询
  console.log('\n📋 可用查询字段:');
  const pnlSchema = await query(SUBGRAPH_ENDPOINTS.pnl, `{
    __schema {
      queryType {
        fields {
          name
          type { name kind }
        }
      }
    }
  }`);
  const pnlFields = (pnlSchema as { __schema: { queryType: { fields: Array<{ name: string; type: { name: string; kind: string } }> } } }).__schema.queryType.fields;
  pnlFields.forEach((f: { name: string; type: { name: string; kind: string } }) => {
    console.log(`  - ${f.name} -> ${f.type.name || f.type.kind}`);
  });

  // 查询 UserPosition 结构
  console.log('\n📋 UserPosition 字段:');
  const upSchema = await query(SUBGRAPH_ENDPOINTS.pnl, `{
    __type(name: "UserPosition") {
      fields {
        name
        type { name kind ofType { name } }
      }
    }
  }`);
  const upFields = (upSchema as { __type: { fields: Array<{ name: string; type: { name: string; kind: string; ofType?: { name: string } } }> } }).__type.fields;
  upFields.forEach((f: { name: string; type: { name: string; kind: string; ofType?: { name: string } } }) => {
    console.log(`  - ${f.name}: ${f.type.name || f.type.ofType?.name || f.type.kind}`);
  });

  // 查询用户持仓
  console.log('\n📋 查询用户持仓 (userPositions):');
  try {
    const positions = await query(SUBGRAPH_ENDPOINTS.pnl, `{
      userPositions(
        where: { user: "${TEST_ADDRESS.toLowerCase()}" }
        first: 3
        orderBy: realizedPnl
        orderDirection: desc
      ) {
        id
        user
        conditionId
        outcome
        balance
        avgPrice
        realizedPnl
        feePaid
        createdTimestamp
        lastUpdatedTimestamp
      }
    }`);
    console.log(JSON.stringify(positions, null, 2));
  } catch (e) {
    console.log('  ❌ Error:', String(e).slice(0, 200));
  }

  // 查询 Condition 结构
  console.log('\n📋 Condition 字段:');
  const condSchema = await query(SUBGRAPH_ENDPOINTS.pnl, `{
    __type(name: "Condition") {
      fields {
        name
        type { name kind ofType { name } }
      }
    }
  }`);
  const condFields = (condSchema as { __type: { fields: Array<{ name: string; type: { name: string; kind: string; ofType?: { name: string } } }> } }).__type.fields;
  condFields.forEach((f: { name: string; type: { name: string; kind: string; ofType?: { name: string } } }) => {
    console.log(`  - ${f.name}: ${f.type.name || f.type.ofType?.name || f.type.kind}`);
  });

  console.log('\n✅ 探索完成');
}

main().catch(console.error);

================================================================================
// File: scripts/archive/api-verification-history/09-subgraph-correct.ts
================================================================================
/**
 * 使用官方 schema 验证 Polymarket Subgraph
 *
 * 基于 polymarket-subgraph 仓库的 schema.graphql
 */

const SUBGRAPH_ENDPOINTS = {
  // 注意：端点 URL 可能需要更新版本号
  pnl: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn',
  activity: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/0.0.5/gn',
  oi: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/oi-subgraph/0.0.4/gn',
  wallet: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/wallet-subgraph/0.0.3/gn',
};

const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';
const TEST_CONDITION_ID = '0xdd22472e552920b8438158ea7238bfadfa4f736aa4cee91a6b86c39ead110917';

async function query(endpoint: string, q: string): Promise<{ data?: unknown; errors?: unknown[] }> {
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: q }),
    });
    if (!response.ok) {
      return { errors: [{ message: `HTTP ${response.status}` }] };
    }
    return await response.json();
  } catch (e) {
    return { errors: [{ message: String(e) }] };
  }
}

async function testEndpoint(name: string, endpoint: string, testQuery: string): Promise<void> {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`📊 ${name}`);
  console.log(`Endpoint: ${endpoint.slice(0, 70)}...`);
  console.log('='.repeat(60));

  const result = await query(endpoint, testQuery);

  if (result.errors) {
    console.log('❌ Error:', JSON.stringify(result.errors).slice(0, 300));
  } else {
    console.log('✅ Success');
    console.log(JSON.stringify(result.data, null, 2).slice(0, 800));
  }
}

async function main(): Promise<void> {
  console.log('🔍 验证 Polymarket Subgraph (使用官方 schema)');
  console.log('Time:', new Date().toISOString());

  // 1. PnL Subgraph - UserPosition
  await testEndpoint('PnL Subgraph - UserPositions', SUBGRAPH_ENDPOINTS.pnl, `{
    userPositions(
      where: { user: "${TEST_ADDRESS.toLowerCase()}" }
      first: 3
      orderBy: realizedPnl
      orderDirection: desc
    ) {
      id
      user
      tokenId
      amount
      avgPrice
      realizedPnl
      totalBought
    }
  }`);

  // 2. PnL Subgraph - Conditions
  await testEndpoint('PnL Subgraph - Conditions', SUBGRAPH_ENDPOINTS.pnl, `{
    conditions(first: 3) {
      id
      positionIds
      payoutNumerators
      payoutDenominator
    }
  }`);

  // 3. Activity Subgraph - Splits
  await testEndpoint('Activity Subgraph - Splits', SUBGRAPH_ENDPOINTS.activity, `{
    splits(
      where: { stakeholder: "${TEST_ADDRESS.toLowerCase()}" }
      first: 3
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      timestamp
      stakeholder
      condition
      amount
    }
  }`);

  // 4. Activity Subgraph - Redemptions
  await testEndpoint('Activity Subgraph - Redemptions', SUBGRAPH_ENDPOINTS.activity, `{
    redemptions(
      first: 3
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      timestamp
      redeemer
      condition
      payout
    }
  }`);

  // 5. OI Subgraph - MarketOpenInterest
  await testEndpoint('OI Subgraph - MarketOpenInterest', SUBGRAPH_ENDPOINTS.oi, `{
    marketOpenInterests(first: 5, orderBy: amount, orderDirection: desc) {
      id
      amount
    }
  }`);

  // 6. Wallet Subgraph - Wallets
  await testEndpoint('Wallet Subgraph - Wallets', SUBGRAPH_ENDPOINTS.wallet, `{
    wallets(first: 3, orderBy: balance, orderDirection: desc) {
      id
      signer
      type
      balance
      lastTransfer
      createdAt
    }
  }`);

  // 7. 检查端点版本
  console.log('\n' + '='.repeat(60));
  console.log('📋 尝试查找可用版本');
  console.log('='.repeat(60));

  // 尝试不同版本的 activity subgraph
  const versions = ['prod', '0.0.5', '0.0.4', '0.0.3', '0.0.2', '0.0.1'];
  for (const ver of versions) {
    const url = `https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/${ver}/gn`;
    const result = await query(url, '{ splits(first: 1) { id } }');
    const status = result.errors ? '❌' : '✅';
    console.log(`  activity-subgraph/${ver}: ${status}`);
  }

  console.log('\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/archive/api-verification-history/10-subgraph-official.ts
================================================================================
/**
 * 验证 Polymarket 官方 Subgraph 端点
 *
 * 基于官方文档: https://docs.polymarket.com/developers/subgraph/overview
 * Schema 仓库: https://github.com/Polymarket/polymarket-subgraph
 */

// 官方确认的端点版本
const SUBGRAPH_ENDPOINTS = {
  orderbook: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/orderbook-subgraph/0.0.1/gn',
  positions: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/positions-subgraph/0.0.7/gn',
  activity: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/0.0.4/gn',
  oi: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/oi-subgraph/0.0.6/gn',
  pnl: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn',
};

const TEST_ADDRESS = '0x58c3f5d66c95d4c41b093fbdd2520e46b6c9de74';

async function query(endpoint: string, q: string): Promise<{ data?: unknown; errors?: unknown[] }> {
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: q }),
    });
    if (!response.ok) {
      return { errors: [{ message: `HTTP ${response.status}` }] };
    }
    return await response.json();
  } catch (e) {
    return { errors: [{ message: String(e) }] };
  }
}

interface SchemaField {
  name: string;
  type: { name: string; kind: string; ofType?: { name: string } };
}

async function getSchemaFields(endpoint: string, typeName: string): Promise<string[]> {
  const result = await query(endpoint, `{
    __type(name: "${typeName}") {
      fields { name type { name kind ofType { name } } }
    }
  }`);
  if (result.errors || !result.data) return [];
  const type = (result.data as { __type?: { fields: SchemaField[] } }).__type;
  return type?.fields?.map((f) => f.name) || [];
}

async function getQueryFields(endpoint: string): Promise<string[]> {
  const result = await query(endpoint, `{
    __schema {
      queryType {
        fields { name }
      }
    }
  }`);
  if (result.errors || !result.data) return [];
  const schema = result.data as { __schema: { queryType: { fields: Array<{ name: string }> } } };
  return schema.__schema.queryType.fields.map((f) => f.name).filter((n) => !n.startsWith('_'));
}

async function testEndpoint(name: string, endpoint: string, testQuery: string): Promise<boolean> {
  console.log(`\n${'─'.repeat(60)}`);
  console.log(`📊 ${name}`);
  console.log(`${'─'.repeat(60)}`);

  const result = await query(endpoint, testQuery);

  if (result.errors) {
    console.log('❌ Error:', JSON.stringify(result.errors).slice(0, 200));
    return false;
  }

  console.log('✅ Success');
  console.log(JSON.stringify(result.data, null, 2).slice(0, 600));
  return true;
}

async function exploreSubgraph(name: string, endpoint: string): Promise<void> {
  console.log(`\n${'═'.repeat(60)}`);
  console.log(`🔍 ${name} Subgraph`);
  console.log(`${'═'.repeat(60)}`);

  // 获取可用查询
  const queries = await getQueryFields(endpoint);
  console.log('\n📋 可用查询:', queries.join(', '));
}

async function main(): Promise<void> {
  console.log('🚀 验证 Polymarket 官方 Subgraph');
  console.log('基于: https://docs.polymarket.com/developers/subgraph/overview');
  console.log('Time:', new Date().toISOString());

  const results: Record<string, boolean> = {};

  // ========== 1. Positions Subgraph ==========
  await exploreSubgraph('Positions', SUBGRAPH_ENDPOINTS.positions);

  const posFields = await getSchemaFields(SUBGRAPH_ENDPOINTS.positions, 'UserBalance');
  console.log('\n📋 UserBalance 字段:', posFields.join(', '));

  results['positions-userBalances'] = await testEndpoint('Positions - UserBalances', SUBGRAPH_ENDPOINTS.positions, `{
    userBalances(
      where: { user: "${TEST_ADDRESS.toLowerCase()}" }
      first: 3
      orderBy: balance
      orderDirection: desc
    ) {
      id
      user
      tokenId
      balance
      avgPrice
    }
  }`);

  // ========== 2. PnL Subgraph ==========
  await exploreSubgraph('PnL', SUBGRAPH_ENDPOINTS.pnl);

  const pnlFields = await getSchemaFields(SUBGRAPH_ENDPOINTS.pnl, 'UserPosition');
  console.log('\n📋 UserPosition 字段:', pnlFields.join(', '));

  results['pnl-userPositions'] = await testEndpoint('PnL - UserPositions', SUBGRAPH_ENDPOINTS.pnl, `{
    userPositions(
      where: { user: "${TEST_ADDRESS.toLowerCase()}" }
      first: 3
      orderBy: realizedPnl
      orderDirection: desc
    ) {
      id
      user
      tokenId
      amount
      avgPrice
      realizedPnl
      totalBought
    }
  }`);

  results['pnl-conditions'] = await testEndpoint('PnL - Conditions', SUBGRAPH_ENDPOINTS.pnl, `{
    conditions(first: 3) {
      id
      positionIds
      payoutNumerators
      payoutDenominator
    }
  }`);

  // ========== 3. Activity Subgraph ==========
  await exploreSubgraph('Activity', SUBGRAPH_ENDPOINTS.activity);

  const splitFields = await getSchemaFields(SUBGRAPH_ENDPOINTS.activity, 'Split');
  console.log('\n📋 Split 字段:', splitFields.join(', '));

  results['activity-splits'] = await testEndpoint('Activity - Splits', SUBGRAPH_ENDPOINTS.activity, `{
    splits(
      first: 3
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      timestamp
      stakeholder
      condition
      amount
    }
  }`);

  results['activity-redemptions'] = await testEndpoint('Activity - Redemptions', SUBGRAPH_ENDPOINTS.activity, `{
    redemptions(
      first: 3
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      timestamp
      redeemer
      condition
      payout
    }
  }`);

  // ========== 4. OI Subgraph ==========
  await exploreSubgraph('OI', SUBGRAPH_ENDPOINTS.oi);

  const oiFields = await getSchemaFields(SUBGRAPH_ENDPOINTS.oi, 'MarketOpenInterest');
  console.log('\n📋 MarketOpenInterest 字段:', oiFields.join(', '));

  results['oi-marketOpenInterests'] = await testEndpoint('OI - MarketOpenInterests', SUBGRAPH_ENDPOINTS.oi, `{
    marketOpenInterests(first: 5, orderBy: amount, orderDirection: desc) {
      id
      amount
    }
  }`);

  results['oi-global'] = await testEndpoint('OI - GlobalOpenInterest', SUBGRAPH_ENDPOINTS.oi, `{
    globalOpenInterests(first: 1) {
      id
      amount
    }
  }`);

  // ========== 5. Orderbook Subgraph ==========
  await exploreSubgraph('Orderbook', SUBGRAPH_ENDPOINTS.orderbook);

  const obFields = await getSchemaFields(SUBGRAPH_ENDPOINTS.orderbook, 'OrderFilledEvent');
  console.log('\n📋 OrderFilledEvent 字段:', obFields.join(', '));

  results['orderbook-fills'] = await testEndpoint('Orderbook - OrderFilledEvents', SUBGRAPH_ENDPOINTS.orderbook, `{
    orderFilledEvents(
      first: 3
      orderBy: timestamp
      orderDirection: desc
    ) {
      id
      orderHash
      maker
      taker
      makerAssetId
      takerAssetId
      makerAmountFilled
      takerAmountFilled
      timestamp
    }
  }`);

  // ========== 汇总 ==========
  console.log('\n' + '═'.repeat(60));
  console.log('📋 验证结果汇总');
  console.log('═'.repeat(60));

  let passed = 0;
  let failed = 0;
  for (const [name, success] of Object.entries(results)) {
    console.log(`  ${success ? '✅' : '❌'} ${name}`);
    if (success) passed++;
    else failed++;
  }

  console.log(`\n总计: ${passed} 通过, ${failed} 失败`);
  console.log('\n✅ 验证完成');
}

main().catch(console.error);

================================================================================
// File: scripts/archive/one-off-trading/faze-bo3-arb.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * FaZe vs Passion UA - BO3 Match Winner Arbitrage Monitor (V2 - Instant Merge)
 *
 * V2 策略：配合 token-rebalancer.ts 使用
 * - Long Arb: Buy YES + NO → 立即 Merge（因为账户预存了 tokens）
 * - Short Arb: 直接卖出预存的 tokens
 * - Rebalancer 自动补充 tokens，确保随时有流动性
 *
 * Usage:
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/faze-bo3-arb.ts
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/faze-bo3-arb.ts --auto-execute
 *   POLY_PRIVKEY=0x... npx tsx scripts/v2/faze-bo3-arb.ts --auto-execute --threshold 0.003
 */

import {
    RealtimeServiceV2,
    CTFClient,
    TradingService,
    RateLimiter,
    createUnifiedCache,
    type TokenIds,
  } from '../../src/index.js';
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // MARKET CONFIGURATION - FaZe vs Passion UA BO3 Match Winner
  // ═══════════════════════════════════════════════════════════════════════════════
  
  const MARKET_CONFIG = {
    name: 'CS2: FaZe vs Passion UA (BO3)',
    conditionId: '0x5ac2e92a82ea41ec3a4d9332d323d8d198a8c9acc732b7e6373bd61f45e1df49',
    outcomes: ['FaZe', 'Passion UA'],
    yesTokenId: '89062136554637645106569570664838812035010963361832797298254486917225439629146',
    noTokenId: '54956090965819006918015199317329813503156478664679332459223691084797135448319',
  };
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // CONFIGURATION
  // ═══════════════════════════════════════════════════════════════════════════════
  
  const PRIVATE_KEY = process.env.POLY_PRIVKEY || process.env.POLYMARKET_PRIVATE_KEY || '';
  const RPC_URL = process.env.POLYGON_RPC_URL || 'https://polygon-rpc.com';
  
  const args = process.argv.slice(2);
  const AUTO_EXECUTE = args.includes('--auto-execute');
  const thresholdIdx = args.indexOf('--threshold');
  const PROFIT_THRESHOLD = thresholdIdx !== -1 ? parseFloat(args[thresholdIdx + 1]) : 0.005;
  const MIN_SIZE = 5;
  const MAX_SINGLE_TRADE = 100;
  const MIN_TOKEN_RESERVE = 10;
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // STATE
  // ═══════════════════════════════════════════════════════════════════════════════
  
  interface OrderbookState {
    yesBids: Array<{ price: number; size: number }>;
    yesAsks: Array<{ price: number; size: number }>;
    noBids: Array<{ price: number; size: number }>;
    noAsks: Array<{ price: number; size: number }>;
    lastUpdate: number;
  }
  
  interface BalanceState {
    usdc: number;
    yesTokens: number;
    noTokens: number;
    lastUpdate: number;
  }
  
  let orderbook: OrderbookState = {
    yesBids: [],
    yesAsks: [],
    noBids: [],
    noAsks: [],
    lastUpdate: 0,
  };
  
  let balance: BalanceState = {
    usdc: 0,
    yesTokens: 0,
    noTokens: 0,
    lastUpdate: 0,
  };
  
  let realtimeService: RealtimeServiceV2;
  let ctf: CTFClient | null = null;
  let tradingService: TradingService | null = null;
  
  let isExecuting = false;
  let lastArbCheck = 0;
  let totalOpportunities = 0;
  let totalExecuted = 0;
  let totalProfit = 0;
  
  const tokenIds: TokenIds = {
    yesTokenId: MARKET_CONFIG.yesTokenId,
    noTokenId: MARKET_CONFIG.noTokenId,
  };
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // MAIN
  // ═══════════════════════════════════════════════════════════════════════════════
  
  async function main() {
    console.log('╔════════════════════════════════════════════════════════════════╗');
    console.log('║       FAZE vs PASSION UA - BO3 ARBITRAGE (V2 INSTANT)          ║');
    console.log('╚════════════════════════════════════════════════════════════════╝');
    console.log('');
    console.log(`Market: ${MARKET_CONFIG.name}`);
    console.log(`Outcomes: ${MARKET_CONFIG.outcomes[0]} (YES) vs ${MARKET_CONFIG.outcomes[1]} (NO)`);
    console.log(`Condition ID: ${MARKET_CONFIG.conditionId.slice(0, 20)}...`);
    console.log(`Profit Threshold: ${(PROFIT_THRESHOLD * 100).toFixed(2)}%`);
    console.log(`Auto Execute: ${AUTO_EXECUTE ? 'YES' : 'NO'}`);
    console.log(`Strategy: INSTANT MERGE (with Rebalancer support)`);
    console.log('');
  
    const rateLimiter = new RateLimiter();
    const cache = createUnifiedCache();

    if (PRIVATE_KEY) {
      ctf = new CTFClient({ privateKey: PRIVATE_KEY, rpcUrl: RPC_URL });
      console.log(`Wallet: ${ctf.getAddress()}`);

      tradingService = new TradingService(rateLimiter, cache, { privateKey: PRIVATE_KEY, chainId: 137 });
      await tradingService.initialize();
      console.log('Trading service initialized');
  
      await updateBalance();
      console.log(`USDC.e Balance: ${balance.usdc.toFixed(2)}`);
      console.log(`YES Tokens: ${balance.yesTokens.toFixed(2)}`);
      console.log(`NO Tokens: ${balance.noTokens.toFixed(2)}`);
  
      const heldPairs = Math.min(balance.yesTokens, balance.noTokens);
      if (heldPairs < MIN_TOKEN_RESERVE) {
        console.log(`\n⚠️  Token reserve low (${heldPairs.toFixed(0)} < ${MIN_TOKEN_RESERVE})`);
        console.log(`   Run token-rebalancer.ts to auto-split tokens`);
      }
    } else {
      console.log('No wallet configured - monitoring only');
    }
  
    console.log('');
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('Connecting to WebSocket...');
    console.log('');

    realtimeService = new RealtimeServiceV2({ debug: false });

    // Wait for connection
    const connectedPromise = new Promise<void>((resolve) => {
      realtimeService.once('connected', resolve);
    });

    realtimeService.connect();
    await connectedPromise;
    console.log('WebSocket connected');

    // Subscribe to markets
    realtimeService.subscribeMarkets([MARKET_CONFIG.yesTokenId, MARKET_CONFIG.noTokenId], {
      onOrderbook: handleBookUpdate,
      onError: (error) => console.error('WebSocket error:', error.message),
    });
    console.log(`Subscribed to ${MARKET_CONFIG.outcomes[0]} and ${MARKET_CONFIG.outcomes[1]} tokens`);

    setInterval(updateBalance, 30000);

    process.on('SIGINT', async () => {
      console.log('\n\nShutting down...');
      console.log(`Total opportunities: ${totalOpportunities}, Executed: ${totalExecuted}, Profit: $${totalProfit.toFixed(2)}`);
      realtimeService.disconnect();
      process.exit(0);
    });
  
    console.log('Monitoring for arbitrage opportunities...\n');
  }
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // BALANCE & ORDERBOOK
  // ═══════════════════════════════════════════════════════════════════════════════
  
  async function updateBalance() {
    if (!ctf) return;
    try {
      const [usdcBalance, positions] = await Promise.all([
        ctf.getUsdcBalance(),
        ctf.getPositionBalanceByTokenIds(MARKET_CONFIG.conditionId, tokenIds),
      ]);
      balance.usdc = parseFloat(usdcBalance);
      balance.yesTokens = parseFloat(positions.yesBalance);
      balance.noTokens = parseFloat(positions.noBalance);
      balance.lastUpdate = Date.now();
    } catch (error) {
      console.error('Failed to update balance:', (error as Error).message);
    }
  }
  
  function handleBookUpdate(update: { assetId: string; bids: Array<{ price: string; size: string }>; asks: Array<{ price: string; size: string }> }) {
    const { assetId, bids, asks } = update;
    // Convert string prices/sizes to numbers
    const parsedBids = bids.map(b => ({ price: parseFloat(b.price), size: parseFloat(b.size) }));
    const parsedAsks = asks.map(a => ({ price: parseFloat(a.price), size: parseFloat(a.size) }));

    if (assetId === MARKET_CONFIG.yesTokenId) {
      orderbook.yesBids = parsedBids.sort((a, b) => b.price - a.price);
      orderbook.yesAsks = parsedAsks.sort((a, b) => a.price - b.price);
    } else if (assetId === MARKET_CONFIG.noTokenId) {
      orderbook.noBids = parsedBids.sort((a, b) => b.price - a.price);
      orderbook.noAsks = parsedAsks.sort((a, b) => a.price - b.price);
    }
    orderbook.lastUpdate = Date.now();
    checkArbitrage();
  }
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // ARBITRAGE DETECTION
  // ═══════════════════════════════════════════════════════════════════════════════
  
  function checkArbitrage() {
    const now = Date.now();
    if (now - lastArbCheck < 10) return;
    lastArbCheck = now;
  
    if (orderbook.yesBids.length === 0 || orderbook.noAsks.length === 0) return;
  
    const yesBestBid = orderbook.yesBids[0]?.price || 0;
    const yesBestAsk = orderbook.yesAsks[0]?.price || 1;
    const noBestBid = orderbook.noBids[0]?.price || 0;
    const noBestAsk = orderbook.noAsks[0]?.price || 1;
  
    const effectiveBuyYes = Math.min(yesBestAsk, 1 - noBestBid);
    const effectiveBuyNo = Math.min(noBestAsk, 1 - yesBestBid);
    const effectiveSellYes = Math.max(yesBestBid, 1 - noBestAsk);
    const effectiveSellNo = Math.max(noBestBid, 1 - yesBestAsk);
  
    const longCost = effectiveBuyYes + effectiveBuyNo;
    const longProfit = 1 - longCost;
    const shortRevenue = effectiveSellYes + effectiveSellNo;
    const shortProfit = shortRevenue - 1;
  
    const orderbookLongSize = Math.min(orderbook.yesAsks[0]?.size || 0, orderbook.noAsks[0]?.size || 0);
    const orderbookShortSize = Math.min(orderbook.yesBids[0]?.size || 0, orderbook.noBids[0]?.size || 0);
  
    const heldPairs = Math.min(balance.yesTokens, balance.noTokens);
    const balanceLongSize = longCost > 0 ? balance.usdc / longCost : 0;
    const longSize = Math.min(orderbookLongSize, balanceLongSize, MAX_SINGLE_TRADE);
    const shortSize = Math.min(orderbookShortSize, heldPairs, MAX_SINGLE_TRADE);
  
    const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
    const status = [
      `[${timestamp}]`,
      `${MARKET_CONFIG.outcomes[0]}: ${yesBestBid.toFixed(2)}/${yesBestAsk.toFixed(2)}`,
      `${MARKET_CONFIG.outcomes[1]}: ${noBestBid.toFixed(2)}/${noBestAsk.toFixed(2)}`,
      `Long: ${(longProfit * 100).toFixed(2)}%`,
      `Short: ${(shortProfit * 100).toFixed(2)}%`,
      `Bal: $${balance.usdc.toFixed(0)}`,
      `Pairs: ${heldPairs.toFixed(0)}`,
    ].join(' | ');
  
    const hasLongArb = longProfit > PROFIT_THRESHOLD && longSize >= MIN_SIZE && balance.usdc >= MIN_SIZE;
    const hasShortArb = shortProfit > PROFIT_THRESHOLD && shortSize >= MIN_SIZE && heldPairs >= MIN_TOKEN_RESERVE;
  
    if (hasLongArb || hasShortArb) {
      console.log('\n' + '!'.repeat(75));
      console.log(status);
  
      if (hasLongArb) {
        totalOpportunities++;
        console.log(`\n🎯 LONG ARB: Buy ${MARKET_CONFIG.outcomes[0]} @ ${effectiveBuyYes.toFixed(4)} + ${MARKET_CONFIG.outcomes[1]} @ ${effectiveBuyNo.toFixed(4)}`);
        console.log(`   Cost: ${longCost.toFixed(4)}, Profit: ${(longProfit * 100).toFixed(2)}%, Size: ${longSize.toFixed(2)}, Est: $${(longProfit * longSize).toFixed(2)}`);
        if (AUTO_EXECUTE && !isExecuting) executeLongArb(effectiveBuyYes, effectiveBuyNo, longSize, longProfit);
      }
  
      if (hasShortArb) {
        totalOpportunities++;
        console.log(`\n🎯 SHORT ARB: Sell ${MARKET_CONFIG.outcomes[0]} @ ${effectiveSellYes.toFixed(4)} + ${MARKET_CONFIG.outcomes[1]} @ ${effectiveSellNo.toFixed(4)}`);
        console.log(`   Revenue: ${shortRevenue.toFixed(4)}, Profit: ${(shortProfit * 100).toFixed(2)}%, Size: ${shortSize.toFixed(2)}, Est: $${(shortProfit * shortSize).toFixed(2)}`);
        if (AUTO_EXECUTE && !isExecuting) executeShortArb(shortSize, shortProfit * shortSize);
      }
  
      console.log('!'.repeat(75) + '\n');
    } else {
      process.stdout.write('\r' + status + '    ');
    }
  }
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // EXECUTION
  // ═══════════════════════════════════════════════════════════════════════════════
  
  async function executeLongArb(buyYesPrice: number, buyNoPrice: number, size: number, profitRate: number) {
    if (!ctf || !tradingService || isExecuting) return;
    isExecuting = true;
    const startTime = Date.now();
    console.log('\n🔄 Executing Long Arb (Buy → Instant Merge)...');
  
    try {
      const requiredUsdc = (buyYesPrice + buyNoPrice) * size;
      if (balance.usdc < requiredUsdc) {
        console.log(`❌ Insufficient USDC.e: have ${balance.usdc.toFixed(2)}, need ${requiredUsdc.toFixed(2)}`);
        isExecuting = false;
        return;
      }
  
      console.log(`   1. Buying tokens in parallel...`);
      const orderStartTime = Date.now();
      const [buyYesResult, buyNoResult] = await Promise.all([
        tradingService.createMarketOrder({ tokenId: MARKET_CONFIG.yesTokenId, side: 'BUY', amount: size * buyYesPrice, orderType: 'FOK' }),
        tradingService.createMarketOrder({ tokenId: MARKET_CONFIG.noTokenId, side: 'BUY', amount: size * buyNoPrice, orderType: 'FOK' }),
      ]);
      console.log(`      ${MARKET_CONFIG.outcomes[0]}: ${buyYesResult.success ? '✓' : '✗'}, ${MARKET_CONFIG.outcomes[1]}: ${buyNoResult.success ? '✓' : '✗'} (${Date.now() - orderStartTime}ms)`);
  
      if (!buyYesResult.success || !buyNoResult.success) {
        console.log(`❌ Order(s) failed - will retry on next opportunity`);
        if (buyYesResult.errorMsg) console.log(`   YES Error: ${buyYesResult.errorMsg}`);
        if (buyNoResult.errorMsg) console.log(`   NO Error: ${buyNoResult.errorMsg}`);
        isExecuting = false;
        return;
      }
  
      // Immediate merge using pre-held tokens
      const heldPairs = Math.min(balance.yesTokens, balance.noTokens);
      const mergeSize = Math.floor(Math.min(size, heldPairs) * 1e6) / 1e6;
  
      if (mergeSize >= MIN_SIZE) {
        console.log(`   2. Merging ${mergeSize.toFixed(2)} pairs from pre-held tokens...`);
        try {
          const mergeResult = await ctf.merge(MARKET_CONFIG.conditionId, mergeSize.toString());
          console.log(`      TX: ${mergeResult.txHash}`);
  
          const estProfit = profitRate * mergeSize;
          totalProfit += estProfit;
          console.log(`✅ Long Arb completed! Profit: ~$${estProfit.toFixed(2)}. Total: ${Date.now() - startTime}ms`);
        } catch (mergeError: any) {
          console.log(`   ⚠️ Merge failed: ${mergeError.message}`);
          console.log(`   Tokens will be held for later merge by rebalancer`);
        }
      } else {
        console.log(`   2. Skipping merge (held pairs ${heldPairs.toFixed(2)} < ${MIN_SIZE})`);
        console.log(`   Tokens held - rebalancer will merge later`);
      }
  
      totalExecuted++;
      await new Promise(r => setTimeout(r, 2000));
      await updateBalance();
      console.log(`   New balance: USDC=${balance.usdc.toFixed(2)}, YES=${balance.yesTokens.toFixed(2)}, NO=${balance.noTokens.toFixed(2)}`);
    } catch (error) {
      console.log(`❌ Long Arb failed: ${(error as Error).message}`);
    }
    isExecuting = false;
  }
  
  async function executeShortArb(size: number, estProfit: number) {
    if (!ctf || !tradingService || isExecuting) return;
    isExecuting = true;
    const startTime = Date.now();
    console.log('\n🔄 Executing Short Arb (Sell Pre-held Tokens)...');
  
    try {
      const heldPairs = Math.min(balance.yesTokens, balance.noTokens);
      if (heldPairs < size) {
        console.log(`❌ Insufficient held tokens: have ${heldPairs.toFixed(2)}, need ${size.toFixed(2)}`);
        console.log(`   Run token-rebalancer.ts to auto-split more tokens`);
        isExecuting = false;
        return;
      }
  
      console.log(`   1. Selling pre-held tokens in parallel...`);
      const orderStartTime = Date.now();
      const [sellYesResult, sellNoResult] = await Promise.all([
        tradingService.createMarketOrder({ tokenId: MARKET_CONFIG.yesTokenId, side: 'SELL', amount: size, orderType: 'FOK' }),
        tradingService.createMarketOrder({ tokenId: MARKET_CONFIG.noTokenId, side: 'SELL', amount: size, orderType: 'FOK' }),
      ]);
      console.log(`      ${MARKET_CONFIG.outcomes[0]}: ${sellYesResult.success ? '✓' : '✗'}, ${MARKET_CONFIG.outcomes[1]}: ${sellNoResult.success ? '✓' : '✗'} (${Date.now() - orderStartTime}ms)`);
  
      if (!sellYesResult.success || !sellNoResult.success) {
        console.log(`❌ Order(s) failed`);
        if (sellYesResult.errorMsg) console.log(`   YES Error: ${sellYesResult.errorMsg}`);
        if (sellNoResult.errorMsg) console.log(`   NO Error: ${sellNoResult.errorMsg}`);
        isExecuting = false;
        return;
      }
  
      console.log(`✅ Short Arb completed! Profit: ~$${estProfit.toFixed(2)}. Total: ${Date.now() - startTime}ms`);
      totalExecuted++;
      totalProfit += estProfit;
  
      await new Promise(r => setTimeout(r, 2000));
      await updateBalance();
      console.log(`   New balance: USDC=${balance.usdc.toFixed(2)}, YES=${balance.yesTokens.toFixed(2)}, NO=${balance.noTokens.toFixed(2)}`);
  
      const newHeldPairs = Math.min(balance.yesTokens, balance.noTokens);
      if (newHeldPairs < MIN_TOKEN_RESERVE) {
        console.log(`   ⚠️ Token reserve low (${newHeldPairs.toFixed(0)}) - rebalancer should split more`);
      }
    } catch (error) {
      console.log(`❌ Short Arb failed: ${(error as Error).message}`);
    }
    isExecuting = false;
  }
  
  main().catch(console.error);

================================================================================
// File: scripts/archive/one-off-trading/sell-nvidia-positions.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Sell NVIDIA Market Positions
 *
 * Sells both YES and NO tokens from the NVIDIA market to recover USDC.
 *
 * Usage:
 *   # Dry run
 *   npx tsx scripts/sell-nvidia-positions.ts
 *
 *   # Execute
 *   npx tsx scripts/sell-nvidia-positions.ts --execute
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { ethers } from 'ethers';
import {
  TradingService,
  RateLimiter,
  createUnifiedCache,
  CTFClient,
} from '../../src/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = match ? match[1].trim() : '';

if (!PRIVATE_KEY) {
  console.error('PRIVATE_KEY not found');
  process.exit(1);
}

const EXECUTE = process.argv.includes('--execute');

// NVIDIA market token IDs (from report)
const NVIDIA_MARKET = {
  conditionId: '0x0b16eb7741855ca3d4c8293089b5a9bdf7e59a6cf7f86ab87eb59c60ca01bbcf',
  yesTokenId: '94850533403292240972948844256810904078895883844462287088135166537739765648754',
  noTokenId: '69263280792958981516606123639467754139758192236863611059536531765186180114584',
  question: 'NVIDIA largest company by market cap on Dec 31',
};

// Conditional Tokens contract ABI
const CTF_ABI = [
  'function balanceOf(address account, uint256 positionId) view returns (uint256)',
];
const CTF_ADDRESS = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║              SELL NVIDIA POSITIONS                             ║');
  console.log('╠════════════════════════════════════════════════════════════════╣');
  console.log(`║  Mode: ${EXECUTE ? '🔥 EXECUTE' : '👀 DRY RUN'}                                          ║`);
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');

  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const ctf = new CTFClient({ privateKey: PRIVATE_KEY });
  const tradingService = new TradingService(rateLimiter, cache, { privateKey: PRIVATE_KEY });

  const address = ctf.getAddress();
  console.log(`Wallet: ${address}`);
  console.log(`Market: ${NVIDIA_MARKET.question}`);
  console.log('');

  // Create provider and CTF contract for balance queries
  const provider = new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
  const ctfContract = new ethers.Contract(CTF_ADDRESS, CTF_ABI, provider);

  // Get current balances
  const usdcBalance = await ctf.getUsdcBalance();
  const yesBalanceRaw = await ctfContract.balanceOf(address, NVIDIA_MARKET.yesTokenId);
  const noBalanceRaw = await ctfContract.balanceOf(address, NVIDIA_MARKET.noTokenId);
  const yesBalance = ethers.utils.formatUnits(yesBalanceRaw, 6);
  const noBalance = ethers.utils.formatUnits(noBalanceRaw, 6);

  console.log('─── Current Balances ───');
  console.log(`USDC: $${parseFloat(usdcBalance).toFixed(2)}`);
  console.log(`YES:  ${parseFloat(yesBalance).toFixed(2)} tokens`);
  console.log(`NO:   ${parseFloat(noBalance).toFixed(2)} tokens`);
  console.log('');

  // Get market prices
  const orderbook = await tradingService.getProcessedOrderbook(NVIDIA_MARKET.yesTokenId);
  const yesBid = orderbook?.bids?.[0]?.price ?? 0;
  const yesAsk = orderbook?.asks?.[0]?.price ?? 1;

  const noOrderbook = await tradingService.getProcessedOrderbook(NVIDIA_MARKET.noTokenId);
  const noBid = noOrderbook?.bids?.[0]?.price ?? 0;
  const noAsk = noOrderbook?.asks?.[0]?.price ?? 1;

  console.log('─── Market Prices ───');
  console.log(`YES: bid=$${yesBid.toFixed(3)} ask=$${yesAsk.toFixed(3)}`);
  console.log(`NO:  bid=$${noBid.toFixed(3)} ask=$${noAsk.toFixed(3)}`);
  console.log('');

  const yesValue = parseFloat(yesBalance) * yesBid;
  const noValue = parseFloat(noBalance) * noBid;

  console.log('─── Expected Value (at bid prices) ───');
  console.log(`YES: ${parseFloat(yesBalance).toFixed(2)} × $${yesBid.toFixed(3)} = $${yesValue.toFixed(2)}`);
  console.log(`NO:  ${parseFloat(noBalance).toFixed(2)} × $${noBid.toFixed(3)} = $${noValue.toFixed(2)}`);
  console.log(`Total: $${(yesValue + noValue).toFixed(2)}`);
  console.log('');

  if (!EXECUTE) {
    console.log('💡 Run with --execute to sell positions:');
    console.log('   npx tsx scripts/sell-nvidia-positions.ts --execute');
    return;
  }

  // Initialize trading service
  console.log('─── Executing Trades ───');
  console.log('Initializing trading service...');
  await tradingService.initialize();
  console.log('Trading service ready.');
  console.log('');

  // Sell YES tokens if we have any
  if (parseFloat(yesBalance) >= 1) {
    console.log(`Selling ${parseFloat(yesBalance).toFixed(2)} YES tokens...`);
    try {
      const result = await tradingService.createMarketOrder({
        tokenId: NVIDIA_MARKET.yesTokenId,
        side: 'SELL',
        amount: parseFloat(yesBalance),
        orderType: 'FAK', // Fill-and-Kill allows partial fills
      });

      if (result.success) {
        console.log(`✅ YES sold! Order ID: ${result.orderId || 'N/A'}`);
        if (result.transactionHashes?.length) {
          console.log(`   TX: ${result.transactionHashes[0]}`);
        }
      } else {
        console.log(`⚠️ YES order may not have filled: ${result.errorMsg || 'Unknown'}`);
      }
    } catch (error: any) {
      console.log(`❌ YES sell failed: ${error.message}`);
    }
  } else {
    console.log('No YES tokens to sell (balance < 1)');
  }

  console.log('');

  // Sell NO tokens if we have any
  if (parseFloat(noBalance) >= 1) {
    console.log(`Selling ${parseFloat(noBalance).toFixed(2)} NO tokens...`);
    try {
      const result = await tradingService.createMarketOrder({
        tokenId: NVIDIA_MARKET.noTokenId,
        side: 'SELL',
        amount: parseFloat(noBalance),
        orderType: 'FAK', // Fill-and-Kill allows partial fills
      });

      if (result.success) {
        console.log(`✅ NO sold! Order ID: ${result.orderId || 'N/A'}`);
        if (result.transactionHashes?.length) {
          console.log(`   TX: ${result.transactionHashes[0]}`);
        }
      } else {
        console.log(`⚠️ NO order may not have filled: ${result.errorMsg || 'Unknown'}`);
      }
    } catch (error: any) {
      console.log(`❌ NO sell failed: ${error.message}`);
    }
  } else {
    console.log('No NO tokens to sell (balance < 1)');
  }

  console.log('');

  // Wait a bit for balances to update
  await new Promise((r) => setTimeout(r, 2000));

  // Get final balances
  const finalUsdc = await ctf.getUsdcBalance();
  const finalYesRaw = await ctfContract.balanceOf(address, NVIDIA_MARKET.yesTokenId);
  const finalNoRaw = await ctfContract.balanceOf(address, NVIDIA_MARKET.noTokenId);
  const finalYes = ethers.utils.formatUnits(finalYesRaw, 6);
  const finalNo = ethers.utils.formatUnits(finalNoRaw, 6);

  console.log('─── Final Balances ───');
  console.log(`USDC: $${parseFloat(finalUsdc).toFixed(2)} (${parseFloat(finalUsdc) >= parseFloat(usdcBalance) ? '+' : ''}$${(parseFloat(finalUsdc) - parseFloat(usdcBalance)).toFixed(2)})`);
  console.log(`YES:  ${parseFloat(finalYes).toFixed(2)} tokens`);
  console.log(`NO:   ${parseFloat(finalNo).toFixed(2)} tokens`);
  console.log('');

  console.log('✅ Done!');
}

main().catch(console.error);

================================================================================
// File: scripts/benchmark/compare.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Compare Benchmark Results
 *
 * 比较不同服务器/时间的 benchmark 结果
 *
 * Usage:
 *   npx tsx scripts/benchmark/compare.ts result1.json result2.json
 *   npx tsx scripts/benchmark/compare.ts ./local.json ./vultr.json ./aws.json
 */

import * as fs from 'fs';

interface BenchmarkReport {
  timestamp: string;
  system: {
    platform: string;
    hostname: string;
    cpuModel: string;
    memory: string;
  };
  totalDuration: number;
  benchmarks: Array<{
    name: string;
    success: boolean;
    duration: number;
    results: any;
  }>;
}

// ========================================
// Main
// ========================================

async function main() {
  const files = process.argv.slice(2);

  if (files.length < 2) {
    console.log('Usage: npx tsx compare.ts <result1.json> <result2.json> [result3.json ...]');
    console.log('');
    console.log('Example:');
    console.log('  npx tsx compare.ts ./local.json ./vultr.json');
    process.exit(1);
  }

  const reports: Array<{ file: string; data: BenchmarkReport }> = [];

  for (const file of files) {
    if (!fs.existsSync(file)) {
      console.error(`File not found: ${file}`);
      process.exit(1);
    }

    try {
      const data = JSON.parse(fs.readFileSync(file, 'utf-8'));
      reports.push({ file, data });
    } catch (error) {
      console.error(`Failed to parse ${file}:`, error);
      process.exit(1);
    }
  }

  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║           Benchmark Comparison Report                    ║');
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  // System info comparison
  console.log('📋 Systems Compared:');
  console.log('─────────────────────────────────────────────────────────');

  for (const { file, data } of reports) {
    const sys = data.system;
    console.log(`   ${file}:`);
    console.log(`      Host:     ${sys.hostname || 'Unknown'}`);
    console.log(`      Platform: ${sys.platform || 'Unknown'}`);
    console.log(`      CPU:      ${sys.cpuModel || 'Unknown'}`);
    console.log(`      Memory:   ${sys.memory || 'Unknown'}`);
    console.log(`      Time:     ${data.timestamp}`);
    console.log('');
  }

  // WebSocket comparison
  console.log('📡 WebSocket Latency:');
  console.log('─────────────────────────────────────────────────────────');

  const wsHeaders = ['Metric', ...reports.map(r => r.data.system.hostname || r.file.slice(0, 15))];
  const wsMetrics = ['Connection (ms)', 'Msgs/sec', 'Interval P50 (ms)', 'Interval P95 (ms)'];

  // Build header
  console.log('┌' + '─'.repeat(20) + reports.map(() => '┬' + '─'.repeat(15)).join('') + '┐');
  console.log('│' + wsHeaders[0].padEnd(20) + reports.map((_, i) => '│' + wsHeaders[i + 1].padStart(14) + ' ').join('') + '│');
  console.log('├' + '─'.repeat(20) + reports.map(() => '┼' + '─'.repeat(15)).join('') + '┤');

  // Connection time
  const connTimes = reports.map(r => {
    const ws = r.data.benchmarks.find(b => b.name === 'ws-latency')?.results;
    return ws?.connection?.timeMs?.toFixed(0) || 'N/A';
  });
  console.log('│' + 'Connection (ms)'.padEnd(20) + connTimes.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');

  // Messages per second
  const msgRates = reports.map(r => {
    const ws = r.data.benchmarks.find(b => b.name === 'ws-latency')?.results;
    return ws?.messages?.perSecond?.toFixed(2) || 'N/A';
  });
  console.log('│' + 'Msgs/sec'.padEnd(20) + msgRates.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');

  // Interval P50
  const p50s = reports.map(r => {
    const ws = r.data.benchmarks.find(b => b.name === 'ws-latency')?.results;
    return ws?.interval?.p50?.toFixed(2) || 'N/A';
  });
  console.log('│' + 'Interval P50 (ms)'.padEnd(20) + p50s.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');

  // Interval P95
  const p95s = reports.map(r => {
    const ws = r.data.benchmarks.find(b => b.name === 'ws-latency')?.results;
    return ws?.interval?.p95?.toFixed(2) || 'N/A';
  });
  console.log('│' + 'Interval P95 (ms)'.padEnd(20) + p95s.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');

  console.log('└' + '─'.repeat(20) + reports.map(() => '┴' + '─'.repeat(15)).join('') + '┘');
  console.log('');

  // Order API comparison
  console.log('📊 Order API Latency (avg ms):');
  console.log('─────────────────────────────────────────────────────────');

  console.log('┌' + '─'.repeat(20) + reports.map(() => '┬' + '─'.repeat(15)).join('') + '┐');
  console.log('│' + 'Operation'.padEnd(20) + reports.map(r => '│' + (r.data.system.hostname || r.file.slice(0, 14)).padStart(14) + ' ').join('') + '│');
  console.log('├' + '─'.repeat(20) + reports.map(() => '┼' + '─'.repeat(15)).join('') + '┤');

  const orderOps = ['getOrderbook', 'getBestPrices', 'estimateExecution'];
  for (const op of orderOps) {
    const values = reports.map(r => {
      const order = r.data.benchmarks.find(b => b.name === 'order-latency')?.results;
      return order?.[op]?.avg?.toFixed(2) || 'N/A';
    });
    console.log('│' + op.padEnd(20) + values.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');
  }

  console.log('└' + '─'.repeat(20) + reports.map(() => '┴' + '─'.repeat(15)).join('') + '┘');
  console.log('');

  // RPC comparison
  console.log('🔗 RPC Latency (avg ms):');
  console.log('─────────────────────────────────────────────────────────');

  // Collect all unique RPC endpoints across all reports
  const allEndpoints = new Set<string>();
  for (const { data } of reports) {
    const rpc = data.benchmarks.find(b => b.name === 'rpc-latency')?.results;
    if (rpc?.endpoints) {
      for (const ep of rpc.endpoints) {
        allEndpoints.add(ep.name);
      }
    }
  }

  if (allEndpoints.size > 0) {
    console.log('┌' + '─'.repeat(20) + reports.map(() => '┬' + '─'.repeat(15)).join('') + '┐');
    console.log('│' + 'Endpoint'.padEnd(20) + reports.map(r => '│' + (r.data.system.hostname || r.file.slice(0, 14)).padStart(14) + ' ').join('') + '│');
    console.log('├' + '─'.repeat(20) + reports.map(() => '┼' + '─'.repeat(15)).join('') + '┤');

    for (const epName of Array.from(allEndpoints)) {
      const values = reports.map(r => {
        const rpc = r.data.benchmarks.find(b => b.name === 'rpc-latency')?.results;
        const ep = rpc?.endpoints?.find((e: any) => e.name === epName);
        return ep?.stats?.getBlockNumber?.avg?.toFixed(2) || 'N/A';
      });
      console.log('│' + epName.slice(0, 19).padEnd(20) + values.map(v => '│' + String(v).padStart(14) + ' ').join('') + '│');
    }

    console.log('└' + '─'.repeat(20) + reports.map(() => '┴' + '─'.repeat(15)).join('') + '┘');
  }
  console.log('');

  // Winner summary
  console.log('🏆 Summary:');
  console.log('─────────────────────────────────────────────────────────');

  // Find best WebSocket
  const wsScores = reports.map((r, i) => {
    const ws = r.data.benchmarks.find(b => b.name === 'ws-latency')?.results;
    const p50 = ws?.interval?.p50 ?? Infinity;
    return { index: i, p50, name: r.data.system.hostname || r.file };
  });
  wsScores.sort((a, b) => a.p50 - b.p50);

  if (wsScores[0].p50 !== Infinity) {
    console.log(`   Best WebSocket Latency:  ${wsScores[0].name} (P50: ${wsScores[0].p50.toFixed(2)}ms)`);
  }

  // Find best order API
  const orderScores = reports.map((r, i) => {
    const order = r.data.benchmarks.find(b => b.name === 'order-latency')?.results;
    const avg = order?.getOrderbook?.avg ?? Infinity;
    return { index: i, avg, name: r.data.system.hostname || r.file };
  });
  orderScores.sort((a, b) => a.avg - b.avg);

  if (orderScores[0].avg !== Infinity) {
    console.log(`   Best Order API Latency:  ${orderScores[0].name} (Avg: ${orderScores[0].avg.toFixed(2)}ms)`);
  }

  console.log('');
  console.log('💡 Lower latency = better for trading');
}

main().catch(console.error);

================================================================================
// File: scripts/benchmark/order-latency.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Order Latency Benchmark
 *
 * 测试在 Polymarket API 的延迟
 *
 * 测量指标：
 * - 订单簿获取延迟
 * - 市场数据获取延迟
 * - 下单延迟（如果配置了 API Key）
 *
 * Usage:
 *   npx tsx scripts/benchmark/order-latency.ts
 *   npx tsx scripts/benchmark/order-latency.ts --rounds 10
 */

import { PolymarketSDK } from '../../src/index.js';

// ========================================
// Configuration
// ========================================

const ROUNDS = parseInt(process.argv.find(a => a.startsWith('--rounds='))?.split('=')[1] || '5');
const DRY_RUN = process.argv.includes('--dry-run');

interface LatencyResult {
  operation: string;
  latencyMs: number;
  success: boolean;
  error?: string;
}

// ========================================
// Main
// ========================================

async function main() {
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║           Order Latency Benchmark                        ║');
  console.log('╠══════════════════════════════════════════════════════════╣');
  console.log(`║  Rounds:    ${ROUNDS}                                              ║`);
  console.log(`║  Dry Run:   ${DRY_RUN ? 'YES (no actual orders)' : 'NO (will place real orders)'}              ║`);
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  const sdk = new PolymarketSDK();
  const results: LatencyResult[] = [];

  // Find an active market
  console.log('🔍 Finding active market...');
  const markets = await sdk.dipArb.scanUpcomingMarkets({
    coin: 'BTC',
    duration: '15m',
    minMinutesUntilEnd: 5,
    maxMinutesUntilEnd: 30,
    limit: 1,
  });

  if (markets.length === 0) {
    console.log('❌ No active markets found. Try again later.');
    process.exit(1);
  }

  const market = markets[0];
  console.log(`✅ Found: ${market.name}`);
  console.log(`   Condition: ${market.conditionId.slice(0, 20)}...`);
  console.log('');

  // Benchmark 1: Get Processed Orderbook (includes analytics)
  console.log('📊 Benchmark 1: Get Processed Orderbook Latency');
  console.log('───────────────────────────────────────────────');

  for (let i = 0; i < ROUNDS; i++) {
    const start = performance.now();
    try {
      await sdk.getOrderbook(market.conditionId);
      const latency = performance.now() - start;
      results.push({ operation: 'getOrderbook', latencyMs: latency, success: true });
      console.log(`   Round ${i + 1}: ${latency.toFixed(2)}ms`);
    } catch (error) {
      const latency = performance.now() - start;
      results.push({
        operation: 'getOrderbook',
        latencyMs: latency,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
      console.log(`   Round ${i + 1}: FAILED - ${error instanceof Error ? error.message : String(error)}`);
    }
    // Small delay between requests
    await new Promise(r => setTimeout(r, 200));
  }
  console.log('');

  // Benchmark 2: Get Market Data
  console.log('📊 Benchmark 2: Get Market Data Latency');
  console.log('───────────────────────────────────────');

  for (let i = 0; i < ROUNDS; i++) {
    const start = performance.now();
    try {
      await sdk.getMarket(market.conditionId);
      const latency = performance.now() - start;
      results.push({ operation: 'getMarket', latencyMs: latency, success: true });
      console.log(`   Round ${i + 1}: ${latency.toFixed(2)}ms`);
    } catch (error) {
      const latency = performance.now() - start;
      results.push({
        operation: 'getMarket',
        latencyMs: latency,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
      console.log(`   Round ${i + 1}: FAILED - ${error instanceof Error ? error.message : String(error)}`);
    }
    await new Promise(r => setTimeout(r, 200));
  }
  console.log('');

  // Benchmark 3: Detect Arbitrage (includes orderbook fetch + calculations)
  console.log('📊 Benchmark 3: Detect Arbitrage Latency');
  console.log('────────────────────────────────────────');

  for (let i = 0; i < ROUNDS; i++) {
    const start = performance.now();
    try {
      await sdk.detectArbitrage(market.conditionId);
      const latency = performance.now() - start;
      results.push({ operation: 'detectArbitrage', latencyMs: latency, success: true });
      console.log(`   Round ${i + 1}: ${latency.toFixed(2)}ms`);
    } catch (error) {
      const latency = performance.now() - start;
      results.push({
        operation: 'detectArbitrage',
        latencyMs: latency,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
      console.log(`   Round ${i + 1}: FAILED - ${error instanceof Error ? error.message : String(error)}`);
    }
    await new Promise(r => setTimeout(r, 200));
  }
  console.log('');

  // Benchmark 4: Place and Cancel Order (if not dry run and has trading service)
  const tradingService = (sdk as any).tradingService;
  if (!DRY_RUN && tradingService) {
    console.log('📊 Benchmark 4: Place & Cancel Order Latency');
    console.log('─────────────────────────────────────────────');

    try {
      await tradingService.initialize();
    } catch (error) {
      console.log(`⚠️  Trading service not available: ${error instanceof Error ? error.message : String(error)}`);
      console.log('   Skipping order placement tests.');
      console.log('');
    }

    if (tradingService.isInitialized?.()) {
      // Use a very low price that won't fill
      const testPrice = 0.01;
      const testSize = 10;

      for (let i = 0; i < Math.min(ROUNDS, 3); i++) {
        // Place order
        const placeStart = performance.now();
        try {
          const orderResult = await tradingService.createLimitOrder({
            tokenId: market.upTokenId,
            side: 'BUY',
            price: testPrice,
            size: testSize,
          });
          const placeLatency = performance.now() - placeStart;
          results.push({ operation: 'createLimitOrder', latencyMs: placeLatency, success: orderResult.success });
          console.log(`   Round ${i + 1} Place: ${placeLatency.toFixed(2)}ms`);

          // Cancel order
          if (orderResult.success && orderResult.orderId) {
            await new Promise(r => setTimeout(r, 500));
            const cancelStart = performance.now();
            await tradingService.cancelOrder(orderResult.orderId);
            const cancelLatency = performance.now() - cancelStart;
            results.push({ operation: 'cancelOrder', latencyMs: cancelLatency, success: true });
            console.log(`   Round ${i + 1} Cancel: ${cancelLatency.toFixed(2)}ms`);
          }
        } catch (error) {
          const latency = performance.now() - placeStart;
          results.push({
            operation: 'createLimitOrder',
            latencyMs: latency,
            success: false,
            error: error instanceof Error ? error.message : String(error),
          });
          console.log(`   Round ${i + 1}: FAILED - ${error instanceof Error ? error.message : String(error)}`);
        }
        await new Promise(r => setTimeout(r, 1000));
      }
      console.log('');
    }
  } else {
    console.log('⏭️  Skipping order placement (dry run mode or no trading service)');
    console.log('');
  }

  // Calculate statistics
  console.log('═══════════════════════════════════════════════════════════');
  console.log('                      RESULTS                              ');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('');

  const calcStats = (arr: number[]) => {
    if (arr.length === 0) return null;
    const sorted = [...arr].sort((a, b) => a - b);
    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: arr.reduce((a, b) => a + b, 0) / arr.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
    };
  };

  const operations = ['getOrderbook', 'getMarket', 'detectArbitrage', 'createLimitOrder', 'cancelOrder'];

  for (const op of operations) {
    const opResults = results.filter(r => r.operation === op && r.success);
    if (opResults.length === 0) continue;

    const latencies = opResults.map(r => r.latencyMs);
    const stats = calcStats(latencies);
    if (!stats) continue;

    console.log(`📈 ${op}:`);
    console.log(`   Samples:  ${opResults.length}`);
    console.log(`   Min:      ${stats.min.toFixed(2)}ms`);
    console.log(`   Max:      ${stats.max.toFixed(2)}ms`);
    console.log(`   Avg:      ${stats.avg.toFixed(2)}ms`);
    console.log(`   P50:      ${stats.p50.toFixed(2)}ms`);
    console.log(`   P95:      ${stats.p95.toFixed(2)}ms`);
    console.log('');
  }

  // Output JSON for comparison
  const summary: Record<string, any> = {
    timestamp: new Date().toISOString(),
    rounds: ROUNDS,
    dryRun: DRY_RUN,
    market: market.slug,
  };

  for (const op of operations) {
    const opResults = results.filter(r => r.operation === op && r.success);
    if (opResults.length === 0) continue;
    const latencies = opResults.map(r => r.latencyMs);
    summary[op] = calcStats(latencies);
  }

  console.log('📄 JSON Result:');
  console.log(JSON.stringify(summary, null, 2));

  sdk.stop();
}

main().catch(console.error);

================================================================================
// File: scripts/benchmark/rpc-latency.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * RPC Latency Benchmark
 *
 * 测试 Polygon RPC 节点的延迟
 *
 * 测量指标：
 * - 获取区块号延迟
 * - 获取余额延迟
 * - 不同 RPC 端点的对比
 *
 * Usage:
 *   npx tsx scripts/benchmark/rpc-latency.ts
 *   npx tsx scripts/benchmark/rpc-latency.ts --rounds 10
 */

// ========================================
// Configuration
// ========================================

const ROUNDS = parseInt(process.argv.find(a => a.startsWith('--rounds='))?.split('=')[1] || '5');

// Common RPC endpoints to test
const RPC_ENDPOINTS = [
  { name: 'Polygon Public', url: 'https://polygon-rpc.com' },
  { name: 'Ankr', url: 'https://rpc.ankr.com/polygon' },
  { name: 'Alchemy', url: process.env.POLYGON_RPC_URL || '' },
].filter(e => e.url);

// Test wallet address (Polymarket Exchange)
const TEST_ADDRESS = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';

interface RpcResult {
  endpoint: string;
  operation: string;
  latencyMs: number;
  success: boolean;
  error?: string;
}

// ========================================
// RPC Helper
// ========================================

async function rpcCall(url: string, method: string, params: any[]): Promise<any> {
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method,
      params,
      id: 1,
    }),
  });

  const data = await response.json();
  if (data.error) {
    throw new Error(data.error.message || 'RPC error');
  }
  return data.result;
}

// ========================================
// Main
// ========================================

async function main() {
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║           RPC Latency Benchmark                          ║');
  console.log('╠══════════════════════════════════════════════════════════╣');
  console.log(`║  Rounds:     ${ROUNDS}                                             ║`);
  console.log(`║  Endpoints:  ${RPC_ENDPOINTS.length}                                             ║`);
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  const results: RpcResult[] = [];

  for (const endpoint of RPC_ENDPOINTS) {
    console.log(`📡 Testing: ${endpoint.name}`);
    console.log(`   URL: ${endpoint.url.slice(0, 40)}...`);
    console.log('─────────────────────────────────────────');

    // Test 1: Get Block Number
    console.log('   📊 eth_blockNumber:');
    for (let i = 0; i < ROUNDS; i++) {
      const start = performance.now();
      try {
        await rpcCall(endpoint.url, 'eth_blockNumber', []);
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_blockNumber',
          latencyMs: latency,
          success: true,
        });
        console.log(`      Round ${i + 1}: ${latency.toFixed(2)}ms`);
      } catch (error) {
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_blockNumber',
          latencyMs: latency,
          success: false,
          error: error instanceof Error ? error.message : String(error),
        });
        console.log(`      Round ${i + 1}: FAILED`);
      }
      await new Promise(r => setTimeout(r, 100));
    }

    // Test 2: Get Balance
    console.log('   📊 eth_getBalance:');
    for (let i = 0; i < ROUNDS; i++) {
      const start = performance.now();
      try {
        const balance = await rpcCall(endpoint.url, 'eth_getBalance', [TEST_ADDRESS, 'latest']);
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_getBalance',
          latencyMs: latency,
          success: true,
        });
        if (i === 0) {
          const balanceEth = parseInt(balance, 16) / 1e18;
          console.log(`      Balance: ${balanceEth.toFixed(4)} MATIC`);
        }
        console.log(`      Round ${i + 1}: ${latency.toFixed(2)}ms`);
      } catch (error) {
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_getBalance',
          latencyMs: latency,
          success: false,
          error: error instanceof Error ? error.message : String(error),
        });
        console.log(`      Round ${i + 1}: FAILED`);
      }
      await new Promise(r => setTimeout(r, 100));
    }

    // Test 3: Get Gas Price
    console.log('   📊 eth_gasPrice:');
    for (let i = 0; i < ROUNDS; i++) {
      const start = performance.now();
      try {
        const gasPrice = await rpcCall(endpoint.url, 'eth_gasPrice', []);
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_gasPrice',
          latencyMs: latency,
          success: true,
        });
        if (i === 0) {
          const gasPriceGwei = parseInt(gasPrice, 16) / 1e9;
          console.log(`      Gas Price: ${gasPriceGwei.toFixed(2)} Gwei`);
        }
        console.log(`      Round ${i + 1}: ${latency.toFixed(2)}ms`);
      } catch (error) {
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_gasPrice',
          latencyMs: latency,
          success: false,
          error: error instanceof Error ? error.message : String(error),
        });
        console.log(`      Round ${i + 1}: FAILED`);
      }
      await new Promise(r => setTimeout(r, 100));
    }

    // Test 4: Get Latest Block
    console.log('   📊 eth_getBlockByNumber:');
    for (let i = 0; i < ROUNDS; i++) {
      const start = performance.now();
      try {
        await rpcCall(endpoint.url, 'eth_getBlockByNumber', ['latest', false]);
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_getBlockByNumber',
          latencyMs: latency,
          success: true,
        });
        console.log(`      Round ${i + 1}: ${latency.toFixed(2)}ms`);
      } catch (error) {
        const latency = performance.now() - start;
        results.push({
          endpoint: endpoint.name,
          operation: 'eth_getBlockByNumber',
          latencyMs: latency,
          success: false,
          error: error instanceof Error ? error.message : String(error),
        });
        console.log(`      Round ${i + 1}: FAILED`);
      }
      await new Promise(r => setTimeout(r, 100));
    }

    console.log('');
  }

  // Calculate statistics
  console.log('═══════════════════════════════════════════════════════════');
  console.log('                      RESULTS                              ');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('');

  const calcStats = (arr: number[]) => {
    if (arr.length === 0) return null;
    const sorted = [...arr].sort((a, b) => a - b);
    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: arr.reduce((a, b) => a + b, 0) / arr.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
    };
  };

  // Summary by endpoint
  const summary: Record<string, Record<string, ReturnType<typeof calcStats>>> = {};

  for (const endpoint of RPC_ENDPOINTS) {
    summary[endpoint.name] = {};
    const operations = ['eth_blockNumber', 'eth_getBalance', 'eth_gasPrice', 'eth_getBlockByNumber'];

    console.log(`📈 ${endpoint.name}:`);

    for (const op of operations) {
      const opResults = results.filter(r =>
        r.endpoint === endpoint.name &&
        r.operation === op &&
        r.success
      );
      if (opResults.length === 0) {
        console.log(`   ${op}: No successful results`);
        continue;
      }

      const latencies = opResults.map(r => r.latencyMs);
      const stats = calcStats(latencies);
      if (!stats) continue;

      summary[endpoint.name][op] = stats;
      console.log(`   ${op}:`);
      console.log(`      Avg: ${stats.avg.toFixed(2)}ms | P50: ${stats.p50.toFixed(2)}ms | P95: ${stats.p95.toFixed(2)}ms`);
    }

    // Calculate overall average
    const allLatencies = results
      .filter(r => r.endpoint === endpoint.name && r.success)
      .map(r => r.latencyMs);
    const overallStats = calcStats(allLatencies);
    if (overallStats) {
      console.log(`   ─────────────────────────────────`);
      console.log(`   Overall Avg: ${overallStats.avg.toFixed(2)}ms`);
    }
    console.log('');
  }

  // Comparison table
  console.log('📊 Comparison (Average Latency):');
  console.log('┌────────────────────┬────────────────┬────────────────┬────────────────┬────────────────┐');
  console.log('│ Endpoint           │ blockNumber    │ getBalance     │ gasPrice       │ getBlock       │');
  console.log('├────────────────────┼────────────────┼────────────────┼────────────────┼────────────────┤');

  for (const endpoint of RPC_ENDPOINTS) {
    const ops = ['eth_blockNumber', 'eth_getBalance', 'eth_gasPrice', 'eth_getBlockByNumber'];
    const values = ops.map(op => {
      const stats = summary[endpoint.name]?.[op];
      return stats ? `${stats.avg.toFixed(0)}ms`.padStart(12) : '         N/A';
    });
    console.log(`│ ${endpoint.name.padEnd(18)} │${values.join(' │')} │`);
  }
  console.log('└────────────────────┴────────────────┴────────────────┴────────────────┴────────────────┘');
  console.log('');

  // Output JSON for comparison
  const jsonResult = {
    timestamp: new Date().toISOString(),
    rounds: ROUNDS,
    endpoints: RPC_ENDPOINTS.map(e => ({
      name: e.name,
      url: e.url.replace(/[a-zA-Z0-9]{20,}/g, '***'), // Hide API keys
      stats: summary[e.name],
    })),
  };

  console.log('📄 JSON Result:');
  console.log(JSON.stringify(jsonResult, null, 2));
}

main().catch(console.error);

================================================================================
// File: scripts/benchmark/run-all.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Run All Benchmarks
 *
 * 运行所有 benchmark 脚本并生成汇总报告
 *
 * Usage:
 *   npx tsx scripts/benchmark/run-all.ts
 *   npx tsx scripts/benchmark/run-all.ts --output ./benchmark-results.json
 */

import { spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { fileURLToPath } from 'url';

// ========================================
// Configuration
// ========================================

const OUTPUT_FILE = process.argv.find(a => a.startsWith('--output='))?.split('=')[1];
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const SCRIPT_DIR = __dirname;

interface BenchmarkResult {
  name: string;
  success: boolean;
  duration: number;
  output?: string;
  error?: string;
}

// ========================================
// Helpers
// ========================================

function runScript(scriptPath: string, args: string[] = []): Promise<BenchmarkResult> {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const name = path.basename(scriptPath, '.ts');

    console.log(`\n${'='.repeat(60)}`);
    console.log(`Running: ${name}`);
    console.log('='.repeat(60));

    const child = spawn('npx', ['tsx', scriptPath, ...args], {
      cwd: path.resolve(SCRIPT_DIR, '../..'),
      stdio: ['inherit', 'pipe', 'pipe'],
    });

    let output = '';
    let errorOutput = '';

    child.stdout?.on('data', (data) => {
      const str = data.toString();
      output += str;
      process.stdout.write(str);
    });

    child.stderr?.on('data', (data) => {
      const str = data.toString();
      errorOutput += str;
      process.stderr.write(str);
    });

    child.on('close', (code) => {
      const duration = Date.now() - startTime;
      resolve({
        name,
        success: code === 0,
        duration,
        output: output || undefined,
        error: errorOutput || undefined,
      });
    });

    child.on('error', (err) => {
      const duration = Date.now() - startTime;
      resolve({
        name,
        success: false,
        duration,
        error: err.message,
      });
    });
  });
}

function extractJsonFromOutput(output: string): object | null {
  // Find JSON block in output
  const jsonMatch = output.match(/\{[\s\S]*"timestamp"[\s\S]*\}/);
  if (jsonMatch) {
    try {
      return JSON.parse(jsonMatch[0]);
    } catch {
      return null;
    }
  }
  return null;
}

interface SystemInfo {
  platform: string;
  arch: string;
  cpus: number;
  cpuModel: string;
  memory: string;
  hostname: string;
  nodeVersion: string;
}

function getSystemInfo(): SystemInfo {
  return {
    platform: os.platform(),
    arch: os.arch(),
    cpus: os.cpus().length,
    cpuModel: os.cpus()[0]?.model || 'Unknown',
    memory: `${Math.round(os.totalmem() / 1024 / 1024 / 1024)}GB`,
    hostname: os.hostname(),
    nodeVersion: process.version,
  };
}

// ========================================
// Main
// ========================================

async function main() {
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║           Polymarket SDK Benchmark Suite                 ║');
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  const systemInfo = getSystemInfo();
  console.log('📋 System Info:');
  console.log(`   Platform:  ${systemInfo.platform} ${systemInfo.arch}`);
  console.log(`   CPU:       ${systemInfo.cpuModel}`);
  console.log(`   Cores:     ${systemInfo.cpus}`);
  console.log(`   Memory:    ${systemInfo.memory}`);
  console.log(`   Node:      ${systemInfo.nodeVersion}`);

  const benchmarks = [
    { script: 'ws-latency.ts', args: ['--duration=15'] },
    { script: 'order-latency.ts', args: ['--rounds=3', '--dry-run'] },
    { script: 'rpc-latency.ts', args: ['--rounds=3'] },
  ];

  const results: BenchmarkResult[] = [];
  const extractedResults: Record<string, object | null> = {};

  const startTime = Date.now();

  for (const benchmark of benchmarks) {
    const scriptPath = path.join(SCRIPT_DIR, benchmark.script);

    if (!fs.existsSync(scriptPath)) {
      console.log(`\n⚠️ Script not found: ${benchmark.script}`);
      results.push({
        name: benchmark.script,
        success: false,
        duration: 0,
        error: 'Script not found',
      });
      continue;
    }

    const result = await runScript(scriptPath, benchmark.args);
    results.push(result);

    if (result.output) {
      extractedResults[result.name] = extractJsonFromOutput(result.output);
    }
  }

  const totalDuration = Date.now() - startTime;

  // Generate summary
  console.log('\n');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('                  BENCHMARK SUMMARY                        ');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('');

  console.log('📊 Results Overview:');
  console.log('┌────────────────────┬──────────┬──────────────┐');
  console.log('│ Benchmark          │ Status   │ Duration     │');
  console.log('├────────────────────┼──────────┼──────────────┤');

  for (const result of results) {
    const status = result.success ? '✅ Pass' : '❌ Fail';
    const duration = `${(result.duration / 1000).toFixed(1)}s`;
    console.log(`│ ${result.name.padEnd(18)} │ ${status.padEnd(8)} │ ${duration.padStart(10)}   │`);
  }

  console.log('├────────────────────┼──────────┼──────────────┤');
  console.log(`│ ${'Total'.padEnd(18)} │ ${results.filter(r => r.success).length}/${results.length} pass │ ${(totalDuration / 1000).toFixed(1)}s`.padEnd(52) + '│');
  console.log('└────────────────────┴──────────┴──────────────┘');
  console.log('');

  // Key metrics summary
  console.log('📈 Key Metrics:');

  // WebSocket metrics
  const wsResult = extractedResults['ws-latency'] as any;
  if (wsResult) {
    console.log(`   WebSocket:`);
    console.log(`      Connection Time: ${wsResult.connection?.timeMs || 'N/A'}ms`);
    console.log(`      Messages/sec:    ${wsResult.messages?.perSecond?.toFixed(2) || 'N/A'}`);
    console.log(`      Interval P50:    ${wsResult.interval?.p50?.toFixed(2) || 'N/A'}ms`);
  }

  // Order metrics
  const orderResult = extractedResults['order-latency'] as any;
  if (orderResult) {
    console.log(`   Order API:`);
    if (orderResult.getOrderbook) {
      console.log(`      Orderbook Avg:   ${orderResult.getOrderbook.avg?.toFixed(2) || 'N/A'}ms`);
    }
    if (orderResult.getBestPrices) {
      console.log(`      Best Prices Avg: ${orderResult.getBestPrices.avg?.toFixed(2) || 'N/A'}ms`);
    }
  }

  // RPC metrics
  const rpcResult = extractedResults['rpc-latency'] as any;
  if (rpcResult?.endpoints) {
    console.log(`   RPC Endpoints:`);
    for (const endpoint of rpcResult.endpoints) {
      if (endpoint.stats?.getBlockNumber) {
        console.log(`      ${endpoint.name}: ${endpoint.stats.getBlockNumber.avg?.toFixed(2) || 'N/A'}ms avg`);
      }
    }
  }

  console.log('');

  // Save results if output file specified
  if (OUTPUT_FILE) {
    const fullReport = {
      timestamp: new Date().toISOString(),
      system: systemInfo,
      totalDuration,
      benchmarks: results.map(r => ({
        name: r.name,
        success: r.success,
        duration: r.duration,
        results: extractedResults[r.name] || null,
      })),
    };

    fs.writeFileSync(OUTPUT_FILE, JSON.stringify(fullReport, null, 2));
    console.log(`📄 Full report saved to: ${OUTPUT_FILE}`);
  }

  // Recommendations
  console.log('💡 Recommendations:');
  console.log('   - Run on target server to compare with local results');
  console.log('   - Use --output flag to save results for comparison');
  console.log('   - Compare RPC endpoints to choose the fastest for your region');
  console.log('');

  // Exit with error if any benchmark failed
  const failedCount = results.filter(r => !r.success).length;
  if (failedCount > 0) {
    console.log(`⚠️ ${failedCount} benchmark(s) failed`);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

================================================================================
// File: scripts/benchmark/ws-latency.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * WebSocket Latency Benchmark
 *
 * 测试从 Polymarket WebSocket 接收 orderbook 更新的延迟
 *
 * 测量指标：
 * - 消息间隔时间 (message interval)
 * - 首次消息延迟 (time to first message)
 * - 消息处理时间 (processing time)
 *
 * Usage:
 *   npx tsx scripts/benchmark/ws-latency.ts
 *   npx tsx scripts/benchmark/ws-latency.ts --duration 60  # 运行60秒
 */

import { PolymarketSDK } from '../../src/index.js';

// ========================================
// Configuration
// ========================================

const DURATION_SECONDS = parseInt(process.argv.find(a => a.startsWith('--duration='))?.split('=')[1] || '30');
const SAMPLE_MARKET = 'btc-updown-15m';  // 使用活跃的 15 分钟市场

interface LatencyStats {
  messageCount: number;
  intervals: number[];
  processingTimes: number[];
  firstMessageTime: number | null;
  connectionTime: number | null;
}

// ========================================
// Main
// ========================================

async function main() {
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║         WebSocket Latency Benchmark                      ║');
  console.log('╠══════════════════════════════════════════════════════════╣');
  console.log(`║  Duration: ${DURATION_SECONDS}s                                           ║`);
  console.log(`║  Market:   ${SAMPLE_MARKET}                              ║`);
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  const sdk = new PolymarketSDK();

  const stats: LatencyStats = {
    messageCount: 0,
    intervals: [],
    processingTimes: [],
    firstMessageTime: null,
    connectionTime: null,
  };

  let lastMessageTime = 0;
  const startTime = Date.now();

  // Find an active market
  console.log('🔍 Finding active market...');
  const markets = await sdk.dipArb.scanUpcomingMarkets({
    coin: 'BTC',
    duration: '15m',
    minMinutesUntilEnd: 5,
    maxMinutesUntilEnd: 30,
    limit: 1,
  });

  if (markets.length === 0) {
    console.log('❌ No active markets found. Try again later.');
    process.exit(1);
  }

  const market = markets[0];
  console.log(`✅ Found: ${market.name}`);
  console.log(`   UP Token: ${market.upTokenId.slice(0, 20)}...`);
  console.log(`   DOWN Token: ${market.downTokenId.slice(0, 20)}...`);
  console.log('');

  // Connect and subscribe
  console.log('📡 Connecting to WebSocket...');
  const connectStart = Date.now();

  const realtimeService = (sdk as any).realtimeService;
  realtimeService.connect();

  await new Promise<void>((resolve) => {
    realtimeService.once('connected', () => {
      stats.connectionTime = Date.now() - connectStart;
      console.log(`✅ Connected in ${stats.connectionTime}ms`);
      resolve();
    });

    setTimeout(() => {
      console.log('⚠️ Connection timeout, proceeding anyway');
      resolve();
    }, 10000);
  });

  // Subscribe to orderbook
  console.log('📊 Subscribing to orderbook...');
  console.log('');
  console.log('Collecting samples...');

  const subscription = realtimeService.subscribeMarkets(
    [market.upTokenId, market.downTokenId],
    {
      onOrderbook: () => {
        const now = Date.now();
        const processStart = performance.now();

        stats.messageCount++;

        if (stats.firstMessageTime === null) {
          stats.firstMessageTime = now - startTime;
          console.log(`   First message received in ${stats.firstMessageTime}ms`);
        }

        if (lastMessageTime > 0) {
          const interval = now - lastMessageTime;
          stats.intervals.push(interval);
        }

        lastMessageTime = now;

        // Simulate some processing
        const processEnd = performance.now();
        stats.processingTimes.push(processEnd - processStart);

        // Progress indicator
        if (stats.messageCount % 100 === 0) {
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          console.log(`   ${stats.messageCount} messages received (${elapsed}s elapsed)`);
        }
      },
      onError: (error: Error) => {
        console.error('WebSocket error:', error.message);
      },
    }
  );

  // Wait for duration
  await new Promise(resolve => setTimeout(resolve, DURATION_SECONDS * 1000));

  // Cleanup
  subscription.unsubscribe();
  sdk.stop();

  // Calculate statistics
  console.log('');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('                      RESULTS                              ');
  console.log('═══════════════════════════════════════════════════════════');
  console.log('');

  const calcStats = (arr: number[]) => {
    if (arr.length === 0) return { min: 0, max: 0, avg: 0, p50: 0, p95: 0, p99: 0 };
    const sorted = [...arr].sort((a, b) => a - b);
    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: arr.reduce((a, b) => a + b, 0) / arr.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  };

  const intervalStats = calcStats(stats.intervals);
  const processingStats = calcStats(stats.processingTimes);

  console.log('📈 Message Statistics:');
  console.log(`   Total messages:     ${stats.messageCount}`);
  console.log(`   Messages per second: ${(stats.messageCount / DURATION_SECONDS).toFixed(2)}`);
  console.log(`   Connection time:    ${stats.connectionTime}ms`);
  console.log(`   First message:      ${stats.firstMessageTime}ms`);
  console.log('');

  console.log('⏱️  Message Interval (ms):');
  console.log(`   Min:    ${intervalStats.min.toFixed(2)}`);
  console.log(`   Max:    ${intervalStats.max.toFixed(2)}`);
  console.log(`   Avg:    ${intervalStats.avg.toFixed(2)}`);
  console.log(`   P50:    ${intervalStats.p50.toFixed(2)}`);
  console.log(`   P95:    ${intervalStats.p95.toFixed(2)}`);
  console.log(`   P99:    ${intervalStats.p99.toFixed(2)}`);
  console.log('');

  console.log('⚡ Processing Time (ms):');
  console.log(`   Min:    ${processingStats.min.toFixed(4)}`);
  console.log(`   Max:    ${processingStats.max.toFixed(4)}`);
  console.log(`   Avg:    ${processingStats.avg.toFixed(4)}`);
  console.log('');

  // Output JSON for comparison
  const result = {
    timestamp: new Date().toISOString(),
    duration: DURATION_SECONDS,
    market: market.slug,
    connection: {
      timeMs: stats.connectionTime,
      firstMessageMs: stats.firstMessageTime,
    },
    messages: {
      total: stats.messageCount,
      perSecond: stats.messageCount / DURATION_SECONDS,
    },
    interval: intervalStats,
    processing: processingStats,
  };

  console.log('📄 JSON Result:');
  console.log(JSON.stringify(result, null, 2));
}

main().catch(console.error);

================================================================================
// File: scripts/deposit/deposit.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Polymarket Deposit Tool
 *
 * Usage:
 *   PRIVATE_KEY=0x... npx tsx scripts/deposit/deposit.ts [command] [amount]
 *
 * Commands:
 *   check              - Check balances and allowances (default)
 *   approve            - Set up all trading approvals
 *   swap <amount>      - Swap Native USDC to USDC.e
 *   deposit <amount>   - Deposit Native USDC to Polymarket
 */

import { OnchainService, depositUsdc } from '../../src/index.js';
import { Wallet, providers } from 'ethers';

const PRIVATE_KEY = process.env.PRIVATE_KEY || process.env.POLY_PRIVKEY || '';

async function main() {
  if (!PRIVATE_KEY) {
    console.log('Usage: PRIVATE_KEY=0x... npx tsx scripts/deposit/deposit.ts [check|approve|swap|deposit] [amount]');
    process.exit(1);
  }

  const [command = 'check', amountStr] = process.argv.slice(2);
  const amount = amountStr ? parseFloat(amountStr) : 0;

  const onchain = new OnchainService({ privateKey: PRIVATE_KEY });
  const provider = new providers.JsonRpcProvider('https://polygon-rpc.com');
  const wallet = new Wallet(PRIVATE_KEY, provider);

  console.log(`\nWallet: ${onchain.getAddress()}\n`);

  switch (command) {
    case 'check': {
      const balances = await onchain.getTokenBalances();
      console.log('Balances:');
      console.log(`  MATIC:       ${balances.matic}`);
      console.log(`  Native USDC: ${balances.usdc}`);
      console.log(`  USDC.e:      ${balances.usdcE}`);

      const allowances = await onchain.checkAllowances();
      console.log(`\nTrading Ready: ${allowances.tradingReady ? '✓' : '✗'}`);
      if (allowances.issues.length > 0) {
        console.log('Issues:', allowances.issues.join(', '));
      }
      break;
    }

    case 'approve': {
      console.log('Setting up trading approvals...');
      const result = await onchain.approveAll();
      console.log(`Done. ${result.summary}`);
      break;
    }

    case 'swap': {
      if (amount <= 0) {
        console.log('Usage: swap <amount>');
        process.exit(1);
      }
      console.log(`Swapping ${amount} USDC → USDC.e...`);
      const result = await onchain.swap('USDC', 'USDC_E', amount.toString());
      console.log(`TX: ${result.transactionHash}`);
      console.log(`Received: ${result.amountOut} USDC.e`);
      break;
    }

    case 'deposit': {
      if (amount < 2) {
        console.log('Minimum deposit: $2');
        process.exit(1);
      }
      console.log(`Depositing ${amount} USDC to Polymarket...`);
      const result = await depositUsdc(wallet, amount, { token: 'NATIVE_USDC' });
      if (result.success) {
        console.log(`TX: ${result.txHash}`);
        console.log('Bridge will process in 1-5 minutes.');
      } else {
        console.log(`Error: ${result.error}`);
      }
      break;
    }

    default:
      console.log('Unknown command. Use: check, approve, swap, deposit');
  }
}

main().catch(console.error);

================================================================================
// File: scripts/dip-arb/auto-trade.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * DipArb Auto Trading - 15m Crypto Markets
 *
 * 策略原理：
 * 1. 检测 10 秒内 5% 以上的瞬时暴跌
 * 2. 买入暴跌侧 (Leg1)
 * 3. 等待对侧价格下降，满足 sumTarget 后买入 (Leg2)
 * 4. 双持仓锁定利润：UP + DOWN = $1
 *
 * 日志：每个市场单独一个日志文件，存放在 /tmp/dip-arb-logs/
 *
 * Run with:
 *   npx tsx scripts/dip-arb/auto-trade.ts --eth
 *   npx tsx scripts/dip-arb/auto-trade.ts --btc
 *   npx tsx scripts/dip-arb/auto-trade.ts --sol
 *   npx tsx scripts/dip-arb/auto-trade.ts --xrp
 */

import * as fs from 'fs';
import * as path from 'path';
import { PolymarketSDK } from '../../src/index.js';

// ========================================
// Parse Command Line Arguments
// ========================================

type CoinType = 'BTC' | 'ETH' | 'SOL' | 'XRP';

interface CliArgs {
  coin: CoinType;
  dipThreshold: number;      // 跌幅阈值 (0.30 = 30%)
  slidingWindowMs: number;   // 滑动窗口 (毫秒)
  leg2TimeoutSeconds: number; // 止损时间 (秒)
  sumTarget: number;         // 总成本目标
  shares: number;            // 每次交易份数
}

function parseArgs(): CliArgs {
  const args = process.argv.slice(2);

  // 解析币种
  let coin: CoinType = 'ETH';
  if (args.includes('--btc') || args.includes('-b')) coin = 'BTC';
  else if (args.includes('--eth') || args.includes('-e')) coin = 'ETH';
  else if (args.includes('--sol') || args.includes('-s')) coin = 'SOL';
  else if (args.includes('--xrp') || args.includes('-x')) coin = 'XRP';

  // 解析数值参数
  const getArgValue = (name: string, defaultVal: number): number => {
    const arg = args.find(a => a.startsWith(`--${name}=`));
    if (arg) {
      const val = parseFloat(arg.split('=')[1]);
      return isNaN(val) ? defaultVal : val;
    }
    return defaultVal;
  };

  // 币种默认参数
  const coinDefaults: Record<CoinType, Partial<CliArgs>> = {
    XRP: { dipThreshold: 0.40, slidingWindowMs: 3000, leg2TimeoutSeconds: 60, sumTarget: 0.85 },
    SOL: { dipThreshold: 0.40, slidingWindowMs: 3000, leg2TimeoutSeconds: 60, sumTarget: 0.85 },
    ETH: { dipThreshold: 0.30, slidingWindowMs: 5000, leg2TimeoutSeconds: 60, sumTarget: 0.93 },
    BTC: { dipThreshold: 0.20, slidingWindowMs: 5000, leg2TimeoutSeconds: 60, sumTarget: 0.95 },
  };

  const defaults = coinDefaults[coin];

  return {
    coin,
    dipThreshold: getArgValue('dip', defaults.dipThreshold!),
    slidingWindowMs: getArgValue('window', defaults.slidingWindowMs!),
    leg2TimeoutSeconds: getArgValue('timeout', defaults.leg2TimeoutSeconds!),
    sumTarget: getArgValue('target', defaults.sumTarget!),
    shares: getArgValue('shares', 25),
  };
}

const CLI_ARGS = parseArgs();
const SELECTED_COIN = CLI_ARGS.coin;

// Config
const PRIVATE_KEY = process.env.PRIVATE_KEY || '';
const MONITOR_DURATION_MS = 60 * 60 * 1000; // 1 hour
const LOG_DIR = '/tmp/dip-arb-logs';

if (!PRIVATE_KEY) {
  console.error('Error: PRIVATE_KEY environment variable is required');
  process.exit(1);
}

// Ensure log directory exists
if (!fs.existsSync(LOG_DIR)) {
  fs.mkdirSync(LOG_DIR, { recursive: true });
}

// ========================================
// Per-Market Logging
// ========================================

let currentMarketSlug: string | null = null;
let currentLogs: string[] = [];
let currentLogPath: string | null = null;

function getLogFilename(marketSlug: string): string {
  const date = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
  const time = new Date().toISOString().slice(11, 19).replace(/:/g, ''); // HHMMSS
  return path.join(LOG_DIR, `${date}_${time}_${marketSlug}.log`);
}

function log(msg: string) {
  const timestamp = new Date().toISOString().slice(11, 19);
  const line = `[${timestamp}] ${msg}`;
  console.log(line);
  currentLogs.push(line);
}

function sdkLogHandler(message: string) {
  const timestamp = new Date().toISOString().slice(11, 19);
  const line = `[${timestamp}] ${message}`;
  console.log(line);
  currentLogs.push(line);
}

function saveCurrentLog(suffix?: string) {
  if (currentLogs.length === 0) return;

  const logPath = currentLogPath || path.join(LOG_DIR, `unknown_${Date.now()}.log`);
  const finalPath = suffix ? logPath.replace('.log', `_${suffix}.log`) : logPath;

  fs.writeFileSync(finalPath, currentLogs.join('\n'));
  console.log(`📁 Log saved: ${finalPath} (${currentLogs.length} lines)`);
}

function startNewMarketLog(marketSlug: string) {
  // Save previous market log if exists
  if (currentLogs.length > 0 && currentMarketSlug) {
    saveCurrentLog();
  }

  // Start new log
  currentMarketSlug = marketSlug;
  currentLogs = [];
  currentLogPath = getLogFilename(marketSlug);

  log(`📝 New log file: ${currentLogPath}`);
}

// ========================================
// Main
// ========================================

async function main() {
  // ========================================
  // Configuration
  // ========================================
  const config = {
    // 交易参数 (支持命令行覆盖)
    shares: CLI_ARGS.shares,           // --shares=25
    sumTarget: CLI_ARGS.sumTarget,     // --target=0.95

    // 订单拆分参数
    splitOrders: 1,          // 单笔下单，避免份额不匹配
    orderIntervalMs: 500,    // 订单间隔 500ms (仅在 splitOrders > 1 时使用)

    // 信号检测参数 (支持命令行覆盖)
    slidingWindowMs: CLI_ARGS.slidingWindowMs,  // --window=10000 (毫秒)
    dipThreshold: CLI_ARGS.dipThreshold,        // --dip=0.30 (30%)
    windowMinutes: 14,       // 轮次开始后 14 分钟内可交易

    // 执行参数
    maxSlippage: 0.02,       // 2% 滑点
    autoExecute: true,       // 自动执行
    executionCooldown: 500,  // 冷却时间 500ms

    // 其他
    enableSurge: false,      // 禁用暴涨检测
    autoMerge: true,         // 自动 merge
    leg2TimeoutSeconds: CLI_ARGS.leg2TimeoutSeconds,  // --timeout=60 (秒)

    debug: true,             // 调试日志

    // 日志处理器 - 将 SDK 日志也写入当前 market 的 logs 数组
    logHandler: sdkLogHandler,
  };

  // 计算预期利润率
  const expectedProfit = ((1 - config.sumTarget) / config.sumTarget * 100).toFixed(1);

  // Start initial log
  startNewMarketLog('init');

  log('');
  log('╔══════════════════════════════════════════════════════════╗');
  log(`║           DipArb Auto Trading - ${SELECTED_COIN} Markets              ║`);
  log('╠══════════════════════════════════════════════════════════╣');
  log(`║  Dip Threshold:   ${(config.dipThreshold * 100).toFixed(0)}% in ${config.slidingWindowMs / 1000}s window                    ║`);
  log(`║  Sum Target:      ${config.sumTarget} (profit >= ${expectedProfit}%)                   ║`);
  log(`║  Stop Loss:       ${config.leg2TimeoutSeconds}s after Leg1                             ║`);
  log(`║  Shares/Trade:    ${config.shares}                                          ║`);
  log(`║  Order Type:      Market Order (Leg1 + Leg2 + Exit)              ║`);
  log(`║  Log Directory:   ${LOG_DIR}`);
  log('╚══════════════════════════════════════════════════════════╝');
  log('');
  log('Usage: npx tsx auto-trade.ts --xrp [--dip=0.40] [--window=3000] [--timeout=60] [--shares=25] [--target=0.95]');
  log('');

  // Initialize SDK
  log('Initializing SDK...');
  const sdk = new PolymarketSDK({
    privateKey: PRIVATE_KEY,
  });

  sdk.dipArb.updateConfig(config);

  // ========================================
  // Event Listeners
  // ========================================

  sdk.dipArb.on('started', (market) => {
    // Start new log for this market
    startNewMarketLog(market.slug || market.conditionId.slice(0, 20));

    log('');
    log('┌──────────────────────────────────────────────────────────┐');
    log('│                    MARKET STARTED                        │');
    log('├──────────────────────────────────────────────────────────┤');
    log(`│ ${market.name.slice(0, 56)}`);
    log(`│ ${market.underlying} ${market.durationMinutes}m`);
    log(`│ End Time: ${market.endTime.toISOString()}`);
    log(`│ Condition: ${market.conditionId.slice(0, 30)}...`);
    log('└──────────────────────────────────────────────────────────┘');
  });

  sdk.dipArb.on('stopped', () => {
    log('>>> SERVICE STOPPED');
  });

  sdk.dipArb.on('newRound', (event) => {
    const sum = event.upOpen + event.downOpen;
    log(`>>> NEW ROUND | UP: ${event.upOpen.toFixed(3)} | DOWN: ${event.downOpen.toFixed(3)} | Sum: ${sum.toFixed(3)}`);
  });

  sdk.dipArb.on('signal', (signal) => {
    log('');
    log('╔══════════════════════════════════════════════════════════╗');
    if (signal.type === 'leg1') {
      log(`║  LEG1 SIGNAL: Buy ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)}`);
      log(`║  Drop: ${(signal.dropPercent * 100).toFixed(1)}% | Opposite: ${signal.oppositeAsk.toFixed(4)}`);
    } else {
      log(`║  LEG2 SIGNAL: Buy ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
      log(`║  Total Cost: ${signal.totalCost.toFixed(4)} | Profit: ${(signal.expectedProfitRate * 100).toFixed(2)}%`);
    }
    log('╚══════════════════════════════════════════════════════════╝');
  });

  sdk.dipArb.on('execution', (result) => {
    if (result.success) {
      log(`✅ ${result.leg.toUpperCase()} FILLED: ${result.side} @ ${result.price?.toFixed(4)} x${result.shares}`);
    } else {
      log(`❌ ${result.leg.toUpperCase()} FAILED: ${result.error}`);
    }
  });

  sdk.dipArb.on('roundComplete', (result) => {
    log('');
    log('┌──────────────────────────────────────────────────────────┐');
    log(`│  ROUND ${result.status.toUpperCase()}`);
    if (result.profit !== undefined) {
      log(`│  Profit: $${result.profit.toFixed(4)} (${(result.profitRate! * 100).toFixed(2)}%)`);
    }
    log('└──────────────────────────────────────────────────────────┘');
  });

  sdk.dipArb.on('rotate', (event) => {
    // Save current market log before rotation
    log('');
    log('╔══════════════════════════════════════════════════════════╗');
    log(`║  🔄 MARKET ROTATION                                      ║`);
    log(`║  Reason: ${event.reason}`);
    log(`║  Previous: ${event.previousMarket?.slice(0, 40) || 'none'}...`);
    log(`║  New: ${event.newMarket.slice(0, 40)}...`);
    log('╚══════════════════════════════════════════════════════════╝');

    // Save old log and start new one
    // Note: 'started' event will be triggered after rotate, which will start new log
  });

  sdk.dipArb.on('settled', (result) => {
    log(`>>> SETTLED: ${result.strategy} | Success: ${result.success}`);
    if (result.amountReceived) {
      log(`    Amount: $${result.amountReceived.toFixed(2)}`);
    }
    if (result.error) {
      log(`    Error: ${result.error}`);
    }
  });

  sdk.dipArb.on('error', (error) => {
    log(`[ERROR] ${error.message}`);
  });

  // ========================================
  // Scan and Start
  // ========================================

  log(`Scanning for ${SELECTED_COIN} 15m markets...`);
  const markets = await sdk.dipArb.scanUpcomingMarkets({
    coin: SELECTED_COIN,
    duration: '15m',
    limit: 5,
  });

  log(`Found ${markets.length} markets:`);
  for (const m of markets) {
    const endIn = Math.round((m.endTime.getTime() - Date.now()) / 60000);
    const status = endIn <= 0 ? '(ENDED)' : `(ends in ${endIn}m)`;
    log(`  - ${m.name.slice(0, 50)} ${status}`);
    log(`    Condition: ${m.conditionId.slice(0, 30)}...`);
    log(`    End: ${m.endTime.toISOString()}`);
  }

  if (markets.length === 0) {
    log('No markets found. Exiting.');
    saveCurrentLog('no-markets');
    return;
  }

  // Filter out already ended markets
  const activeMarkets = markets.filter(m => m.endTime.getTime() > Date.now());
  if (activeMarkets.length === 0) {
    log('All markets have ended. Waiting for new markets...');
  } else {
    log(`Active markets: ${activeMarkets.length}`);
  }

  // Start
  const market = await sdk.dipArb.findAndStart({
    coin: SELECTED_COIN,
    preferDuration: '15m',
  });

  if (!market) {
    log('Failed to start. Exiting.');
    saveCurrentLog('failed');
    return;
  }

  log(`Selected market ends at: ${market.endTime.toISOString()}`);
  const timeUntilEnd = Math.round((market.endTime.getTime() - Date.now()) / 1000);
  log(`Time until market end: ${timeUntilEnd}s (${Math.round(timeUntilEnd / 60)}m)`);

  // Enable auto-rotate with redeem strategy
  sdk.dipArb.enableAutoRotate({
    enabled: true,
    underlyings: [SELECTED_COIN],
    duration: '15m',
    settleStrategy: 'redeem',  // 等待市场结算后赎回 (5分钟后)
    autoSettle: true,
    preloadMinutes: 2,
    redeemWaitMinutes: 5,       // 市场结束后等待 5 分钟再赎回
    redeemRetryIntervalSeconds: 30,  // 每 30 秒检查一次
  });
  log(`Auto-rotate enabled for ${SELECTED_COIN} (with background redemption)`);

  log('');
  log('═══════════════════════════════════════════════════════════');
  log('  AUTO TRADING ACTIVE - Press Ctrl+C to stop');
  log('═══════════════════════════════════════════════════════════');
  log('');

  // Status update every 30 seconds (more frequent to catch rotation)
  let statusCount = 0;
  const statusInterval = setInterval(() => {
    const stats = sdk.dipArb.getStats();
    const round = sdk.dipArb.getCurrentRound();
    const currentMarket = sdk.dipArb.getMarket();
    statusCount++;

    // Check if market has ended
    if (currentMarket) {
      const timeLeft = Math.round((currentMarket.endTime.getTime() - Date.now()) / 1000);
      const timeLeftStr = timeLeft > 0 ? `${timeLeft}s left` : `ENDED ${-timeLeft}s ago`;
      log(`[Status #${statusCount}] Market: ${currentMarket.underlying} | ${timeLeftStr} | Signals: ${stats.signalsDetected} | L1: ${stats.leg1Filled} | L2: ${stats.leg2Filled}`);
    } else {
      log(`[Status #${statusCount}] No market active | Signals: ${stats.signalsDetected}`);
    }

    // Show current position
    if (round) {
      if (round.phase === 'leg1_filled' && round.leg1) {
        log(`  📊 Position: ${round.leg1.shares}x ${round.leg1.side} @ ${round.leg1.price.toFixed(4)} | Waiting for Leg2...`);
      } else if (round.phase === 'completed' && round.leg1 && round.leg2) {
        const totalCost = round.leg1.price + round.leg2.price;
        const profit = (1 - totalCost) * round.leg1.shares;
        log(`  📊 Position: ${round.leg1.shares}x UP + ${round.leg2.shares}x DOWN | Cost: ${totalCost.toFixed(4)} | Profit: $${profit.toFixed(2)}`);
      } else if (round.phase === 'waiting') {
        log(`  📊 Position: None (waiting for signal)`);
      }
    }
  }, 30000);

  // Wait
  await new Promise(resolve => setTimeout(resolve, MONITOR_DURATION_MS));

  // Cleanup
  clearInterval(statusInterval);

  // Final stats
  const stats = sdk.dipArb.getStats();
  log('');
  log('╔══════════════════════════════════════════════════════════╗');
  log('║                     FINAL STATS                          ║');
  log('╠══════════════════════════════════════════════════════════╣');
  log(`║ Running Time:     ${Math.round(stats.runningTimeMs / 1000)}s`);
  log(`║ Rounds Monitored: ${stats.roundsMonitored}`);
  log(`║ Signals Detected: ${stats.signalsDetected}`);
  log(`║ Leg1 Filled:      ${stats.leg1Filled}`);
  log(`║ Leg2 Filled:      ${stats.leg2Filled}`);
  log(`║ Total Profit:     $${stats.totalProfit.toFixed(2)}`);
  log('╚══════════════════════════════════════════════════════════╝');

  await sdk.dipArb.stop();
  sdk.stop();

  // Save final log
  saveCurrentLog('final');
}

// Handle Ctrl+C
process.on('SIGINT', async () => {
  log('');
  log('Interrupted. Saving logs...');
  saveCurrentLog('interrupted');
  process.exit(0);
});

main().catch((err) => {
  log(`Fatal error: ${err.message}`);
  console.error(err);
  saveCurrentLog('error');
  process.exit(1);
});

================================================================================
// File: scripts/dip-arb/example-basic.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Example 14: DipArbService - Dip Arbitrage for 15m/5m UP/DOWN Markets
 *
 * Demonstrates the dip arbitrage workflow for Polymarket's short-term crypto markets:
 * 1. Scan for upcoming BTC/ETH/SOL/XRP UP/DOWN markets
 * 2. Auto-select and start monitoring a market
 * 3. Detect dip signals (price drops > threshold)
 * 4. Execute Leg1 + Leg2 trades for risk-free profit
 * 5. Auto-rotate to next market when current ends
 *
 * Strategy Overview:
 * - Leg1: Buy the dipped side when price drops >= dipThreshold (default 15%)
 * - Leg2: Buy the opposite side when combined cost < sumTarget (default 0.95)
 * - Profit: Total cost < $1 means guaranteed profit at settlement
 *
 * Environment variables:
 *   POLY_PRIVKEY - Private key for trading (required for execution)
 *
 * Run with:
 *   pnpm example:dip-arb
 *
 * Or monitor-only (no trading):
 *   npx tsx examples/14-dip-arb-service.ts --monitor-only
 *
 * With auto-rotate:
 *   npx tsx examples/14-dip-arb-service.ts --auto-rotate
 */

import { PolymarketSDK } from '../../src/index.js';

// Parse arguments
const args = process.argv.slice(2);
const MONITOR_ONLY = args.includes('--monitor-only');
const AUTO_ROTATE = args.includes('--auto-rotate');
const COIN = args.find(a => a.startsWith('--coin='))?.split('=')[1] as 'BTC' | 'ETH' | 'SOL' | 'XRP' | undefined;
const RUN_DURATION = parseInt(args.find(a => a.startsWith('--duration='))?.split('=')[1] || '300') * 1000; // default 5 minutes

async function main() {
  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║              DipArbService - Dip Arbitrage Demo                ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log();

  const privateKey = process.env.POLY_PRIVKEY;

  if (!privateKey && !MONITOR_ONLY) {
    console.log('No POLY_PRIVKEY provided. Running in monitor-only mode.\n');
  }

  // ========== Initialize SDK ==========
  console.log('Initializing SDK...');
  const sdk = await PolymarketSDK.create({
    privateKey: MONITOR_ONLY ? undefined : privateKey,
  });
  console.log('SDK initialized\n');

  // ========== Configure DipArbService ==========
  sdk.dipArb.updateConfig({
    shares: 20,              // Buy 20 shares per leg
    sumTarget: 0.95,         // Target total cost <= $0.95 (5% profit)
    dipThreshold: 0.15,      // Trigger when price drops 15%
    windowMinutes: 2,        // Trade window after round starts
    maxSlippage: 0.02,       // Max 2% slippage
    minProfitRate: 0.03,     // Min 3% profit rate
    leg2TimeoutSeconds: 300, // 5 min timeout for leg2
    enableSurge: true,       // Also detect surges
    autoMerge: true,         // Auto merge after both legs
    autoExecute: !MONITOR_ONLY && !!privateKey,
    debug: true,
  });

  console.log('Configuration:');
  console.log(JSON.stringify(sdk.dipArb.getConfig(), null, 2));
  console.log();

  // ========== Set up event listeners ==========
  sdk.dipArb.on('started', (market) => {
    console.log('\n═══════════════════════════════════════════════════════════════');
    console.log(`🚀 Started monitoring: ${market.name}`);
    console.log(`   Condition ID: ${market.conditionId.slice(0, 20)}...`);
    console.log(`   Underlying: ${market.underlying} | Duration: ${market.durationMinutes}m`);
    console.log(`   End Time: ${market.endTime.toLocaleString()}`);
    console.log('═══════════════════════════════════════════════════════════════\n');
  });

  sdk.dipArb.on('stopped', () => {
    console.log('\n🛑 Service stopped');
  });

  sdk.dipArb.on('newRound', (event) => {
    console.log(`\n📍 New Round: ${event.roundId}`);
    console.log(`   Price to Beat: $${event.priceToBeat.toFixed(2)}`);
    console.log(`   UP Open: ${event.upOpen.toFixed(4)} | DOWN Open: ${event.downOpen.toFixed(4)}`);
  });

  sdk.dipArb.on('signal', (signal) => {
    if (signal.type === 'leg1') {
      console.log(`\n🎯 LEG1 SIGNAL [${signal.source.toUpperCase()}]`);
      console.log(`   Buy ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)}`);
      console.log(`   Drop: ${(signal.dropPercent * 100).toFixed(1)}%`);
      console.log(`   Opposite Ask: ${signal.oppositeAsk.toFixed(4)}`);
      console.log(`   Est Total Cost: ${signal.estimatedTotalCost.toFixed(4)}`);
      console.log(`   Est Profit Rate: ${(signal.estimatedProfitRate * 100).toFixed(2)}%`);
      if (signal.btcInfo) {
        console.log(`   ${signal.btcInfo.btcPrice > 0 ? 'BTC' : 'Underlying'}: $${signal.btcInfo.btcPrice.toFixed(2)} (${signal.btcInfo.btcChangePercent >= 0 ? '+' : ''}${signal.btcInfo.btcChangePercent.toFixed(2)}%)`);
      }
    } else {
      console.log(`\n🎯 LEG2 SIGNAL`);
      console.log(`   Buy ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
      console.log(`   Leg1 was: ${signal.leg1.side} @ ${signal.leg1.price.toFixed(4)}`);
      console.log(`   Total Cost: ${signal.totalCost.toFixed(4)}`);
      console.log(`   Expected Profit Rate: ${(signal.expectedProfitRate * 100).toFixed(2)}%`);
    }
  });

  sdk.dipArb.on('execution', (result) => {
    if (result.success) {
      console.log(`\n✅ ${result.leg.toUpperCase()} Executed!`);
      if (result.side) console.log(`   Side: ${result.side}`);
      if (result.price) console.log(`   Price: ${result.price.toFixed(4)}`);
      if (result.shares) console.log(`   Shares: ${result.shares}`);
      if (result.orderId) console.log(`   Order ID: ${result.orderId}`);
      console.log(`   Time: ${result.executionTimeMs}ms`);
    } else {
      console.log(`\n❌ ${result.leg.toUpperCase()} Failed: ${result.error}`);
    }
  });

  sdk.dipArb.on('roundComplete', (result) => {
    console.log(`\n📊 Round ${result.roundId} Complete`);
    console.log(`   Status: ${result.status}`);
    if (result.totalCost !== undefined) {
      console.log(`   Total Cost: ${result.totalCost.toFixed(4)}`);
      console.log(`   Profit: $${result.profit?.toFixed(4)}`);
      console.log(`   Profit Rate: ${((result.profitRate || 0) * 100).toFixed(2)}%`);
    }
    console.log(`   Merged: ${result.merged ? 'Yes' : 'No'}`);
  });

  sdk.dipArb.on('priceUpdate', (event) => {
    // Only log significant price changes
    if (Math.abs(event.changePercent) >= 0.5) {
      console.log(`   ${event.underlying}: $${event.value.toFixed(2)} (${event.changePercent >= 0 ? '+' : ''}${event.changePercent.toFixed(2)}% vs PTB)`);
    }
  });

  sdk.dipArb.on('rotate', (event) => {
    console.log(`\n🔄 Market Rotation`);
    console.log(`   Reason: ${event.reason}`);
    console.log(`   Previous: ${event.previousMarket?.slice(0, 20) || 'none'}...`);
    console.log(`   New: ${event.newMarket.slice(0, 20)}...`);
  });

  sdk.dipArb.on('settled', (result) => {
    console.log(`\n💰 Position Settled`);
    console.log(`   Strategy: ${result.strategy}`);
    console.log(`   Success: ${result.success}`);
    if (result.amountReceived) {
      console.log(`   Amount: $${result.amountReceived.toFixed(2)}`);
    }
  });

  sdk.dipArb.on('error', (error) => {
    console.error(`\n❌ Error: ${error.message}`);
  });

  // ========== Enable auto-rotate if requested ==========
  if (AUTO_ROTATE) {
    sdk.dipArb.enableAutoRotate({
      underlyings: COIN ? [COIN] : ['BTC', 'ETH'],
      duration: '15m',
      autoSettle: true,
      settleStrategy: 'sell', // 'sell' is faster, 'redeem' waits for resolution
      preloadMinutes: 2,
    });
    console.log('Auto-rotate enabled\n');
  }

  // ========== Scan for markets ==========
  console.log('Scanning for upcoming markets...\n');
  const markets = await sdk.dipArb.scanUpcomingMarkets({
    coin: COIN || 'all',
    duration: '15m',
    minMinutesUntilEnd: 10,
    maxMinutesUntilEnd: 60,
    limit: 10,
  });

  if (markets.length === 0) {
    console.log('No suitable markets found. Try again later.\n');
    sdk.stop();
    return;
  }

  console.log(`Found ${markets.length} markets:\n`);
  markets.forEach((m, i) => {
    const minutesLeft = Math.round((m.endTime.getTime() - Date.now()) / 60000);
    console.log(`  ${i + 1}. [${m.underlying}] ${m.slug}`);
    console.log(`     Ends in ${minutesLeft} minutes`);
  });
  console.log();

  // ========== Start monitoring ==========
  const market = await sdk.dipArb.findAndStart({
    coin: COIN,
    preferDuration: '15m',
  });

  if (!market) {
    console.log('Could not start monitoring. Exiting.\n');
    sdk.stop();
    return;
  }

  // ========== Run for specified duration ==========
  console.log(`Running for ${RUN_DURATION / 1000} seconds...`);
  console.log('Press Ctrl+C to stop early.\n');

  await new Promise(resolve => setTimeout(resolve, RUN_DURATION));

  // ========== Print final stats ==========
  const stats = sdk.dipArb.getStats();
  console.log('\n═══════════════════════════════════════════════════════════════');
  console.log('📊 Final Statistics');
  console.log('═══════════════════════════════════════════════════════════════');
  console.log(`Rounds Monitored: ${stats.roundsMonitored}`);
  console.log(`Rounds Completed: ${stats.roundsCompleted}`);
  console.log(`Rounds Successful: ${stats.roundsSuccessful}`);
  console.log(`Rounds Expired: ${stats.roundsExpired}`);
  console.log(`Signals Detected: ${stats.signalsDetected}`);
  console.log(`Leg1 Filled: ${stats.leg1Filled}`);
  console.log(`Leg2 Filled: ${stats.leg2Filled}`);
  console.log(`Total Spent: $${stats.totalSpent.toFixed(2)}`);
  console.log(`Total Profit: $${stats.totalProfit.toFixed(2)}`);
  console.log(`Running Time: ${(stats.runningTimeMs / 1000).toFixed(1)}s`);
  console.log();

  // ========== Clean up ==========
  sdk.stop();
  console.log('Done!\n');
}

main().catch(console.error);

================================================================================
// File: scripts/dip-arb/redeem-positions.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Redeem Positions Script
 *
 * 赎回已结束市场的持仓
 *
 * Run with:
 *   npx tsx scripts/dip-arb/redeem-positions.ts
 */

import { PolymarketSDK, CTFClient } from '../../src/index.js';

const PRIVATE_KEY = process.env.PRIVATE_KEY;

// Normalize outcome names: Up/Yes = YES, Down/No = NO
function normalizeOutcome(outcome: string): 'YES' | 'NO' {
  const lower = outcome.toLowerCase();
  if (lower === 'up' || lower === 'yes') return 'YES';
  if (lower === 'down' || lower === 'no') return 'NO';
  return 'YES'; // default
}

// Check if user's position is winning
function isWinningPosition(userOutcome: string, payouts: number[]): boolean {
  const normalized = normalizeOutcome(userOutcome);
  // payouts[0] = YES/Up payout, payouts[1] = NO/Down payout
  if (normalized === 'YES') {
    return payouts[0] > 0;
  } else {
    return payouts[1] > 0;
  }
}

async function main() {
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║           Redeem Positions - Ended Markets               ║');
  console.log('╚══════════════════════════════════════════════════════════╝');
  console.log('');

  if (!PRIVATE_KEY) {
    console.error('Error: PRIVATE_KEY environment variable is required');
    process.exit(1);
  }

  // Initialize SDK
  console.log('Initializing SDK...');
  const sdk = new PolymarketSDK({
    privateKey: PRIVATE_KEY,
  });

  // Initialize CTF Client for redemption
  const ctf = new CTFClient({
    privateKey: PRIVATE_KEY,
    rpcUrl: 'https://polygon-rpc.com',
    chainId: 137,
  });

  // Initialize SDK
  await sdk.initialize();

  // Get wallet address
  const address = sdk.tradingService.getAddress();
  console.log(`Wallet: ${address}`);
  console.log('');

  // Get all positions (filter for redeemable ones)
  console.log('Fetching positions...');
  const allPositions = await sdk.dataApi.getPositions(address);
  console.log(`Found ${allPositions.length} total positions`);

  // Also get explicitly redeemable positions
  console.log('Checking for redeemable positions...');
  const redeemablePositions = await sdk.dataApi.getPositions(address, { redeemable: true });
  console.log(`Found ${redeemablePositions.length} resolved positions`);
  console.log('');

  // Use redeemable positions if available, otherwise check all
  const positions = redeemablePositions.length > 0 ? redeemablePositions : allPositions;

  // Group positions by condition ID to find both sides
  const positionsByCondition = new Map<string, typeof positions>();
  for (const pos of positions) {
    const existing = positionsByCondition.get(pos.conditionId) || [];
    existing.push(pos);
    positionsByCondition.set(pos.conditionId, existing);
  }

  // Check each position for redemption
  let resolved = 0;
  let winning = 0;
  let redeemed = 0;
  let lost = 0;
  let failed = 0;

  // Track processed condition IDs to avoid duplicate redemption attempts
  const processedConditions = new Set<string>();

  for (const position of positions) {
    const conditionId = position.conditionId;

    // Skip if already processed this condition
    if (processedConditions.has(conditionId)) {
      continue;
    }
    processedConditions.add(conditionId);

    const title = position.title || position.slug || conditionId.slice(0, 20);
    const outcome = position.outcome || 'Unknown';
    const size = position.size || 0;
    const tokenId = position.asset; // This is the Polymarket token ID

    // Skip if no position
    if (size <= 0) {
      continue;
    }

    console.log(`┌─────────────────────────────────────────────────────────┐`);
    console.log(`│ ${title.slice(0, 55)}`);
    console.log(`│ Condition: ${conditionId.slice(0, 40)}...`);
    console.log(`│ Your bet: ${outcome} | Size: ${size.toFixed(4)}`);

    try {
      // Check if market is resolved
      const resolution = await ctf.getMarketResolution(conditionId);

      if (!resolution.isResolved) {
        console.log(`│ Status: NOT RESOLVED (cannot redeem yet)`);
        console.log(`└─────────────────────────────────────────────────────────┘`);
        console.log('');
        continue;
      }

      resolved++;
      const payouts = resolution.payoutNumerators || [];
      const winningOutcome = payouts[0] > 0 ? 'Up/Yes' : 'Down/No';
      console.log(`│ Winner: ${winningOutcome} (payouts: ${JSON.stringify(payouts)})`);

      // Check if user won
      if (!isWinningPosition(outcome, payouts)) {
        lost++;
        console.log(`│ ❌ YOU LOST - Your ${outcome} tokens are worth $0`);
        console.log(`└─────────────────────────────────────────────────────────┘`);
        console.log('');
        continue;
      }

      winning++;
      console.log(`│ ✅ YOU WON! Attempting redemption...`);

      // Get all positions for this condition to find token IDs
      const conditionPositions = positionsByCondition.get(conditionId) || [];

      // Find YES and NO token IDs
      let yesTokenId: string | undefined;
      let noTokenId: string | undefined;

      for (const p of conditionPositions) {
        const normalized = normalizeOutcome(p.outcome);
        if (normalized === 'YES') {
          yesTokenId = p.asset;
        } else {
          noTokenId = p.asset;
        }
      }

      // If we don't have both token IDs, try to get from market info
      if (!yesTokenId || !noTokenId) {
        console.log(`│ Getting market token IDs...`);
        try {
          const market = await sdk.markets.getMarket(conditionId);
          if (market && market.tokens && market.tokens.length >= 2) {
            yesTokenId = yesTokenId || market.tokens[0]?.tokenId;
            noTokenId = noTokenId || market.tokens[1]?.tokenId;
          }
        } catch {
          console.log(`│ Could not get market info, using position token ID only`);
        }
      }

      // Try to redeem
      console.log(`│ Token: ${tokenId.slice(0, 30)}...`);

      const tokenIds = {
        yesTokenId: yesTokenId || tokenId,
        noTokenId: noTokenId || tokenId,
      };

      const result = await ctf.redeemByTokenIds(conditionId, tokenIds);

      if (result.success) {
        redeemed++;
        console.log(`│ ✅ REDEEMED!`);
        console.log(`│ TX: ${result.txHash}`);
        console.log(`│ Amount: $${result.usdcReceived}`);
      } else {
        failed++;
        console.log(`│ ❌ FAILED`);
      }
    } catch (error) {
      failed++;
      const msg = error instanceof Error ? error.message : String(error);
      console.log(`│ ❌ ERROR: ${msg}`);
    }

    console.log(`└─────────────────────────────────────────────────────────┘`);
    console.log('');

    // Small delay between redemptions
    await new Promise(r => setTimeout(r, 1000));
  }

  // Summary
  console.log('');
  console.log('╔══════════════════════════════════════════════════════════╗');
  console.log('║                       SUMMARY                            ║');
  console.log('╠══════════════════════════════════════════════════════════╣');
  console.log(`║ Markets Checked:    ${processedConditions.size}`);
  console.log(`║ Resolved:           ${resolved}`);
  console.log(`║ Won:                ${winning}`);
  console.log(`║ Lost:               ${lost}`);
  console.log(`║ Redeemed:           ${redeemed}`);
  console.log(`║ Failed:             ${failed}`);
  console.log('╚══════════════════════════════════════════════════════════╝');

  sdk.stop();
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});

================================================================================
// File: scripts/dip-arb/scan-markets.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Test: DipArbService - Scan for ETH 15m markets
 */

import { PolymarketSDK } from '../../src/index.js';

async function main() {
  console.log('=== Testing DipArbService Market Scan ===\n');

  // Initialize SDK (no private key needed for scanning)
  console.log('Initializing SDK...');
  const sdk = new PolymarketSDK();
  console.log('SDK initialized\n');

  // Test 1: Scan for ETH 15m markets
  console.log('--- Test 1: Scan for ETH 15m markets ---');
  const ethMarkets = await sdk.dipArb.scanUpcomingMarkets({
    coin: 'ETH',
    duration: '15m',
    minMinutesUntilEnd: 5,
    maxMinutesUntilEnd: 60,
    limit: 5,
  });

  console.log(`Found ${ethMarkets.length} ETH 15m markets:\n`);

  if (ethMarkets.length === 0) {
    console.log('No ETH 15m markets found. This could be normal if no markets are active.\n');
  } else {
    ethMarkets.forEach((m, i) => {
      const minutesLeft = Math.round((m.endTime.getTime() - Date.now()) / 60000);
      console.log(`${i + 1}. ${m.name}`);
      console.log(`   Slug: ${m.slug}`);
      console.log(`   Condition ID: ${m.conditionId}`);
      console.log(`   UP Token: ${m.upTokenId}`);
      console.log(`   DOWN Token: ${m.downTokenId}`);
      console.log(`   Underlying: ${m.underlying}`);
      console.log(`   Duration: ${m.durationMinutes}m`);
      console.log(`   Ends in: ${minutesLeft} minutes`);
      console.log(`   End Time: ${m.endTime.toLocaleString()}`);
      console.log();
    });
  }

  // Test 2: Scan for all coin types
  console.log('--- Test 2: Scan for all coin 15m markets ---');
  const allMarkets = await sdk.dipArb.scanUpcomingMarkets({
    coin: 'all',
    duration: '15m',
    minMinutesUntilEnd: 5,
    maxMinutesUntilEnd: 60,
    limit: 10,
  });

  console.log(`Found ${allMarkets.length} total 15m markets:\n`);

  const byUnderlying: Record<string, number> = {};
  allMarkets.forEach(m => {
    byUnderlying[m.underlying] = (byUnderlying[m.underlying] || 0) + 1;
  });

  console.log('By underlying:');
  Object.entries(byUnderlying).forEach(([coin, count]) => {
    console.log(`  ${coin}: ${count} markets`);
  });
  console.log();

  // Test 3: Try findAndStart (without actually starting)
  console.log('--- Test 3: Find best ETH market ---');

  // We'll use scanUpcomingMarkets to simulate what findAndStart would select
  const bestEthMarket = ethMarkets[0];
  if (bestEthMarket) {
    console.log(`Best ETH market would be: ${bestEthMarket.slug}`);
    console.log(`  Ends in: ${Math.round((bestEthMarket.endTime.getTime() - Date.now()) / 60000)} minutes`);
  } else {
    console.log('No ETH market available for selection');
  }

  console.log('\n=== Scan Test Complete ===');
}

main().catch(console.error);

================================================================================
// File: scripts/redeem.ts
================================================================================
import { OnchainService } from '../src/index.js';

interface RedeemTarget {
  wallet: string;
  privateKeyEnv: string;
  conditionId: string;
  description: string;
}

const targets: RedeemTarget[] = [
  // Main wallet - ETH 7:15-7:30AM Up (+$24.71)
  {
    wallet: 'main',
    privateKeyEnv: 'POLY_PRIVATE_KEY_1',
    conditionId: '0x0be9ec4ae7d1c374122a755f7d930fbfd1b00da33627a43a322f300d74a3e65a',
    description: 'ETH 1/6 7:15-7:30AM Up',
  },
  // Main wallet - ETH 7:30-7:45AM Down (+$10.96)
  {
    wallet: 'main',
    privateKeyEnv: 'POLY_PRIVATE_KEY_1',
    conditionId: '0x08caf197ee16ea30ddb9851a4301b64b44b74daab1c1f463756e1b33bfe29205',
    description: 'ETH 1/6 7:30-7:45AM Down',
  },
  // Trading wallet - XRP 6:45-7:00AM Up (+$39.60)
  {
    wallet: 'trading',
    privateKeyEnv: 'POLY_PRIVATE_KEY_2',
    conditionId: '0x79a69ec0b35741ad37db9b2043eaf635731cbfdfccb8a7314c4a0cd70f21d097',
    description: 'XRP 1/6 6:45-7:00AM Up',
  },
];

async function main() {
  console.log('=== Redeeming winning positions ===\n');

  for (const target of targets) {
    console.log(`\n[${target.wallet}] ${target.description}`);
    console.log(`  ConditionId: ${target.conditionId}`);

    const privateKey = process.env[target.privateKeyEnv];
    if (!privateKey) {
      console.log(`  ERROR: ${target.privateKeyEnv} not set`);
      continue;
    }

    try {
      const service = new OnchainService({
        privateKey,
        rpcUrl: 'https://polygon-rpc.com',
      });

      // Check resolution
      const resolution = await service.getMarketResolution(target.conditionId);
      const resolutionStatus = resolution.isResolved
        ? `Yes - ${resolution.winningOutcome} wins`
        : 'Not resolved';
      console.log(`  Resolution: ${resolutionStatus}`);

      if (!resolution.isResolved) {
        console.log(`  SKIP: not resolved yet`);
        continue;
      }

      // Get position balance
      const balance = await service.getPositionBalance(target.conditionId);
      console.log(`  Balance: YES=${balance.yesBalance}, NO=${balance.noBalance}`);

      const hasYes = parseFloat(balance.yesBalance) > 0;
      const hasNo = parseFloat(balance.noBalance) > 0;

      if (!hasYes && !hasNo) {
        console.log(`  SKIP: no tokens to redeem`);
        continue;
      }

      // Redeem
      const result = await service.redeem(target.conditionId);
      console.log(`  SUCCESS: Redeemed ${result.tokensRedeemed} tokens -> ${result.usdcReceived} USDC`);
      console.log(`  TX: https://polygonscan.com/tx/${result.txHash}`);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : String(err);
      console.log(`  ERROR: ${message}`);
    }
  }

  console.log('\n=== Done ===');
}

main().catch(console.error);

================================================================================
// File: scripts/rescue/rescue-contract.ts
================================================================================
/**
 * Rescue Contract - 救援被盗钱包资产
 *
 * 原理：
 * 1. 使用 selfdestruct 发送 MATIC 到被盗钱包（内部交易，不在 mempool）
 * 2. Sweeper bot 监控的是公开的 pending transactions，看不到内部交易
 * 3. 在 MATIC 到账后立即广播预签名的赎回和转账交易
 *
 * 使用方法：
 * COMPROMISED_KEY=0x... SAFE_KEY=0x... npx tsx scripts/rescue/rescue-contract.ts
 */

import { ethers, BigNumber } from 'ethers';

// ============================================
// 配置
// ============================================

const RPC_URL = process.env.RPC_URL || 'https://polygon-rpc.com';
const CHAIN_ID = 137;

// 合约地址
const CTF_CONTRACT = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';
const USDC_E_CONTRACT = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';

// 目标地址（救回资金的去向）- 必须通过环境变量设置
const SAFE_ADDRESS = process.env.SAFE_ADDRESS || '';

// Gas 价格策略
const HIGH_GAS_PRICE = ethers.utils.parseUnits('200000', 'gwei');  // 200k gwei for POL competition
const MEDIUM_GAS_PRICE = ethers.utils.parseUnits('5000', 'gwei');   // 5k gwei for USDC.e transfer

// 需要赎回的 positions
const POSITIONS = [
  {
    name: 'ETH 5:15-5:30AM Up',
    conditionId: '0x119ec492cd8934f4ea44dd16d098149fdd00ce116e46a1b65b855a1074d264db',
    tokenId: '82875848930625660471708909808276475886706130514035184576915498263533434905065',
    outcome: 'Up',  // YES in CTF terms
    shares: '78.231700',
  },
  {
    name: 'ETH 2:30-2:45AM Down',
    conditionId: '0x92a59acbc7dba4192485ec90e1bc40d0e8fdb10466af3b6fdd56ab9bc0ef5d9b',
    tokenId: '56703946678402567398779119914656838730380226286022317686810135985797791941257',
    outcome: 'Down',  // NO in CTF terms
    shares: '30.625200',
  },
  {
    name: 'ETH 2:45-3:00AM Down',
    conditionId: '0x2a3c8ca4890b3c2b71814c3350f18433ea0ef0d5e1f399c2b33910dd4807d224',
    tokenId: '113451188975905701019909275656369706409918614011470440344205049432343218879759',
    outcome: 'Down',  // NO in CTF terms
    shares: '25.105600',
  },
  {
    name: 'ETH 5:30-5:45AM Up',
    conditionId: '0x90b7103f2b32e9981be12758715f28143d969cd4ce1edf8eeb3ca6d75bcda5d4',
    tokenId: '36347416490015870327323843024035278361798601777731930769427053154643858785238',
    outcome: 'Up',  // YES in CTF terms
    shares: '25.092200',
  },
];

/**
 * Rescue 合约 bytecode
 *
 * 源码:
 * ```solidity
 * // SPDX-License-Identifier: MIT
 * pragma solidity ^0.8.0;
 * contract Rescue {
 *     constructor(address payable victim) payable {
 *         selfdestruct(victim);
 *     }
 * }
 * ```
 *
 * 编译命令 (solc 0.8.19 --optimize):
 *   solc --bin --optimize-runs 200 Rescue.sol
 *
 * 验证方法:
 *   部署时发送 MATIC，合约立即 selfdestruct 并将余额发送到 victim
 *   这是一个内部交易，不会出现在 mempool 中
 */
const RESCUE_BYTECODE = '0x608060405260405160523803806052833981016040819052601f91602b565b6001600160a01b0316ff5b600060208284031215603c57600080fd5b81516001600160a01b0381168114605257600080fd5b9392505050fe';

// ABI definitions
const CTF_ABI = [
  'function redeemPositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] indexSets) external',
];

const ERC20_ABI = [
  'function transfer(address to, uint256 amount) returns (bool)',
  'function balanceOf(address account) view returns (uint256)',
];

// ============================================
// 主函数
// ============================================

async function main() {
  console.log('='.repeat(60));
  console.log('被盗钱包救援脚本 - 智能合约方案');
  console.log('='.repeat(60));

  // 获取环境变量
  const compromisedKey = process.env.COMPROMISED_KEY;
  const safeKey = process.env.SAFE_KEY;

  if (!compromisedKey || !safeKey || !SAFE_ADDRESS) {
    console.error('请设置环境变量:');
    console.error('  COMPROMISED_KEY - 被盗钱包私钥');
    console.error('  SAFE_KEY - 安全钱包私钥 (用于发送 MATIC)');
    console.error('  SAFE_ADDRESS - 资金转移目标地址');
    process.exit(1);
  }

  // 初始化 provider 和 wallets
  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
  const compromisedWallet = new ethers.Wallet(compromisedKey, provider);
  const safeWallet = new ethers.Wallet(safeKey, provider);

  console.log('\n钱包信息:');
  console.log(`被盗钱包: ${compromisedWallet.address}`);
  console.log(`安全钱包: ${safeWallet.address}`);
  console.log(`资金目标: ${SAFE_ADDRESS}`);

  // 检查当前状态
  const [compromisedBalance, safeBalance] = await Promise.all([
    provider.getBalance(compromisedWallet.address),
    provider.getBalance(safeWallet.address),
  ]);

  console.log(`\n当前余额:`);
  console.log(`被盗钱包 MATIC: ${ethers.utils.formatEther(compromisedBalance)}`);
  console.log(`安全钱包 MATIC: ${ethers.utils.formatEther(safeBalance)}`);

  // 获取被盗钱包当前 nonce
  const currentNonce = await provider.getTransactionCount(compromisedWallet.address);
  console.log(`被盗钱包当前 nonce: ${currentNonce}`);

  // 计算需要的 gas
  const estimatedGas = await estimateRequiredGas(provider, compromisedWallet.address);
  console.log(`\n预估需要 MATIC: ${ethers.utils.formatEther(estimatedGas)}`);

  if (safeBalance.lt(estimatedGas)) {
    console.error(`安全钱包余额不足! 需要 ${ethers.utils.formatEther(estimatedGas)} MATIC`);
    process.exit(1);
  }

  // ============================================
  // Phase 1: 预签名所有交易
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log('Phase 1: 预签名交易');
  console.log('='.repeat(60));

  const signedTransactions: string[] = [];
  let nonce = currentNonce;

  // 签名赎回交易
  for (const position of POSITIONS) {
    console.log(`\n签名赎回: ${position.name}`);

    const ctfInterface = new ethers.utils.Interface(CTF_ABI);
    // indexSets: [1] for YES/Up, [2] for NO/Down
    const indexSets = position.outcome === 'Up' ? [1] : [2];

    const redeemData = ctfInterface.encodeFunctionData('redeemPositions', [
      USDC_E_CONTRACT,
      ethers.constants.HashZero,
      position.conditionId,
      indexSets,
    ]);

    const redeemTx = {
      to: CTF_CONTRACT,
      data: redeemData,
      nonce: nonce,
      gasLimit: 200000,
      maxPriorityFeePerGas: HIGH_GAS_PRICE,
      maxFeePerGas: HIGH_GAS_PRICE,
      chainId: CHAIN_ID,
      type: 2,
    };

    const signedRedeem = await compromisedWallet.signTransaction(redeemTx);
    signedTransactions.push(signedRedeem);
    console.log(`  TX${nonce}: 已签名 (${position.shares} shares)`);
    nonce++;
  }

  // 签名 USDC.e 转账交易
  console.log(`\n签名 USDC.e 转账到 ${SAFE_ADDRESS}`);

  const erc20Interface = new ethers.utils.Interface(ERC20_ABI);
  // 转账最大值 (实际会根据余额)
  const usdcBalance = await getUsdcBalance(provider, compromisedWallet.address);
  console.log(`  当前 USDC.e 余额: ${usdcBalance}`);

  const transferData = erc20Interface.encodeFunctionData('transfer', [
    SAFE_ADDRESS,
    ethers.utils.parseUnits('9999999', 6), // 大额数字，会自动调整
  ]);

  const transferTx = {
    to: USDC_E_CONTRACT,
    data: transferData,
    nonce: nonce,
    gasLimit: 100000,
    maxPriorityFeePerGas: MEDIUM_GAS_PRICE, // USDC 转账用中等 gas
    maxFeePerGas: MEDIUM_GAS_PRICE,
    chainId: CHAIN_ID,
    type: 2,
  };

  const signedTransfer = await compromisedWallet.signTransaction(transferTx);
  signedTransactions.push(signedTransfer);
  console.log(`  TX${nonce}: USDC.e 转账已签名`);
  nonce++;

  // 签名 MATIC 转出交易 (清空剩余)
  console.log(`\n签名 MATIC 转出到 ${SAFE_ADDRESS}`);

  // 预估剩余 MATIC (转入的减去已用的 gas)
  const maticTransferTx = {
    to: SAFE_ADDRESS,
    value: ethers.utils.parseEther('0.001'), // 小额，实际会是剩余
    nonce: nonce,
    gasLimit: 21000,
    maxPriorityFeePerGas: HIGH_GAS_PRICE,
    maxFeePerGas: HIGH_GAS_PRICE,
    chainId: CHAIN_ID,
    type: 2,
  };

  const signedMaticTransfer = await compromisedWallet.signTransaction(maticTransferTx);
  signedTransactions.push(signedMaticTransfer);
  console.log(`  TX${nonce}: MATIC 转出已签名`);

  console.log(`\n总计 ${signedTransactions.length} 笔预签名交易`);

  // ============================================
  // Phase 2: 部署 Rescue 合约 + 广播交易
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log('Phase 2: 部署 Rescue 合约 (selfdestruct)');
  console.log('='.repeat(60));

  // 准备合约部署交易
  const rescueFactory = new ethers.ContractFactory(
    ['constructor(address payable victim)'],
    RESCUE_BYTECODE,
    safeWallet
  );

  // 添加足够的 MATIC 到合约部署交易
  const maticToSend = estimatedGas.mul(120).div(100); // 加 20% 余量

  console.log(`\n准备发送 ${ethers.utils.formatEther(maticToSend)} MATIC 通过 selfdestruct...`);
  console.log('按 Enter 继续执行，Ctrl+C 取消...');

  // 等待用户确认
  await waitForEnter();

  // 部署合约 (会自动 selfdestruct 并发送 MATIC)
  console.log('\n部署 Rescue 合约...');

  try {
    const deployTx = await safeWallet.sendTransaction({
      data: RESCUE_BYTECODE + ethers.utils.defaultAbiCoder.encode(['address'], [compromisedWallet.address]).slice(2),
      value: maticToSend,
      gasLimit: 100000,
      maxPriorityFeePerGas: ethers.utils.parseUnits('50', 'gwei'),
      maxFeePerGas: ethers.utils.parseUnits('100', 'gwei'),
    });

    console.log(`Rescue 合约部署 TX: ${deployTx.hash}`);
    console.log('等待确认...');

    const receipt = await deployTx.wait(1);
    console.log(`确认! Block: ${receipt.blockNumber}`);

    // 检查 MATIC 是否到账
    const newBalance = await provider.getBalance(compromisedWallet.address);
    console.log(`被盗钱包新余额: ${ethers.utils.formatEther(newBalance)} MATIC`);

    // ============================================
    // Phase 3: 立即广播所有预签名交易
    // ============================================
    console.log('\n' + '='.repeat(60));
    console.log('Phase 3: 广播预签名交易');
    console.log('='.repeat(60));

    for (let i = 0; i < signedTransactions.length; i++) {
      try {
        console.log(`\n广播 TX ${currentNonce + i}...`);
        const tx = await provider.sendTransaction(signedTransactions[i]);
        console.log(`  Hash: ${tx.hash}`);

        // 等待确认
        const txReceipt = await tx.wait(1);
        console.log(`  确认! Gas used: ${txReceipt.gasUsed.toString()}`);
      } catch (error) {
        console.error(`  失败: ${error instanceof Error ? error.message : error}`);
      }
    }

    // ============================================
    // 完成
    // ============================================
    console.log('\n' + '='.repeat(60));
    console.log('救援完成!');
    console.log('='.repeat(60));

    // 检查最终余额
    const finalUsdcBalance = await getUsdcBalance(provider, SAFE_ADDRESS);
    console.log(`\n安全地址 USDC.e 余额: ${finalUsdcBalance}`);

  } catch (error) {
    console.error('\n救援失败:', error);
    process.exit(1);
  }
}

// ============================================
// 辅助函数
// ============================================

async function estimateRequiredGas(provider: ethers.providers.Provider, address: string): Promise<BigNumber> {
  // 4 笔赎回 (200k gas each) + 1 笔 USDC 转账 (100k) + 1 笔 MATIC 转账 (21k)
  // 使用 200k gwei gas price
  const totalGas = 4 * 200000 + 100000 + 21000; // ~921k gas
  const gasCost = BigNumber.from(totalGas).mul(HIGH_GAS_PRICE);
  return gasCost;
}

async function getUsdcBalance(provider: ethers.providers.Provider, address: string): Promise<string> {
  const contract = new ethers.Contract(USDC_E_CONTRACT, ERC20_ABI, provider);
  const balance = await contract.balanceOf(address);
  return ethers.utils.formatUnits(balance, 6);
}

function waitForEnter(): Promise<void> {
  return new Promise((resolve) => {
    process.stdin.once('data', () => {
      resolve();
    });
  });
}

// 运行
main().catch(console.error);

================================================================================
// File: scripts/rescue/rescue-erc1155.ts
================================================================================
/**
 * Rescue ERC-1155 - 救援被盗钱包的 Conditional Tokens
 *
 * 原理：
 * 1. 预签名所有转账交易（ERC-1155 + USDC.e + MATIC）
 * 2. 部署 selfdestruct 合约，通过内部交易发送 MATIC（sweeper 看不到）
 * 3. 立即广播预签名的交易
 */

import { ethers, BigNumber } from 'ethers';

// ============================================
// 配置
// ============================================

const RPC_URL = process.env.RPC_URL || 'https://polygon-rpc.com';
const CHAIN_ID = 137;

const CTF_CONTRACT = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';
const USDC_E_CONTRACT = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const SAFE_ADDRESS = process.env.SAFE_ADDRESS || '';

// Gas 倍数 - 相对于网络当前 gas price
const GAS_MULTIPLIER = 3;

const TOKENS = [
  { name: 'ETH 5:15-5:30AM Up', tokenId: '82875848930625660471708909808276475886706130514035184576915498263533434905065' },
  { name: 'ETH 2:30-2:45AM Down', tokenId: '56703946678402567398779119914656838730380226286022317686810135985797791941257' },
  { name: 'ETH 2:45-3:00AM Down', tokenId: '113451188975905701019909275656369706409918614011470440344205049432343218879759' },
  { name: 'ETH 5:30-5:45AM Up', tokenId: '36347416490015870327323843024035278361798601777731930769427053154643858785238' },
];

/**
 * 生成 selfdestruct 合约 bytecode
 *
 * 原理：PUSH20 <address> + SELFDESTRUCT
 * - 0x73 = PUSH20 (将后面 20 字节压栈)
 * - <20 bytes> = 目标地址
 * - 0xff = SELFDESTRUCT (将合约余额发送到栈顶地址)
 *
 * 合约部署时立即执行 selfdestruct，将携带的 MATIC 发送给目标地址
 * 这是内部交易，不会出现在 mempool 中，sweeper 无法检测
 */
function buildSelfdestructBytecode(targetAddress: string): string {
  const addr = targetAddress.toLowerCase().replace('0x', '');
  if (addr.length !== 40) {
    throw new Error(`Invalid address length: ${addr.length}`);
  }
  // PUSH20 <address> SELFDESTRUCT
  return '0x73' + addr + 'ff';
}

const ERC1155_ABI = [
  'function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) external',
  'function balanceOf(address account, uint256 id) view returns (uint256)',
];

const ERC20_ABI = [
  'function transfer(address to, uint256 amount) returns (bool)',
  'function balanceOf(address account) view returns (uint256)',
];

// ============================================
// 主函数
// ============================================

async function main() {
  console.log('='.repeat(60));
  console.log('被盗钱包救援脚本 - ERC-1155 批量转账');
  console.log('='.repeat(60));

  const compromisedKey = process.env.COMPROMISED_KEY;
  const safeKey = process.env.SAFE_KEY;

  if (!compromisedKey || !safeKey || !SAFE_ADDRESS) {
    console.error('\n请设置环境变量:');
    console.error('COMPROMISED_KEY=0x... SAFE_KEY=0x... SAFE_ADDRESS=0x... npx tsx scripts/rescue/rescue-erc1155.ts');
    process.exit(1);
  }

  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
  const compromisedWallet = new ethers.Wallet(compromisedKey, provider);
  const safeWallet = new ethers.Wallet(safeKey, provider);

  console.log(`\n被盗钱包: ${compromisedWallet.address}`);
  console.log(`安全钱包: ${safeWallet.address}`);
  console.log(`目标地址: ${SAFE_ADDRESS}`);

  // 获取实时 gas price
  const networkGasPrice = await provider.getGasPrice();
  const gasPrice = networkGasPrice.mul(GAS_MULTIPLIER);
  console.log(`\n网络 Gas Price: ${ethers.utils.formatUnits(networkGasPrice, 'gwei')} gwei`);
  console.log(`使用 Gas Price: ${ethers.utils.formatUnits(gasPrice, 'gwei')} gwei (${GAS_MULTIPLIER}x)`);

  // 获取 token 余额
  const ctfContract = new ethers.Contract(CTF_CONTRACT, ERC1155_ABI, provider);
  const tokenBalances: BigNumber[] = [];

  console.log('\nToken 余额:');
  for (const token of TOKENS) {
    const balance = await ctfContract.balanceOf(compromisedWallet.address, token.tokenId);
    tokenBalances.push(balance);
    console.log(`  ${token.name}: ${ethers.utils.formatUnits(balance, 6)}`);
  }

  // USDC.e 余额
  const usdcContract = new ethers.Contract(USDC_E_CONTRACT, ERC20_ABI, provider);
  const usdcBalance = await usdcContract.balanceOf(compromisedWallet.address);
  console.log(`  USDC.e: $${ethers.utils.formatUnits(usdcBalance, 6)}`);

  const currentNonce = await provider.getTransactionCount(compromisedWallet.address);
  console.log(`\n当前 nonce: ${currentNonce}`);

  // ============================================
  // Phase 1: 预签名所有交易
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log('Phase 1: 预签名所有交易');
  console.log('='.repeat(60));

  const signedTxs: string[] = [];
  let nonce = currentNonce;

  // 1. ERC-1155 批量转账
  const ctfInterface = new ethers.utils.Interface(ERC1155_ABI);
  const batchTransferData = ctfInterface.encodeFunctionData('safeBatchTransferFrom', [
    compromisedWallet.address, SAFE_ADDRESS, TOKENS.map(t => t.tokenId), tokenBalances, '0x'
  ]);

  const signedBatch = await compromisedWallet.signTransaction({
    to: CTF_CONTRACT, data: batchTransferData, nonce: nonce++,
    gasLimit: 200000, maxPriorityFeePerGas: gasPrice, maxFeePerGas: gasPrice, chainId: CHAIN_ID, type: 2
  });
  signedTxs.push(signedBatch);
  console.log(`\n✓ TX${nonce - 1}: ERC-1155 批量转账已签名 (${TOKENS.length} tokens)`);

  // 2. USDC.e 转账
  if (usdcBalance.gt(0)) {
    const erc20Interface = new ethers.utils.Interface(ERC20_ABI);
    const transferData = erc20Interface.encodeFunctionData('transfer', [SAFE_ADDRESS, usdcBalance]);

    const signedUsdc = await compromisedWallet.signTransaction({
      to: USDC_E_CONTRACT, data: transferData, nonce: nonce++,
      gasLimit: 100000, maxPriorityFeePerGas: gasPrice, maxFeePerGas: gasPrice, chainId: CHAIN_ID, type: 2
    });
    signedTxs.push(signedUsdc);
    console.log(`✓ TX${nonce - 1}: USDC.e 转账已签名 ($${ethers.utils.formatUnits(usdcBalance, 6)})`);
  }

  // 3. MATIC 转账 (剩余)
  const signedMatic = await compromisedWallet.signTransaction({
    to: SAFE_ADDRESS, value: ethers.utils.parseEther('0.001'), nonce: nonce++,
    gasLimit: 21000, maxPriorityFeePerGas: gasPrice, maxFeePerGas: gasPrice, chainId: CHAIN_ID, type: 2
  });
  signedTxs.push(signedMatic);
  console.log(`✓ TX${nonce - 1}: MATIC 转账已签名`);

  // ============================================
  // Phase 2: 部署 Rescue 合约 (selfdestruct 发送 MATIC)
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log('Phase 2: 部署 Rescue 合约 (selfdestruct)');
  console.log('='.repeat(60));

  // 计算需要的 MATIC (gas 费用 + 20% 余量)
  const totalGas = 200000 + 100000 + 21000;  // ERC-1155 + USDC.e + MATIC
  const maticToSend = BigNumber.from(totalGas).mul(gasPrice).mul(120).div(100);

  console.log(`\n总计 ${signedTxs.length} 笔预签名交易`);
  console.log(`预估 gas 用量: ${totalGas.toLocaleString()}`);
  console.log(`发送 ${ethers.utils.formatEther(maticToSend)} MATIC via selfdestruct...`);

  // 生成 selfdestruct bytecode (PUSH20 <address> SELFDESTRUCT)
  const rescueBytecode = buildSelfdestructBytecode(compromisedWallet.address);
  console.log(`\nRescue bytecode: ${rescueBytecode}`);
  console.log(`Bytecode 长度: ${(rescueBytecode.length - 2) / 2} bytes`);

  // 部署合约 (合约立即 selfdestruct，发送 MATIC 给被盗钱包)
  // 使用动态 gas price（与预签名交易相同）
  const deployTx = await safeWallet.sendTransaction({
    data: rescueBytecode,
    value: maticToSend,
    gasLimit: 70000,  // 部署+selfdestruct 需要约 53k gas
    maxPriorityFeePerGas: gasPrice,
    maxFeePerGas: gasPrice,
  });

  console.log(`\nRescue TX: ${deployTx.hash}`);
  console.log('等待确认...');
  await deployTx.wait(1);
  console.log('✓ Rescue 合约已部署，MATIC 已发送到被盗钱包');

  // ============================================
  // Phase 3: 广播预签名交易
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log('Phase 3: 广播预签名交易');
  console.log('='.repeat(60));

  const txNames = ['ERC-1155 批量转账', 'USDC.e 转账', 'MATIC 转出'];
  let successCount = 0;

  for (let i = 0; i < signedTxs.length; i++) {
    try {
      console.log(`\n发送 TX${i + 1} (${txNames[i]})...`);
      const tx = await provider.sendTransaction(signedTxs[i]);
      console.log(`TX: ${tx.hash}`);
      console.log('等待确认...');
      await tx.wait(1);
      console.log(`✓ TX${i + 1} 确认`);
      successCount++;
    } catch (e) {
      console.error(`✗ TX${i + 1} 失败: ${e instanceof Error ? e.message : e}`);
    }
  }

  // ============================================
  // 完成
  // ============================================
  console.log('\n' + '='.repeat(60));
  console.log(`救援完成! ${successCount}/${signedTxs.length} 交易成功`);
  console.log('='.repeat(60));

  console.log('\n目标地址最终余额:');
  for (const token of TOKENS) {
    const balance = await ctfContract.balanceOf(SAFE_ADDRESS, token.tokenId);
    console.log(`  ${token.name}: ${ethers.utils.formatUnits(balance, 6)}`);
  }
  const finalUsdc = await usdcContract.balanceOf(SAFE_ADDRESS);
  console.log(`  USDC.e: $${ethers.utils.formatUnits(finalUsdc, 6)}`);

  const finalMatic = await provider.getBalance(SAFE_ADDRESS);
  console.log(`  MATIC: ${ethers.utils.formatEther(finalMatic)}`);
}

main().catch(e => { console.error('Error:', e); process.exit(1); });

================================================================================
// File: scripts/rescue/test-dry-run.ts
================================================================================
/**
 * Dry-run 测试 - 验证预签名逻辑（不广播）
 */

import { ethers, BigNumber } from 'ethers';

const RPC_URL = process.env.RPC_URL || 'https://polygon-rpc.com';
const CHAIN_ID = 137;
const CTF_CONTRACT = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';
const USDC_E_CONTRACT = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const SAFE_ADDRESS = process.env.SAFE_ADDRESS || '';
const GAS_PRICE = ethers.utils.parseUnits('500', 'gwei');  // 10x normal

const TOKENS = [
  { name: 'ETH 5:15-5:30AM Up', tokenId: '82875848930625660471708909808276475886706130514035184576915498263533434905065' },
  { name: 'ETH 2:30-2:45AM Down', tokenId: '56703946678402567398779119914656838730380226286022317686810135985797791941257' },
  { name: 'ETH 2:45-3:00AM Down', tokenId: '113451188975905701019909275656369706409918614011470440344205049432343218879759' },
  { name: 'ETH 5:30-5:45AM Up', tokenId: '36347416490015870327323843024035278361798601777731930769427053154643858785238' },
];

const ERC1155_ABI = [
  'function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) external',
  'function balanceOf(address account, uint256 id) view returns (uint256)',
];

const ERC20_ABI = [
  'function transfer(address to, uint256 amount) returns (bool)',
  'function balanceOf(address account) view returns (uint256)',
];

async function main() {
  console.log('='.repeat(60));
  console.log('Dry-Run 测试 - 验证预签名逻辑');
  console.log('='.repeat(60));

  const compromisedKey = process.env.COMPROMISED_KEY;
  const safeKey = process.env.SAFE_KEY;

  if (!compromisedKey || !safeKey || !SAFE_ADDRESS) {
    console.error('请设置环境变量:');
    console.error('  COMPROMISED_KEY=0x... SAFE_KEY=0x... SAFE_ADDRESS=0x... npx tsx ...');
    process.exit(1);
  }

  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
  const compromisedWallet = new ethers.Wallet(compromisedKey, provider);
  const safeWallet = new ethers.Wallet(safeKey, provider);

  console.log(`\n被盗钱包: ${compromisedWallet.address}`);
  console.log(`安全钱包: ${safeWallet.address}`);

  // 显示钱包地址（移除硬编码验证）
  console.log('✅ 钱包已加载');

  // 获取 token 余额
  const ctfContract = new ethers.Contract(CTF_CONTRACT, ERC1155_ABI, provider);
  const tokenBalances: BigNumber[] = [];

  console.log('\n当前 Token 余额:');
  for (const token of TOKENS) {
    const balance = await ctfContract.balanceOf(compromisedWallet.address, token.tokenId);
    tokenBalances.push(balance);
    console.log(`  ${token.name}: ${ethers.utils.formatUnits(balance, 6)} 份`);
  }

  // 获取 USDC.e 余额
  const usdcContract = new ethers.Contract(USDC_E_CONTRACT, ERC20_ABI, provider);
  const usdcBalance = await usdcContract.balanceOf(compromisedWallet.address);
  console.log(`  USDC.e: $${ethers.utils.formatUnits(usdcBalance, 6)}`);

  // 获取当前 nonce
  const currentNonce = await provider.getTransactionCount(compromisedWallet.address);
  console.log(`\n当前 nonce: ${currentNonce}`);

  // 测试预签名
  console.log('\n' + '='.repeat(60));
  console.log('测试预签名...');
  console.log('='.repeat(60));

  const ctfInterface = new ethers.utils.Interface(ERC1155_ABI);
  const tokenIds = TOKENS.map(t => t.tokenId);

  // 1. ERC-1155 批量转账
  const batchTransferData = ctfInterface.encodeFunctionData('safeBatchTransferFrom', [
    compromisedWallet.address,
    SAFE_ADDRESS,
    tokenIds,
    tokenBalances,
    '0x',
  ]);

  const batchTransferTx = {
    to: CTF_CONTRACT,
    data: batchTransferData,
    nonce: currentNonce,
    gasLimit: 200000,
    maxPriorityFeePerGas: GAS_PRICE,
    maxFeePerGas: GAS_PRICE,
    chainId: CHAIN_ID,
    type: 2,
  };

  try {
    const signedBatchTransfer = await compromisedWallet.signTransaction(batchTransferTx);
    console.log(`\n✅ TX${currentNonce} - ERC-1155 批量转账签名成功`);
    console.log(`   长度: ${signedBatchTransfer.length} 字符`);
    console.log(`   前缀: ${signedBatchTransfer.slice(0, 20)}...`);

    // 解析签名的交易以验证
    const parsed = ethers.utils.parseTransaction(signedBatchTransfer);
    console.log(`   To: ${parsed.to}`);
    console.log(`   Nonce: ${parsed.nonce}`);
    console.log(`   Gas Limit: ${parsed.gasLimit?.toString()}`);
  } catch (e) {
    console.error(`\n❌ 签名失败: ${e instanceof Error ? e.message : e}`);
    process.exit(1);
  }

  // 2. USDC.e 转账
  if (usdcBalance.gt(0)) {
    const erc20Interface = new ethers.utils.Interface(ERC20_ABI);
    const transferData = erc20Interface.encodeFunctionData('transfer', [
      SAFE_ADDRESS,
      usdcBalance,
    ]);

    const transferTx = {
      to: USDC_E_CONTRACT,
      data: transferData,
      nonce: currentNonce + 1,
      gasLimit: 100000,
      maxPriorityFeePerGas: GAS_PRICE,
      maxFeePerGas: GAS_PRICE,
      chainId: CHAIN_ID,
      type: 2,
    };

    try {
      const signedTransfer = await compromisedWallet.signTransaction(transferTx);
      console.log(`\n✅ TX${currentNonce + 1} - USDC.e 转账签名成功`);
      console.log(`   金额: $${ethers.utils.formatUnits(usdcBalance, 6)}`);
    } catch (e) {
      console.error(`\n❌ USDC.e 转账签名失败: ${e instanceof Error ? e.message : e}`);
    }
  }

  // 3. 计算 Gas 需求
  const totalGas = 200000 + 100000 + 21000;
  const estimatedMatic = BigNumber.from(totalGas).mul(GAS_PRICE);
  const maticToSend = estimatedMatic.mul(120).div(100);  // +20%

  console.log('\n' + '='.repeat(60));
  console.log('Gas 估算:');
  console.log('='.repeat(60));
  console.log(`  ERC-1155 批量转账: 200,000 gas`);
  console.log(`  USDC.e 转账: 100,000 gas`);
  console.log(`  MATIC 转账: 21,000 gas`);
  console.log(`  总计: ${totalGas.toLocaleString()} gas`);
  console.log(`\n  Gas Price: 500 gwei (10x normal)`);
  console.log(`  预估费用: ${ethers.utils.formatEther(estimatedMatic)} MATIC`);
  console.log(`  需发送 (含余量): ${ethers.utils.formatEther(maticToSend)} MATIC`);

  // 检查安全钱包余额
  const safeBalance = await provider.getBalance(safeWallet.address);
  console.log(`\n  安全钱包余额: ${ethers.utils.formatEther(safeBalance)} MATIC`);
  if (safeBalance.gte(maticToSend)) {
    console.log(`  ✅ 余额充足`);
  } else {
    console.log(`  ❌ 余额不足! 需要 ${ethers.utils.formatEther(maticToSend)} MATIC`);
  }

  console.log('\n' + '='.repeat(60));
  console.log('Dry-Run 测试完成!');
  console.log('='.repeat(60));
  console.log(`
准备就绪! 执行真实救援命令:

COMPROMISED_KEY=${compromisedKey.slice(0, 10)}... SAFE_KEY=${safeKey.slice(0, 10)}... \\
  npx tsx scripts/rescue/rescue-erc1155.ts
  `);
}

main().catch(console.error);

================================================================================
// File: scripts/rescue/verify-erc1155-transfer.ts
================================================================================
/**
 * 验证 CTF 合约是否支持 ERC-1155 转账
 *
 * CTF 合约地址: 0x4D97DCd97eC945f40cF65F87097ACe5EA0476045
 */

import { ethers } from 'ethers';

const RPC_URL = process.env.RPC_URL || 'https://polygon-rpc.com';
const CTF_CONTRACT = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';

// 钱包地址 - 通过环境变量设置
const WALLET_ADDRESS = process.env.WALLET_ADDRESS || '';

// 需要检查的 token IDs
const TOKEN_IDS = [
  '82875848930625660471708909808276475886706130514035184576915498263533434905065',
  '56703946678402567398779119914656838730380226286022317686810135985797791941257',
  '113451188975905701019909275656369706409918614011470440344205049432343218879759',
  '36347416490015870327323843024035278361798601777731930769427053154643858785238',
];

// ERC-1155 标准 ABI
const ERC1155_ABI = [
  // 查询余额
  'function balanceOf(address account, uint256 id) view returns (uint256)',
  'function balanceOfBatch(address[] accounts, uint256[] ids) view returns (uint256[])',
  // 转账方法
  'function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) external',
  'function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) external',
  // 授权检查
  'function isApprovedForAll(address account, address operator) view returns (bool)',
  'function setApprovalForAll(address operator, bool approved) external',
  // ERC-165 接口检测
  'function supportsInterface(bytes4 interfaceId) view returns (bool)',
];

// ERC-1155 interface ID
const ERC1155_INTERFACE_ID = '0xd9b67a26';

async function main() {
  console.log('='.repeat(60));
  console.log('验证 CTF 合约 ERC-1155 功能');
  console.log('='.repeat(60));

  if (!WALLET_ADDRESS) {
    console.error('请设置环境变量: WALLET_ADDRESS=0x...');
    process.exit(1);
  }

  console.log(`\n检查钱包: ${WALLET_ADDRESS}`);

  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
  const ctfContract = new ethers.Contract(CTF_CONTRACT, ERC1155_ABI, provider);

  // 1. 检查是否支持 ERC-1155 接口
  console.log('\n1. 检查 ERC-1155 接口支持...');
  try {
    const supportsERC1155 = await ctfContract.supportsInterface(ERC1155_INTERFACE_ID);
    console.log(`   ERC-1155 接口支持: ${supportsERC1155 ? '✅ 是' : '❌ 否'}`);
  } catch (e) {
    console.log(`   ERC-1155 接口检查失败: ${e instanceof Error ? e.message : e}`);
  }

  // 2. 检查 token 余额
  console.log('\n2. 检查 token 余额...');
  for (const tokenId of TOKEN_IDS) {
    try {
      const balance = await ctfContract.balanceOf(WALLET_ADDRESS, tokenId);
      const balanceFormatted = ethers.utils.formatUnits(balance, 6);
      console.log(`   Token ${tokenId.slice(0, 20)}...: ${balanceFormatted} 份`);
    } catch (e) {
      console.log(`   Token ${tokenId.slice(0, 20)}... 余额查询失败: ${e instanceof Error ? e.message : e}`);
    }
  }

  // 3. 批量查询余额
  console.log('\n3. 批量查询余额...');
  try {
    const accounts = TOKEN_IDS.map(() => WALLET_ADDRESS);
    const balances = await ctfContract.balanceOfBatch(accounts, TOKEN_IDS);
    console.log('   批量查询成功! ✅');
    balances.forEach((balance: ethers.BigNumber, i: number) => {
      console.log(`   Position ${i + 1}: ${ethers.utils.formatUnits(balance, 6)} 份`);
    });
  } catch (e) {
    console.log(`   批量查询失败: ${e instanceof Error ? e.message : e}`);
  }

  // 4. 总结
  console.log('\n' + '='.repeat(60));
  console.log('总结:');
  console.log('='.repeat(60));
  console.log(`
CTF 合约 (${CTF_CONTRACT}) 是标准 ERC-1155 合约。

支持的转账方法:
- safeTransferFrom(from, to, id, amount, data) - 单个转账
- safeBatchTransferFrom(from, to, ids, amounts, data) - 批量转账

注意事项:
1. 需要有 MATIC 支付 gas 费
2. 如果转给 EOA 地址，不需要额外授权
3. 批量转账更省 gas
  `);
}

main().catch(console.error);

================================================================================
// File: scripts/research/research-markets.ts
================================================================================
/**
 * Market Research - ARB + MM + HYBRID Analysis
 */

import { PolymarketSDK } from '../src/index.js';

const sdk = new PolymarketSDK();

async function main() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║   ARB + MM + HYBRID Market Research                                      ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');

  console.log('\nFetching top markets by volume...\n');

  const markets = await sdk.gammaApi.getMarkets({
    active: true,
    closed: false,
    order: 'volume24hr',
    ascending: false,
    limit: 50,
  });

  console.log(`Found ${markets.length} markets. Analyzing...\n`);

  interface MarketResult {
    question: string;
    conditionId: string;
    vol24h: number;
    avgSpread: number;
    longArb: number;
    shortArb: number;
    mid: number;
    minDepth: number;
    yesBid: number;
    yesAsk: number;
    noBid: number;
    noAsk: number;
  }

  const results: MarketResult[] = [];

  for (const market of markets) {
    if (!market.conditionId) continue;

    try {
      const ob = await sdk.clobApi.getProcessedOrderbook(market.conditionId);

      if (ob.yes.bid < 0.01 || ob.no.bid < 0.01) continue;

      const vol24h = market.volume24hr || 0;
      const yesSpread = ob.summary.yesSpread || (ob.yes.ask - ob.yes.bid);
      const noSpread = ob.summary.noSpread || (ob.no.ask - ob.no.bid);
      const avgSpread = (yesSpread + noSpread) / 2;
      const longCost = ob.summary.effectiveLongCost;
      const shortRev = ob.summary.effectiveShortRevenue;
      const longArb = 1 - longCost;
      const shortArb = shortRev - 1;
      const mid = (ob.yes.bid + ob.yes.ask) / 2;
      const minDepth = Math.min(ob.yes.bidDepth, ob.yes.askDepth, ob.no.bidDepth, ob.no.askDepth);

      results.push({
        question: market.question || 'Unknown',
        conditionId: market.conditionId,
        vol24h,
        avgSpread,
        longArb,
        shortArb,
        mid,
        minDepth,
        yesBid: ob.yes.bid,
        yesAsk: ob.yes.ask,
        noBid: ob.no.bid,
        noAsk: ob.no.ask,
      });

      process.stdout.write('.');
    } catch {
      process.stdout.write('x');
    }

    await new Promise(r => setTimeout(r, 100));
  }

  console.log('\n');

  // Categorize
  const arb = results.filter(r => r.longArb > 0 || r.shortArb > 0);
  const mm = results.filter(r => r.avgSpread >= 0.01 && r.vol24h >= 10000 && r.minDepth >= 1000);
  const hybrid = results.filter(r => r.mid >= 0.25 && r.mid <= 0.75 && r.vol24h >= 5000);

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('🎯 ARBITRAGE OPPORTUNITIES:', arb.length);
  console.log('═══════════════════════════════════════════════════════════════════════════');

  if (arb.length === 0) {
    console.log('  No direct arbitrage found (market efficient)\n');

    // Show closest to arb
    const sorted = [...results].sort((a, b) => Math.max(a.longArb, a.shortArb) - Math.max(b.longArb, b.shortArb)).reverse();
    console.log('  Closest to arbitrage:');
    for (const r of sorted.slice(0, 3)) {
      const profit = Math.max(r.longArb, r.shortArb);
      console.log(`    ${r.question.slice(0, 50)}... → ${(profit * 100).toFixed(3)}%`);
    }
  } else {
    for (const r of arb.slice(0, 5)) {
      const type = r.longArb > r.shortArb ? 'LONG' : 'SHORT';
      const profit = Math.max(r.longArb, r.shortArb);
      console.log(`\n  ${r.question.slice(0, 60)}...`);
      console.log(`    ${type} ARB: ${(profit * 100).toFixed(3)}%`);
    }
  }

  console.log('\n═══════════════════════════════════════════════════════════════════════════');
  console.log('📊 MARKET MAKING CANDIDATES:', mm.length);
  console.log('═══════════════════════════════════════════════════════════════════════════');

  const mmSorted = [...mm].sort((a, b) => {
    // Score: spread * volume * sqrt(depth)
    const scoreA = a.avgSpread * Math.log(a.vol24h) * Math.sqrt(a.minDepth);
    const scoreB = b.avgSpread * Math.log(b.vol24h) * Math.sqrt(b.minDepth);
    return scoreB - scoreA;
  });

  for (const r of mmSorted.slice(0, 10)) {
    console.log(`\n  ${r.question.slice(0, 60)}...`);
    console.log(`    Spread: ${(r.avgSpread * 100).toFixed(2)}% | Vol: $${(r.vol24h/1000).toFixed(0)}K | Depth: $${(r.minDepth/1000).toFixed(0)}K`);
    console.log(`    YES: ${r.yesBid.toFixed(3)}/${r.yesAsk.toFixed(3)} | NO: ${r.noBid.toFixed(3)}/${r.noAsk.toFixed(3)}`);
  }

  console.log('\n═══════════════════════════════════════════════════════════════════════════');
  console.log('🔄 HYBRID CANDIDATES (uncertain markets 25-75%):', hybrid.length);
  console.log('═══════════════════════════════════════════════════════════════════════════');

  const hybridSorted = [...hybrid].sort((a, b) => {
    // Prefer prices closer to 50%
    const distA = Math.abs(a.mid - 0.5);
    const distB = Math.abs(b.mid - 0.5);
    return distA - distB;
  });

  for (const r of hybridSorted.slice(0, 10)) {
    console.log(`\n  ${r.question.slice(0, 60)}...`);
    console.log(`    Price: ${(r.mid * 100).toFixed(1)}¢ | Vol: $${(r.vol24h/1000).toFixed(0)}K | Spread: ${(r.avgSpread * 100).toFixed(2)}%`);
  }

  console.log('\n═══════════════════════════════════════════════════════════════════════════');
  console.log('SUMMARY');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  Total analyzed:        ${results.length}`);
  console.log(`  Arb opportunities:     ${arb.length}`);
  console.log(`  MM candidates:         ${mm.length}`);
  console.log(`  Hybrid candidates:     ${hybrid.length}`);

  if (mm.length > 0) {
    console.log(`\n  🏆 Top MM recommendation:`);
    console.log(`     ${mmSorted[0].question.slice(0, 60)}...`);
  }
  if (hybrid.length > 0) {
    console.log(`  🏆 Top Hybrid recommendation:`);
    console.log(`     ${hybridSorted[0].question.slice(0, 60)}...`);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/01-e2e.ts
================================================================================
/**
 * TRUE E2E Test: SmartMoneyService 完整链路验证
 *
 * 按照 true-e2e-verification skill:
 * 1. 使用 SmartMoneyService.subscribeSmartMoneyTrades() 监听信号
 * 2. 使用 SmartMoneyService.executeCopyTrade() 执行跟单
 * 3. 通过 createMarketOrder 返回值直接判断成功 (最快方式)
 *
 * 运行：pnpm exec tsx scripts/smart-money/01-e2e.ts
 */

import 'dotenv/config';
import {
  SmartMoneyService,
  WalletService,
  RealtimeServiceV2,
  TradingService,
  DataApiClient,
  SubgraphClient,
  RateLimiter,
  createUnifiedCache,
  type SmartMoneyTrade,
  type TradingSignal,
} from '../../src/index.js';

// Test configuration
const TEST_AMOUNT_USDC = 2; // $2 minimum
const TIMEOUT_MS = 60_000;

async function main() {
  console.log('='.repeat(60));
  console.log('TRUE E2E Test: SmartMoneyService 完整链路');
  console.log('='.repeat(60));

  // Check for private key
  if (!process.env.PRIVATE_KEY) {
    console.error('❌ PRIVATE_KEY not found in .env');
    process.exit(1);
  }

  // Initialize all services
  console.log('\n[Init] 初始化服务...');
  const cache = createUnifiedCache();
  const rateLimiter = new RateLimiter();
  const dataApi = new DataApiClient(rateLimiter, cache);
  const subgraph = new SubgraphClient(rateLimiter, cache);
  const walletService = new WalletService(dataApi, subgraph, cache);
  const realtimeService = new RealtimeServiceV2();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: process.env.PRIVATE_KEY,
    chainId: 137,
  });

  const smartMoneyService = new SmartMoneyService(
    walletService,
    realtimeService,
    tradingService
  );

  const ourAddress = tradingService.getAddress().toLowerCase();
  console.log(`  我们的钱包: ${ourAddress.slice(0, 10)}...${ourAddress.slice(-6)}`);

  try {
    // Step 1: Connect WebSocket
    console.log('\n[Step 1] 连接 WebSocket...');
    realtimeService.connect();
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Connection timeout')), 10000);
      realtimeService.once('connected', () => {
        clearTimeout(timeout);
        console.log('  ✅ WebSocket connected');
        resolve();
      });
    });

    // Step 2: Subscribe to Smart Money trades and wait for signal
    console.log('\n[Step 2] 使用 SmartMoneyService.subscribeSmartMoneyTrades() 监听...');
    console.log('  等待交易信号...\n');

    let tradeCount = 0;
    const signalTrade = await new Promise<SmartMoneyTrade>((resolve, reject) => {
      const timeout = setTimeout(() => {
        subscription.unsubscribe();
        reject(new Error(`Timeout waiting for signal. Received ${tradeCount} trades but none matched.`));
      }, TIMEOUT_MS);

      const subscription = smartMoneyService.subscribeSmartMoneyTrades(
        (trade: SmartMoneyTrade) => {
          tradeCount++;

          // Skip our own trades (though WebSocket won't show them anyway)
          if (trade.traderAddress.toLowerCase() === ourAddress) {
            console.log(`  [${tradeCount}] Skipping our own trade`);
            return;
          }

          // Skip very small trades
          if (trade.size < 2) {
            if (tradeCount <= 3) {
              console.log(`  [${tradeCount}] Trade too small: ${trade.size}`);
            }
            return;
          }

          // Found a signal!
          console.log(`  📡 [${tradeCount}] 收到 SmartMoneyTrade:`);
          console.log(`    Trader: ${trade.traderName || trade.traderAddress.slice(0, 10)}...`);
          console.log(`    Market: ${trade.marketSlug}`);
          console.log(`    Side: ${trade.side} ${trade.outcome}`);
          console.log(`    Size: ${trade.size} @ $${trade.price.toFixed(4)}`);
          console.log(`    TokenId: ${trade.tokenId?.slice(0, 20)}...`);
          console.log(`    isSmartMoney: ${trade.isSmartMoney}`);

          clearTimeout(timeout);
          subscription.unsubscribe();
          resolve(trade);
        },
        { minSize: 1 } // Lower threshold
      );
    });

    // Step 3: Convert SmartMoneyTrade to TradingSignal
    console.log('\n[Step 3] 转换为 TradingSignal...');

    const signal: TradingSignal = {
      type: 'buy',
      confidence: 0.8,
      conditionId: signalTrade.conditionId,
      marketSlug: signalTrade.marketSlug,
      side: signalTrade.side,
      outcome: (signalTrade.outcome as 'YES' | 'NO') || 'YES',
      suggestedPrice: signalTrade.price,
      suggestedSize: TEST_AMOUNT_USDC / signalTrade.price,
      reasons: [`Following ${signalTrade.traderName || signalTrade.traderAddress.slice(0, 10)}...`],
      contributingTrades: [signalTrade],
      timestamp: Date.now(),
    };

    console.log('  Signal created:');
    console.log(`    type: ${signal.type}`);
    console.log(`    side: ${signal.side} ${signal.outcome}`);
    console.log(`    price: $${signal.suggestedPrice?.toFixed(4)}`);

    // Step 4: Execute copy trade
    console.log('\n[Step 4] 使用 SmartMoneyService.executeCopyTrade() 跟单...');
    console.log(`  Amount: $${TEST_AMOUNT_USDC}`);

    const t0 = Date.now();

    const result = await smartMoneyService.executeCopyTrade(signal, {
      sizeScale: 1, // Use full signal size
      maxSize: TEST_AMOUNT_USDC,
      maxSlippage: 0.05, // 5%
      executionMode: 'market',
      marketOrderType: 'FAK', // Allow partial fills
    });

    const executionTime = Date.now() - t0;

    // Step 5: Check result (最快验证方式 - 直接看返回值)
    console.log('\n[Step 5] 验证结果 (通过返回值直接判断)...');
    console.log('='.repeat(60));
    console.log('E2E 测试结果');
    console.log('='.repeat(60));

    if (result.success) {
      console.log('\n✅ 跟单成功!');
      console.log('\n📊 订单详情:');
      console.log(`  OrderId: ${result.orderId}`);
      if (result.transactionHashes?.length) {
        console.log(`  TxHash: ${result.transactionHashes[0]}`);
        console.log(`  (有 TxHash = 已上链成交)`);
      }
      console.log(`\n⏱️ 执行耗时: ${executionTime}ms`);
    } else {
      console.log('\n❌ 跟单失败');
      console.log(`  Error: ${result.errorMsg}`);
    }

    console.log('\n📝 验证方式说明:');
    console.log('  - createMarketOrder 返回 success + transactionHashes = 已成交');
    console.log('  - 这是最快的验证方式 (0ms 额外延迟)');
    console.log('  - 不需要调用 getTrades() 或等待 WebSocket');

    // Cleanup
    smartMoneyService.disconnect();
    realtimeService.disconnect();

    console.log('\n' + '='.repeat(60));
    console.log('测试完成');
    console.log('='.repeat(60));

  } catch (error: any) {
    console.error('\n❌ 测试失败:', error.message);
    smartMoneyService.disconnect();
    realtimeService.disconnect();
    process.exit(1);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/02-e2e-low-level.ts
================================================================================
/**
 * TRUE E2E Test: Copy Trading 完整链路验证
 *
 * 按照 true-e2e-verification skill 的要求：
 * 1. 主动触发 + 被动监听
 * 2. 测量完整链路延迟（下单 → WebSocket 收到）
 *
 * 流程：
 * 1. 连接 Activity WebSocket
 * 2. 等待一个 Smart Money 交易信号
 * 3. 跟单下一个小额订单 ($2 minimum)
 * 4. 验证我们的订单是否在 Activity WebSocket 中收到
 * 5. 测量完整延迟
 *
 * 运行：pnpm exec tsx scripts/smart-money/02-e2e-low-level.ts
 */

import 'dotenv/config';
import {
  RealtimeServiceV2,
  TradingService,
  RateLimiter,
  createUnifiedCache,
  type ActivityTrade,
} from '../../src/index.js';

// Test configuration
const TEST_AMOUNT = 2; // $2 minimum order
const TIMEOUT_MS = 60_000; // 1 minute to find a signal and execute

interface E2EResult {
  signalTrade: ActivityTrade | null;
  ourOrderId: string | null;
  ourOrderPlacedAt: number;
  ourOrderReceivedAt: number | null;
  roundTripLatency: number | null;
  success: boolean;
  error?: string;
}

async function main() {
  console.log('='.repeat(60));
  console.log('TRUE E2E Test: Copy Trading 完整链路验证');
  console.log('='.repeat(60));
  console.log('\n按照 true-e2e-verification skill:');
  console.log('  1. 主动触发（下单）+ 被动监听（WebSocket）');
  console.log('  2. 测量完整链路延迟\n');

  // Check for private key
  if (!process.env.PRIVATE_KEY) {
    console.error('❌ PRIVATE_KEY not found in .env');
    process.exit(1);
  }

  const result: E2EResult = {
    signalTrade: null,
    ourOrderId: null,
    ourOrderPlacedAt: 0,
    ourOrderReceivedAt: null,
    roundTripLatency: null,
    success: false,
  };

  // Initialize services
  const cache = createUnifiedCache();
  const rateLimiter = new RateLimiter();
  const realtime = new RealtimeServiceV2();
  const trading = new TradingService(rateLimiter, cache, {
    privateKey: process.env.PRIVATE_KEY,
    chainId: 137,
  });

  try {
    // Step 1: Connect WebSocket
    console.log('[Step 1] 连接 Activity WebSocket...');
    realtime.connect();
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('WebSocket connection timeout')), 10000);
      realtime.once('connected', () => {
        clearTimeout(timeout);
        console.log('  ✅ WebSocket connected\n');
        resolve();
      });
    });

    // Get our wallet address
    const ourAddress = trading.getAddress().toLowerCase();
    console.log(`[Info] 我们的钱包地址: ${ourAddress.slice(0, 10)}...${ourAddress.slice(-6)}\n`);

    // Step 2: Wait for a signal trade
    console.log('[Step 2] 等待 Smart Money 交易信号...');
    console.log('  (监听所有交易，选择第一个有足够流动性的市场)\n');

    const signalTrade = await new Promise<ActivityTrade>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timeout waiting for signal trade'));
      }, TIMEOUT_MS);

      const sub = realtime.subscribeAllActivity({
        onTrade: (trade) => {
          // Skip our own trades
          if (trade.trader?.address?.toLowerCase() === ourAddress) return;

          // Skip tiny trades
          if (trade.size < 10) return;

          // Found a signal!
          console.log('  📡 收到信号交易:');
          console.log(`    Trader: ${trade.trader?.name || trade.trader?.address?.slice(0, 10)}...`);
          console.log(`    Market: ${trade.marketSlug}`);
          console.log(`    Side: ${trade.side} ${trade.outcome}`);
          console.log(`    Size: ${trade.size} @ $${trade.price.toFixed(4)}`);
          console.log(`    Token: ${trade.asset.slice(0, 20)}...`);

          clearTimeout(timeout);
          sub.unsubscribe();
          resolve(trade);
        },
      });
    });

    result.signalTrade = signalTrade;

    // Step 3: Place our order (copy the signal)
    console.log('\n[Step 3] 跟单下单...');
    console.log(`  Market: ${signalTrade.marketSlug}`);
    console.log(`  Side: ${signalTrade.side} ${signalTrade.outcome}`);
    console.log(`  Amount: $${TEST_AMOUNT}`);

    // Record the time BEFORE placing order
    result.ourOrderPlacedAt = Date.now();

    try {
      // Place a market order following the signal
      // Use FAK (Fill and Kill) for partial fills
      const orderResult = await trading.createMarketOrder({
        tokenId: signalTrade.asset,
        side: signalTrade.side,
        amount: TEST_AMOUNT,
        orderType: 'FAK', // Allow partial fills
      });

      if (orderResult.success) {
        result.ourOrderId = orderResult.orderId || orderResult.orderIds?.[0];
        console.log(`  ✅ 订单已提交: ${result.ourOrderId}`);
        if (orderResult.transactionHashes?.length) {
          console.log(`  TxHash: ${orderResult.transactionHashes[0]}`);
        }
      } else {
        throw new Error(orderResult.errorMsg || 'Unknown error');
      }

    } catch (orderError: any) {
      console.log(`  ⚠️ 下单失败: ${orderError.message}`);
      result.error = orderError.message;

      // Even if order fails, we can still check if the concept works
      // Try with a limit order instead
      console.log('\n  尝试使用限价单...');

      try {
        const limitResult = await trading.createLimitOrder({
          tokenId: signalTrade.asset,
          side: signalTrade.side,
          price: signalTrade.price,
          size: TEST_AMOUNT / signalTrade.price,
          orderType: 'GTC',
        });

        result.ourOrderId = limitResult.orderId;
        console.log(`  ✅ 限价单已提交: ${limitResult.orderId}`);

      } catch (limitError: any) {
        console.log(`  ❌ 限价单也失败: ${limitError.message}`);
        result.error = limitError.message;
      }
    }

    // Step 4: Verify trade via API (since Activity WebSocket doesn't show our own trades)
    console.log('\n[Step 4] 通过 API 验证交易执行...');
    console.log('  (注意: Activity WebSocket 不会广播我们自己的交易)\n');

    // Wait a moment for trade to settle
    await new Promise(resolve => setTimeout(resolve, 3000));

    // Check trades via API
    const trades = await trading.getTrades();
    const ourTrade = trades.find(t =>
      t.tokenId === signalTrade.asset &&
      t.side === signalTrade.side
    );

    // Results
    console.log('='.repeat(60));
    console.log('E2E 测试结果');
    console.log('='.repeat(60));

    if (ourTrade) {
      const tradeTime = ourTrade.timestamp * 1000;
      const executionLatency = tradeTime - result.ourOrderPlacedAt;

      console.log(`\n✅ 跟单交易执行成功!`);
      console.log(`\n📊 交易详情:`);
      console.log(`  Side: ${ourTrade.side}`);
      console.log(`  Price: $${ourTrade.price}`);
      console.log(`  Size: ${ourTrade.size} shares`);
      console.log(`  Fee: $${ourTrade.fee}`);
      console.log(`\n⏱️ 延迟测量:`);
      console.log(`  下单时间: ${new Date(result.ourOrderPlacedAt).toISOString()}`);
      console.log(`  成交时间: ${new Date(tradeTime).toISOString()}`);
      console.log(`  执行延迟: ${executionLatency}ms`);

      result.success = true;
      result.roundTripLatency = executionLatency;
    } else {
      console.log(`\n⚠️ 未找到我们的交易`);
      console.log(`  可能原因:`);
      console.log(`  - 订单未成交 (市场深度不足)`);
      console.log(`  - FAK 订单被取消`);

      if (result.error) {
        console.log(`  - 错误: ${result.error}`);
      }
    }

    console.log(`\n📝 发现:`);
    console.log(`  Activity WebSocket 不会广播用户自己的交易`);
    console.log(`  需要通过 getTrades() API 验证自己的交易执行`);
    console.log(`  或使用 clob_user topic (需要认证) 监听自己的交易`);

    // Cleanup
    realtime.disconnect();

    console.log('\n' + '='.repeat(60));
    console.log('测试完成');
    console.log('='.repeat(60));

    return result;

  } catch (error: any) {
    console.error('\n❌ 测试失败:', error.message);
    realtime.disconnect();
    process.exit(1);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/03-test-service.ts
================================================================================
/**
 * Test Script: SmartMoneyService
 *
 * Verifies SmartMoneyService functionality:
 * - Smart Money detection from leaderboard
 * - Real-time trade subscription
 * - Position syncing
 */

import {
  SmartMoneyService,
  WalletService,
  RealtimeServiceV2,
  TradingService,
  DataApiClient,
  SubgraphClient,
  RateLimiter,
  createUnifiedCache,
} from '../../src/index.js';
import { Wallet } from 'ethers';

async function main() {
  console.log('='.repeat(60));
  console.log('SmartMoneyService Test');
  console.log('='.repeat(60));

  // Initialize dependencies
  const cache = createUnifiedCache();
  const rateLimiter = new RateLimiter();
  const dataApi = new DataApiClient(rateLimiter, cache);
  const subgraph = new SubgraphClient(rateLimiter, cache);

  // Create services
  const walletService = new WalletService(dataApi, subgraph, cache);
  const realtimeService = new RealtimeServiceV2();

  // Create a read-only TradingService with random wallet (for testing only)
  // Note: This won't be used for actual trading in this test
  const randomWallet = Wallet.createRandom();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: randomWallet.privateKey,
    chainId: 137,
  });

  // Create SmartMoneyService
  const smartMoneyService = new SmartMoneyService(
    walletService,
    realtimeService,
    tradingService,
    {
      minPnl: 1000,      // Minimum $1000 PnL
      minPositions: 5,   // Minimum 5 positions
      minWinRate: 0.5,   // Minimum 50% win rate (estimated)
    }
  );

  try {
    // Test 1: Get Smart Money List
    console.log('\n[Test 1] Getting Smart Money list...');
    const smartMoneyList = await smartMoneyService.getSmartMoneyList(20);
    console.log(`Found ${smartMoneyList.length} Smart Money wallets`);

    if (smartMoneyList.length > 0) {
      console.log('\nTop 5 Smart Money wallets:');
      for (const wallet of smartMoneyList.slice(0, 5)) {
        console.log(`  ${wallet.rank}. ${wallet.address.slice(0, 10)}...`);
        console.log(`     PnL: $${wallet.pnl.toFixed(2)}, Score: ${wallet.score}`);
      }
    }

    // Test 2: Check if specific address is Smart Money
    if (smartMoneyList.length > 0) {
      console.log('\n[Test 2] Checking isSmartMoney...');
      const testAddress = smartMoneyList[0].address;
      const isSmart = await smartMoneyService.isSmartMoney(testAddress);
      console.log(`Address ${testAddress.slice(0, 10)}... is Smart Money: ${isSmart}`);
    }

    // Test 3: Sync positions for top Smart Money wallets
    if (smartMoneyList.length > 0) {
      console.log('\n[Test 3] Syncing positions for top 3 wallets...');
      const addresses = smartMoneyList.slice(0, 3).map(w => w.address);
      const snapshots = await smartMoneyService.syncPositions(addresses);

      for (const snapshot of snapshots) {
        console.log(`\n  ${snapshot.traderAddress.slice(0, 10)}...:`);
        console.log(`    Positions: ${snapshot.positions.length}`);
        if (snapshot.positions.length > 0) {
          const top = snapshot.positions[0];
          console.log(`    Top position: ${top.outcome} @ ${top.size.toFixed(2)} shares`);
        }
      }
    }

    // Test 4: Subscribe to Smart Money trades (5 second test)
    console.log('\n[Test 4] Subscribing to Smart Money trades (10 seconds)...');

    // Connect WebSocket
    realtimeService.connect();
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Connection timeout')), 10000);
      realtimeService.once('connected', () => {
        clearTimeout(timeout);
        console.log('  WebSocket connected');
        resolve();
      });
      realtimeService.once('error', (err) => {
        clearTimeout(timeout);
        reject(err);
      });
    });

    let tradeCount = 0;
    const subscription = smartMoneyService.subscribeSmartMoneyTrades(
      (trade) => {
        tradeCount++;
        console.log(`  [Trade ${tradeCount}] ${trade.traderAddress.slice(0, 10)}...`);
        console.log(`    ${trade.side} ${trade.size} @ $${trade.price.toFixed(4)}`);
        console.log(`    Smart Money: ${trade.isSmartMoney}`);
      },
      { minSize: 10 } // Only trades > $10
    );

    // Wait for 10 seconds
    await new Promise(resolve => setTimeout(resolve, 10000));

    // Unsubscribe
    subscription.unsubscribe();
    console.log(`\n  Received ${tradeCount} trades in 10 seconds`);

    // Cleanup
    smartMoneyService.disconnect();
    realtimeService.disconnect();

    console.log('\n' + '='.repeat(60));
    console.log('All tests completed successfully!');
    console.log('='.repeat(60));

  } catch (error) {
    console.error('\nTest failed:', error);
    smartMoneyService.disconnect();
    realtimeService.disconnect();
    process.exit(1);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/04-auto-copy-trading.ts
================================================================================
/**
 * Auto Copy Trading Test - 自动跟单聪明钱
 *
 * 简化版跟单：一行代码启动自动跟单
 * - 跟踪排行榜前10名
 * - 聪明钱一旦有交易立即跟单
 * - 支持 dry run 模式测试
 *
 * 运行：pnpm exec tsx scripts/smart-money/04-auto-copy-trading.ts
 */

import 'dotenv/config';
import {
  SmartMoneyService,
  WalletService,
  RealtimeServiceV2,
  TradingService,
  DataApiClient,
  SubgraphClient,
  RateLimiter,
  createUnifiedCache,
} from '../../src/index.js';

// Configuration
const DRY_RUN = true; // Set to false to execute real trades
const TOP_N = 50; // Follow top 50 traders (more chances to catch trades)
const SIZE_SCALE = 0.1; // Copy 10% of their trade size
const MAX_SIZE_PER_TRADE = 10; // Max $10 per trade
const MAX_SLIPPAGE = 0.03; // 3% slippage
const RUN_DURATION_MS = 2 * 60 * 1000; // Run for 2 minutes

async function main() {
  console.log('='.repeat(60));
  console.log('🤖 Auto Copy Trading - 自动跟单聪明钱');
  console.log('='.repeat(60));
  console.log(`Mode: ${DRY_RUN ? '🧪 DRY RUN (不执行真实交易)' : '💰 LIVE TRADING'}`);
  console.log(`Following: Top ${TOP_N} traders`);
  console.log(`Size Scale: ${SIZE_SCALE * 100}%`);
  console.log(`Max per trade: $${MAX_SIZE_PER_TRADE}`);
  console.log(`Duration: ${RUN_DURATION_MS / 1000}s`);
  console.log('='.repeat(60));

  // Check for private key
  const privateKey = process.env.PRIVATE_KEY || process.env.POLY_PRIVATE_KEY;
  if (!privateKey) {
    console.error('❌ PRIVATE_KEY or POLY_PRIVATE_KEY not found in .env');
    process.exit(1);
  }

  // Initialize services
  console.log('\n[Init] 初始化服务...');
  const cache = createUnifiedCache();
  const rateLimiter = new RateLimiter();
  const dataApi = new DataApiClient(rateLimiter, cache);
  const subgraph = new SubgraphClient(rateLimiter, cache);
  const walletService = new WalletService(dataApi, subgraph, cache);
  const realtimeService = new RealtimeServiceV2();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey,
    chainId: 137,
  });

  const smartMoneyService = new SmartMoneyService(
    walletService,
    realtimeService,
    tradingService
  );

  const ourAddress = tradingService.getAddress().toLowerCase();
  console.log(`  我们的钱包: ${ourAddress.slice(0, 10)}...${ourAddress.slice(-6)}`);

  try {
    // Connect WebSocket
    console.log('\n[WebSocket] 连接中...');
    realtimeService.connect();
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Connection timeout')), 10000);
      realtimeService.once('connected', () => {
        clearTimeout(timeout);
        console.log('  ✅ WebSocket connected');
        resolve();
      });
    });

    // Start auto copy trading - 一行代码启动自动跟单！
    console.log('\n[Auto Copy Trading] 启动自动跟单...');

    const subscription = await smartMoneyService.startAutoCopyTrading({
      // 跟踪排行榜前N名
      topN: TOP_N,

      // 跟单配置
      sizeScale: SIZE_SCALE,
      maxSizePerTrade: MAX_SIZE_PER_TRADE,
      maxSlippage: MAX_SLIPPAGE,
      orderType: 'FOK',

      // 过滤
      minTradeSize: 5, // Only copy trades > $5

      // Dry run mode
      dryRun: DRY_RUN,

      // Callbacks
      onTrade: (trade, result) => {
        console.log('\n📈 跟单执行:');
        console.log(`  Trader: ${trade.traderName || trade.traderAddress.slice(0, 10)}...`);
        console.log(`  Market: ${trade.marketSlug}`);
        console.log(`  ${trade.side} ${trade.outcome} @ $${trade.price.toFixed(4)}`);
        console.log(`  Result: ${result.success ? '✅ 成功' : '❌ 失败'}`);
        if (result.orderId) console.log(`  OrderId: ${result.orderId}`);
        if (result.errorMsg) console.log(`  Error: ${result.errorMsg}`);
      },
      onError: (error) => {
        console.error('\n❌ 跟单错误:', error.message);
      },
    });

    console.log(`\n✅ 自动跟单已启动!`);
    console.log(`   跟踪 ${subscription.targetAddresses.length} 个钱包`);
    console.log(`   目标地址:`);
    subscription.targetAddresses.slice(0, 5).forEach((addr, i) => {
      console.log(`     ${i + 1}. ${addr.slice(0, 10)}...${addr.slice(-6)}`);
    });
    if (subscription.targetAddresses.length > 5) {
      console.log(`     ... 还有 ${subscription.targetAddresses.length - 5} 个`);
    }

    console.log('\n⏳ 监听交易中... (按 Ctrl+C 停止)\n');

    // Run for specified duration
    await new Promise<void>((resolve) => {
      const interval = setInterval(() => {
        const stats = subscription.getStats();
        const elapsed = Math.floor((Date.now() - stats.startTime) / 1000);
        console.log(`  [${elapsed}s] 检测: ${stats.tradesDetected}, 执行: ${stats.tradesExecuted}, 跳过: ${stats.tradesSkipped}, 失败: ${stats.tradesFailed}`);
      }, 30000); // Log stats every 30 seconds

      setTimeout(() => {
        clearInterval(interval);
        resolve();
      }, RUN_DURATION_MS);
    });

    // Final stats
    const finalStats = subscription.getStats();
    console.log('\n' + '='.repeat(60));
    console.log('📊 运行统计');
    console.log('='.repeat(60));
    console.log(`  运行时间: ${Math.floor((Date.now() - finalStats.startTime) / 1000)}s`);
    console.log(`  检测交易: ${finalStats.tradesDetected}`);
    console.log(`  执行跟单: ${finalStats.tradesExecuted}`);
    console.log(`  跳过交易: ${finalStats.tradesSkipped}`);
    console.log(`  失败交易: ${finalStats.tradesFailed}`);
    console.log(`  总花费: $${finalStats.totalUsdcSpent.toFixed(2)}`);

    // Cleanup
    subscription.stop();
    smartMoneyService.disconnect();
    realtimeService.disconnect();

    console.log('\n✅ 测试完成');

  } catch (error: any) {
    console.error('\n❌ 错误:', error.message);
    smartMoneyService.disconnect();
    realtimeService.disconnect();
    process.exit(1);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/05-auto-copy-simple.ts
================================================================================
/**
 * Auto Copy Trading (Simplified) - 最简化的自动跟单
 *
 * 展示三种初始化方式：
 * 1. PolymarketSDK.create() - 静态工厂方法（推荐）
 * 2. sdk.start() - 一步启动
 * 3. 手动分步初始化
 *
 * 运行：pnpm exec tsx scripts/smart-money/05-auto-copy-simple.ts
 */

import 'dotenv/config';
import { PolymarketSDK } from '../../src/index.js';

const DRY_RUN = true;
const TOP_N = 50;
const RUN_DURATION_MS = 60 * 1000;

async function main() {
  console.log('='.repeat(60));
  console.log('🤖 Auto Copy Trading - Simplified API');
  console.log('='.repeat(60));

  const privateKey = process.env.PRIVATE_KEY || process.env.POLY_PRIVATE_KEY;
  if (!privateKey) {
    console.error('❌ PRIVATE_KEY not found');
    process.exit(1);
  }

  // ============================================
  // 方式 1: 静态工厂方法（最简洁，推荐）
  // ============================================
  const sdk = await PolymarketSDK.create({ privateKey });
  // 一行搞定：new SDK + initialize + connect + waitForConnection

  // ============================================
  // 方式 2: 使用 start() 方法
  // ============================================
  // const sdk = new PolymarketSDK({ privateKey });
  // await sdk.start();  // initialize + connect + waitForConnection

  // ============================================
  // 方式 3: 手动分步（完全控制）
  // ============================================
  // const sdk = new PolymarketSDK({ privateKey });
  // await sdk.initialize();
  // sdk.connect();
  // await sdk.waitForConnection();

  console.log('✅ SDK ready\n');

  // 启动自动跟单
  const subscription = await sdk.smartMoney.startAutoCopyTrading({
    topN: TOP_N,
    sizeScale: 0.1,
    maxSizePerTrade: 10,
    maxSlippage: 0.03,
    orderType: 'FOK',
    minTradeSize: 5,
    dryRun: DRY_RUN,
    onTrade: (trade, result) => {
      console.log(`📈 ${trade.traderName || trade.traderAddress.slice(0, 10)}...`);
      console.log(`   ${trade.side} ${trade.outcome} @ $${trade.price.toFixed(4)}`);
      console.log(`   ${result.success ? '✅' : '❌'}\n`);
    },
  });

  console.log(`跟踪 ${subscription.targetAddresses.length} 个钱包`);
  console.log('⏳ 监听中...\n');

  // 运行指定时间
  await new Promise(resolve => setTimeout(resolve, RUN_DURATION_MS));

  // 统计
  const stats = subscription.getStats();
  console.log('='.repeat(60));
  console.log(`检测: ${stats.tradesDetected}, 执行: ${stats.tradesExecuted}, 跳过: ${stats.tradesSkipped}`);

  // 清理 - 一行搞定
  subscription.stop();
  sdk.stop();  // 或 sdk.disconnect()

  console.log('✅ Done');
}

main().catch(console.error);

================================================================================
// File: scripts/smart-money/06-real-copy-test.ts
================================================================================
/**
 * Real Copy Trading Test - 真实下单测试
 *
 * ⚠️ 警告：这会执行真实交易！
 *
 * 运行：pnpm exec tsx scripts/smart-money/06-real-copy-test.ts
 */

import 'dotenv/config';
import { PolymarketSDK } from '../../src/index.js';

// ⚠️ 真实交易配置
const DRY_RUN = false;  // 真实交易！
const TOP_N = 50;
const SIZE_SCALE = 0.05;  // 跟 5% (确保 >= $1 最小订单)
const MAX_SIZE_PER_TRADE = 5;  // 最多 $5
const RUN_DURATION_MS = 60 * 1000; // 1 分钟

async function main() {
  console.log('='.repeat(60));
  console.log('🔴 REAL COPY TRADING TEST - 真实交易测试');
  console.log('='.repeat(60));
  console.log(`Size Scale: ${SIZE_SCALE * 100}%`);
  console.log(`Max per trade: $${MAX_SIZE_PER_TRADE}`);
  console.log(`Duration: ${RUN_DURATION_MS / 1000}s`);
  console.log('='.repeat(60));

  const privateKey = process.env.PRIVATE_KEY || process.env.POLY_PRIVATE_KEY;
  if (!privateKey) {
    console.error('❌ PRIVATE_KEY not found');
    process.exit(1);
  }

  // 使用静态工厂方法一步启动（推荐）
  console.log('\n[Init] 初始化 SDK...');
  const sdk = await PolymarketSDK.create({ privateKey });
  console.log('  ✅ SDK ready (initialized + WebSocket connected)');

  const subscription = await sdk.smartMoney.startAutoCopyTrading({
    topN: TOP_N,
    sizeScale: SIZE_SCALE,
    maxSizePerTrade: MAX_SIZE_PER_TRADE,
    maxSlippage: 0.05,  // 5% slippage for real trades
    orderType: 'FOK',
    minTradeSize: 5,
    dryRun: DRY_RUN,
    onTrade: (trade, result) => {
      const status = result.success ? '✅ SUCCESS' : '❌ FAILED';
      console.log(`\n${status}`);
      console.log(`  Trader: ${trade.traderName || trade.traderAddress.slice(0, 10)}...`);
      console.log(`  Market: ${trade.marketSlug}`);
      console.log(`  ${trade.side} ${trade.outcome} @ $${trade.price.toFixed(4)}`);
      if (result.orderId) console.log(`  OrderId: ${result.orderId}`);
      if (result.errorMsg) console.log(`  Error: ${result.errorMsg}`);
    },
    onError: (error) => {
      console.error('\n❌ Error:', error.message);
    },
  });

  console.log(`\n✅ 跟踪 ${subscription.targetAddresses.length} 个钱包`);
  console.log('⏳ 监听中... (真实交易模式)\n');

  // Run for duration
  await new Promise(resolve => setTimeout(resolve, RUN_DURATION_MS));

  // Stats
  const stats = subscription.getStats();
  console.log('\n' + '='.repeat(60));
  console.log('📊 运行统计');
  console.log('='.repeat(60));
  console.log(`  检测交易: ${stats.tradesDetected}`);
  console.log(`  执行跟单: ${stats.tradesExecuted}`);
  console.log(`  跳过交易: ${stats.tradesSkipped}`);
  console.log(`  失败交易: ${stats.tradesFailed}`);
  console.log(`  总花费: $${stats.totalUsdcSpent.toFixed(2)}`);

  subscription.stop();
  sdk.stop();

  console.log('\n✅ Done');
}

main().catch(console.error);

================================================================================
// File: scripts/trading/check-orders.ts
================================================================================
/**
 * 检查 Polymarket 真实订单
 */

import { TradingService, RateLimiter, createUnifiedCache } from '../../src/index.js';

async function main() {
  const privateKey = process.env.POLY_PRIVKEY || process.env.PRIVATE_KEY;
  if (!privateKey) {
    console.error('❌ 没有配置私钥');
    process.exit(1);
  }

  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const client = new TradingService(rateLimiter, cache, { privateKey });

  console.log('⏳ 初始化...');
  await client.initialize();
  console.log(`✅ 钱包: ${client.getAddress()}`);

  // 检查 USDC 余额
  console.log('\n📊 余额:');
  const balance = await client.getBalanceAllowance('COLLATERAL');
  console.log(`   USDC: $${(Number(balance.balance) / 1e6).toFixed(2)}`);
  console.log(`   Allowance: $${(Number(balance.allowance) / 1e6).toFixed(2)}`);

  // 检查未完成订单
  console.log('\n📋 Open Orders:');
  const orders = await client.getOpenOrders();
  if (orders.length === 0) {
    console.log('   (无)');
  } else {
    for (const order of orders) {
      console.log(`   ${order.id}: ${order.side} ${order.remainingSize}@${order.price} (${order.status})`);
    }
  }

  // 检查最近交易
  console.log('\n💰 Recent Trades:');
  const trades = await client.getTrades();
  if (trades.length === 0) {
    console.log('   (无)');
  } else {
    for (const trade of trades.slice(0, 10)) {
      console.log(`   ${trade.id}: ${trade.side} ${trade.size}@${trade.price} (fee: ${trade.fee})`);
    }
  }
}

main().catch(console.error);

================================================================================
// File: scripts/trading/test-order.ts
================================================================================
#!/usr/bin/env npx tsx
/**
 * Test Order Script - 测试下单功能
 *
 * 测试 GTC 限价单 vs FOK 市价单的区别
 *
 * Usage:
 *   POLY_PRIVKEY=0x... npx tsx scripts/trading/test-order.ts
 */

import { TradingService, RateLimiter, createUnifiedCache } from '../../src/index.js';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read private key from dashboard-api .env
const envPath = path.resolve(__dirname, '../../earning-engine/dashboard-api/.env');
const envContent = fs.readFileSync(envPath, 'utf8');
const match = envContent.match(/^PRIVATE_KEY=(.+)$/m);
const PRIVATE_KEY = process.env.POLY_PRIVKEY || (match ? match[1].trim() : '');

// 使用一个活跃的市场进行测试 - NVIDIA market cap
const TEST_MARKET = {
  name: 'NVIDIA largest company by market cap on Dec 31',
  conditionId: '0x0b16eb7741855ca3d4383fabb8b760c897c2165d603916497f484b87ba9826dc',
  yesTokenId: '94850533403292240972948844256810904078895883844462287088135166537739765648754',
  noTokenId: '69263280792958981516606123639467754139758192236863611059536531765186180114584',
};

const TEST_AMOUNT = 5; // 5 USDC 测试 (Polymarket 最小订单量是 5 份)

async function main() {
  if (!PRIVATE_KEY) {
    console.error('Error: Set POLY_PRIVKEY environment variable');
    process.exit(1);
  }

  console.log('╔════════════════════════════════════════════════════════════════╗');
  console.log('║       ORDER TYPE TEST - GTC vs FOK                              ║');
  console.log('╚════════════════════════════════════════════════════════════════╝');
  console.log('');
  console.log(`Market: ${TEST_MARKET.name}`);
  console.log(`Test Amount: $${TEST_AMOUNT} USDC`);
  console.log('');

  const rateLimiter = new RateLimiter();
  const cache = createUnifiedCache();
  const tradingService = new TradingService(rateLimiter, cache, {
    privateKey: PRIVATE_KEY,
    chainId: 137,
  });

  await tradingService.initialize();
  console.log(`Wallet: ${tradingService.getAddress()}`);

  // 获取当前余额
  const { balance, allowance } = await tradingService.getBalanceAllowance('COLLATERAL');
  console.log(`USDC Balance: ${(parseFloat(balance) / 1e6).toFixed(2)} USDC`);
  console.log(`Allowance: ${allowance === 'unlimited' || parseFloat(allowance) / 1e6 > 1e12 ? 'Unlimited' : (parseFloat(allowance) / 1e6).toFixed(2)}`);
  console.log('');

  // 获取当前市场价格
  const orderbook = await tradingService.getProcessedOrderbook(TEST_MARKET.yesTokenId);
  const bestBid = orderbook.bids[0]?.price || 0;
  const bestAsk = orderbook.asks[0]?.price || 1;
  console.log(`Current YES price: ${bestBid.toFixed(3)} / ${bestAsk.toFixed(3)}`);
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // TEST 1: GTC Limit Order (这是 Earning Engine 使用的方式)
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('TEST 1: GTC Limit Order (Earning Engine 方式)');
  console.log('═══════════════════════════════════════════════════════════════');

  // 尝试以低于市价的价格买入 (maker order)
  const gtcBuyPrice = Math.max(0.01, bestBid - 0.05); // 低于最佳买价 5 cents
  const gtcSize = Math.max(5, TEST_AMOUNT / gtcBuyPrice); // 最小 5 份

  console.log(`Placing GTC BUY order: ${gtcSize.toFixed(2)} shares @ $${gtcBuyPrice.toFixed(3)}`);
  console.log(`Expected cost: $${(gtcSize * gtcBuyPrice).toFixed(2)}`);

  try {
    const gtcResult = await tradingService.createOrder({
      tokenId: TEST_MARKET.yesTokenId,
      side: 'BUY',
      price: gtcBuyPrice,
      size: gtcSize,
      orderType: 'GTC',
    });

    if (gtcResult.success) {
      console.log(`✅ GTC Order SUCCESS!`);
      console.log(`   Order ID: ${gtcResult.orderId}`);

      // 立即取消订单
      console.log('   Cancelling order...');
      const cancelResult = await tradingService.cancelOrder(gtcResult.orderId!);
      console.log(`   Cancel: ${cancelResult.success ? '✓' : '✗'}`);
    } else {
      console.log(`❌ GTC Order FAILED: ${gtcResult.errorMsg}`);
    }
  } catch (error: any) {
    console.log(`❌ GTC Order ERROR: ${error.message}`);
  }

  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // TEST 2: FOK Market Order (这是套利脚本使用的方式)
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('TEST 2: FOK Market Order (套利脚本方式)');
  console.log('═══════════════════════════════════════════════════════════════');

  console.log(`Placing FOK BUY order: $${TEST_AMOUNT} USDC worth`);

  try {
    const fokResult = await tradingService.createMarketOrder({
      tokenId: TEST_MARKET.yesTokenId,
      side: 'BUY',
      amount: TEST_AMOUNT,
      orderType: 'FOK',
    });

    if (fokResult.success) {
      console.log(`✅ FOK Order SUCCESS!`);
      console.log(`   Order ID: ${fokResult.orderId}`);

      // 等待一下让订单成交
      await new Promise((r) => setTimeout(r, 2000));

      // 检查持仓并卖出
      console.log('   Selling back...');
      const sellResult = await tradingService.createMarketOrder({
        tokenId: TEST_MARKET.yesTokenId,
        side: 'SELL',
        amount: TEST_AMOUNT * 0.95, // 卖出略少一点确保成功
        orderType: 'FOK',
      });
      console.log(`   Sell: ${sellResult.success ? '✓' : '✗'} ${sellResult.errorMsg || ''}`);
    } else {
      console.log(`❌ FOK Order FAILED: ${fokResult.errorMsg}`);
    }
  } catch (error: any) {
    console.log(`❌ FOK Order ERROR: ${error.message}`);
  }

  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // SUMMARY
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('SUMMARY');
  console.log('═══════════════════════════════════════════════════════════════');
  console.log('');
  console.log('如果 GTC 失败但 FOK 成功，说明:');
  console.log('  - Polymarket 对 GTC 限价单有不同的余额要求');
  console.log('  - 可能需要通过 Polymarket UI 存入资金');
  console.log('  - 或者 Earning Engine 应该改用 FOK 市价单');
  console.log('');
  console.log('如果两个都失败，说明:');
  console.log('  - 钱包配置可能有问题');
  console.log('  - 需要检查 API Key 或签名');
  console.log('');
}

main().catch(console.error);

================================================================================
// File: scripts/verify/test-approve-trading.ts
================================================================================
/**
 * Test Approve Trading
 *
 * Approve all required contracts for trading on Polymarket.
 * This will send real transactions!
 *
 * Usage:
 *   PRIVATE_KEY=0x... npx tsx scripts/test-approve-trading.ts
 */

import { ethers } from 'ethers';
import dotenv from 'dotenv';
import { AuthorizationService } from '../src/index.js';

dotenv.config();

const PRIVATE_KEY = process.env.POLY_PRIVATE_KEY || process.env.PRIVATE_KEY;

if (!PRIVATE_KEY) {
  console.error('❌ Error: No private key found.');
  process.exit(1);
}

const POLYGON_RPC = 'https://polygon-rpc.com';

async function main() {
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║           APPROVE TRADING TEST                             ║');
  console.log('╚════════════════════════════════════════════════════════════╝\n');

  const provider = new ethers.providers.JsonRpcProvider(POLYGON_RPC);
  const signer = new ethers.Wallet(PRIVATE_KEY, provider);

  console.log(`Wallet: ${signer.address}`);

  // Check current balance for gas
  const balance = await provider.getBalance(signer.address);
  const maticBalance = ethers.utils.formatEther(balance);
  console.log(`MATIC Balance: ${maticBalance}\n`);

  if (parseFloat(maticBalance) < 0.1) {
    console.error('❌ Insufficient MATIC for gas. Need at least 0.1 MATIC');
    process.exit(1);
  }

  const authService = new AuthorizationService(signer);

  // Check current state
  console.log('Checking current allowances...');
  const before = await authService.checkAllowances();
  console.log(`Trading Ready: ${before.tradingReady ? '✅' : '❌'}\n`);

  if (before.tradingReady) {
    console.log('✅ Already ready for trading. No approvals needed.');
    return;
  }

  // Approve all
  console.log('Approving all contracts...\n');

  try {
    const result = await authService.approveAll();

    console.log('Results:');
    console.log(`  Wallet: ${result.wallet}`);
    console.log(`  All Approved: ${result.allApproved ? '✅' : '❌'}`);

    console.log('\n  ERC20 Approvals:');
    for (const approval of result.erc20Approvals) {
      const status = approval.success ? '✅' : '❌';
      console.log(`    ${status} ${approval.contract}`);
      if (approval.txHash) {
        console.log(`       TX: https://polygonscan.com/tx/${approval.txHash}`);
      }
      if (approval.error) {
        console.log(`       Error: ${approval.error}`);
      }
    }

    console.log('\n  ERC1155 Approvals:');
    for (const approval of result.erc1155Approvals) {
      const status = approval.success ? '✅' : '❌';
      console.log(`    ${status} ${approval.contract}`);
      if (approval.txHash) {
        console.log(`       TX: https://polygonscan.com/tx/${approval.txHash}`);
      }
      if (approval.error) {
        console.log(`       Error: ${approval.error}`);
      }
    }

    console.log(`\n${result.summary}`);
  } catch (err) {
    console.error(`\n❌ Error: ${err instanceof Error ? err.message : err}`);
  }
}

main().catch(console.error);

================================================================================
// File: scripts/verify/test-provider-fix.ts
================================================================================
/**
 * Verify provider fix for SwapService
 * This script tests that the provider initialization works correctly
 */

import { ethers } from 'ethers';

// Test that signer without provider works after fix
async function testProviderFix() {
  console.log('Testing provider fix...\n');

  // Simulate a signer without provider (like what SDK returns)
  const privateKey = process.env.POLY_PRIVATE_KEY;
  if (!privateKey) {
    console.error('POLY_PRIVATE_KEY not set');
    process.exit(1);
  }

  // Create signer WITHOUT provider (simulates SDK issue)
  const signerNoProvider = new ethers.Wallet(privateKey);
  console.log('1. Created signer without provider:');
  console.log('   - Address:', signerNoProvider.address);
  console.log('   - Has provider:', !!signerNoProvider.provider);

  // Apply the fix: connect to provider if missing
  const provider = new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
  const signer = signerNoProvider.provider ? signerNoProvider : signerNoProvider.connect(provider);
  
  console.log('\n2. After fix:');
  console.log('   - Has provider:', !!signer.provider);

  // Test that provider works
  try {
    const balance = await signer.provider!.getBalance(signer.address);
    console.log('   - MATIC balance:', ethers.utils.formatEther(balance));
    console.log('\n✅ Provider fix working correctly!');
  } catch (err) {
    console.error('\n❌ Provider still not working:', err);
    process.exit(1);
  }
}

testProviderFix().catch(console.error);

================================================================================
// File: scripts/verify/test-search-mcp.ts
================================================================================
/**
 * Test Search Markets MCP Tool
 *
 * Verify the improved search functionality.
 */

import { PolymarketSDK } from '../src/index.js';
import { createMcpHandler } from '../src/mcp/index.js';

async function main() {
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║           TEST: search_markets MCP TOOL                    ║');
  console.log('╚════════════════════════════════════════════════════════════╝\n');

  const sdk = new PolymarketSDK();
  const handler = createMcpHandler(sdk);

  // Test 1: Search for "bitcoin"
  console.log('--- Test 1: Search for "bitcoin" ---');
  try {
    const result = await handler('search_markets', {
      query: 'bitcoin',
      limit: 5,
    });

    console.log('Results:');
    const data = result as { markets: Array<{ question: string; volume24h: number }>; total: number };
    data.markets.forEach((m, i) => {
      console.log(`  ${i + 1}. ${m.question}`);
      console.log(`     24h Volume: $${m.volume24h?.toLocaleString() || 'N/A'}`);
    });
    console.log(`\nTotal matches: ${data.total}`);
  } catch (err) {
    console.log(`Error: ${err}`);
  }

  // Test 2: Search for "trump"
  console.log('\n--- Test 2: Search for "trump" ---');
  try {
    const result = await handler('search_markets', {
      query: 'trump',
      limit: 5,
    });

    const data = result as { markets: Array<{ question: string; volume24h: number }>; total: number };
    data.markets.forEach((m, i) => {
      console.log(`  ${i + 1}. ${m.question}`);
      console.log(`     24h Volume: $${m.volume24h?.toLocaleString() || 'N/A'}`);
    });
    console.log(`\nTotal matches: ${data.total}`);
  } catch (err) {
    console.log(`Error: ${err}`);
  }

  // Test 3: Search with category filter
  console.log('\n--- Test 3: Search "price" with Crypto category ---');
  try {
    const result = await handler('search_markets', {
      query: 'price',
      category: 'Crypto',
      limit: 5,
    });

    const data = result as { markets: Array<{ question: string; volume24h: number }>; total: number };
    data.markets.forEach((m, i) => {
      console.log(`  ${i + 1}. ${m.question}`);
    });
    console.log(`\nTotal matches: ${data.total}`);
  } catch (err) {
    console.log(`Error: ${err}`);
  }

  // Test 4: Multi-word search
  console.log('\n--- Test 4: Multi-word search "fed interest rate" ---');
  try {
    const result = await handler('search_markets', {
      query: 'fed interest rate',
      limit: 5,
    });

    const data = result as { markets: Array<{ question: string; volume24h: number }>; total: number };
    data.markets.forEach((m, i) => {
      console.log(`  ${i + 1}. ${m.question}`);
      console.log(`     24h Volume: $${m.volume24h?.toLocaleString() || 'N/A'}`);
    });
    console.log(`\nTotal matches: ${data.total}`);
  } catch (err) {
    console.log(`Error: ${err}`);
  }

  // Test 5: Trending markets
  console.log('\n--- Test 5: Trending markets (for comparison) ---');
  try {
    const result = await handler('get_trending_markets', {
      limit: 5,
      sortBy: 'volume',
    });

    const data = result as { markets: Array<{ question: string; volume24h: number }> };
    data.markets.forEach((m, i) => {
      console.log(`  ${i + 1}. ${m.question}`);
      console.log(`     24h Volume: $${m.volume24h?.toLocaleString() || 'N/A'}`);
    });
  } catch (err) {
    console.log(`Error: ${err}`);
  }

  console.log('\n' + '═'.repeat(60));
  console.log('TEST COMPLETE');
  console.log('═'.repeat(60));
}

main().catch(console.error);

================================================================================
// File: scripts/verify/verify-all-apis.ts
================================================================================
/**
 * Verify all Polymarket API responses against SDK type definitions
 *
 * Run: pnpm -F @catalyst-team/poly-sdk tsx scripts/verify-all-apis.ts
 */

const DATA_API = 'https://data-api.polymarket.com';
const GAMMA_API = 'https://gamma-api.polymarket.com';
const CLOB_API = 'https://clob.polymarket.com';

// Known active wallet for testing
const TEST_WALLET = '0x1c579085b4dcdf00f0ce6f2d8c1d402fec0f1632';

interface FieldAnalysis {
  field: string;
  type: string;
  sample: unknown;
  isNull: boolean;
}

function analyzeFields(obj: Record<string, unknown>, prefix = ''): FieldAnalysis[] {
  const results: FieldAnalysis[] = [];
  for (const [key, value] of Object.entries(obj)) {
    const fieldPath = prefix ? `${prefix}.${key}` : key;
    const type = value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value;
    results.push({
      field: fieldPath,
      type,
      sample: type === 'object' ? '[object]' : type === 'array' ? `[${(value as unknown[]).length} items]` : value,
      isNull: value === null,
    });
    if (type === 'object' && value !== null) {
      results.push(...analyzeFields(value as Record<string, unknown>, fieldPath));
    }
  }
  return results;
}

async function fetchAndAnalyze(name: string, url: string, extractFirst = true) {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`API: ${name}`);
  console.log(`URL: ${url}`);
  console.log('='.repeat(60));

  try {
    const response = await fetch(url);
    if (!response.ok) {
      console.log(`ERROR: ${response.status} ${response.statusText}`);
      return null;
    }

    const data = await response.json();
    const sample = extractFirst && Array.isArray(data) ? data[0] : data;

    if (!sample) {
      console.log('No data returned');
      return null;
    }

    console.log('\nRaw Response Sample:');
    console.log(JSON.stringify(sample, null, 2));

    console.log('\nField Analysis:');
    const fields = analyzeFields(sample as Record<string, unknown>);
    for (const f of fields) {
      const nullMarker = f.isNull ? ' [NULL]' : '';
      console.log(`  ${f.field}: ${f.type}${nullMarker}`);
    }

    return sample;
  } catch (error) {
    console.log(`ERROR: ${error}`);
    return null;
  }
}

async function main() {
  console.log('Polymarket API Verification Script');
  console.log('===================================\n');

  // ===== DATA API =====
  console.log('\n' + '#'.repeat(60));
  console.log('# DATA API');
  console.log('#'.repeat(60));

  // Positions
  await fetchAndAnalyze(
    'Positions',
    `${DATA_API}/positions?user=${TEST_WALLET}`
  );

  // Activity
  await fetchAndAnalyze(
    'Activity',
    `${DATA_API}/activity?user=${TEST_WALLET}&limit=1`
  );

  // Trades
  await fetchAndAnalyze(
    'Trades',
    `${DATA_API}/trades?limit=1`
  );

  // Leaderboard
  await fetchAndAnalyze(
    'Leaderboard',
    `${DATA_API}/v1/leaderboard?limit=1`
  );

  // ===== GAMMA API =====
  console.log('\n' + '#'.repeat(60));
  console.log('# GAMMA API');
  console.log('#'.repeat(60));

  // Markets
  const market = await fetchAndAnalyze(
    'Markets',
    `${GAMMA_API}/markets?active=true&limit=1`
  );

  // Events
  await fetchAndAnalyze(
    'Events',
    `${GAMMA_API}/events?active=true&limit=1`
  );

  // ===== CLOB API =====
  console.log('\n' + '#'.repeat(60));
  console.log('# CLOB API');
  console.log('#'.repeat(60));

  // Get a conditionId from gamma market
  const conditionId = (market as Record<string, unknown>)?.conditionId;
  if (conditionId) {
    // Market
    const clobMarket = await fetchAndAnalyze(
      'CLOB Market',
      `${CLOB_API}/markets/${conditionId}`,
      false
    );

    // Orderbook
    const tokens = (clobMarket as Record<string, unknown>)?.tokens as Array<{ token_id: string }>;
    if (tokens?.[0]) {
      await fetchAndAnalyze(
        'Orderbook',
        `${CLOB_API}/book?token_id=${tokens[0].token_id}`,
        false
      );
    }
  }

  // ===== SUMMARY =====
  console.log('\n' + '#'.repeat(60));
  console.log('# VERIFICATION COMPLETE');
  console.log('#'.repeat(60));
  console.log('\nReview the output above to compare with SDK type definitions.');
}

main().catch(console.error);

================================================================================
// File: scripts/wallet/check-wallet-balances.ts
================================================================================
/**
 * Check Wallet Balances Script
 *
 * Query token balances for any wallet address on Polygon.
 * No private key required - just provide an address.
 *
 * Usage:
 *   npx tsx scripts/check-wallet-balances.ts <address>
 *   npx tsx scripts/check-wallet-balances.ts 0xc2e7800b5af46e6093872b177b7a5e7f0563be51
 */

import { SwapService, POLYGON_TOKENS } from '../src/index.js';

const TEST_ADDRESS = '0xc2e7800b5af46e6093872b177b7a5e7f0563be51'; // Top Polymarket trader

async function main() {
  const address = process.argv[2] || TEST_ADDRESS;

  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║          POLYGON WALLET BALANCE CHECKER                     ║');
  console.log('╚════════════════════════════════════════════════════════════╝');
  console.log('');
  console.log(`Wallet: ${address}`);
  console.log('');

  console.log('Fetching balances...');
  console.log('');

  try {
    const balances = await SwapService.getWalletBalances(address);

    console.log('─── Token Balances ───');
    console.log('');

    for (const b of balances) {
      const amount = parseFloat(b.balance);
      if (amount > 0) {
        console.log(`  ${b.symbol.padEnd(10)} ${b.balance}`);
      }
    }

    // Show zero balances
    const zeroBalances = balances.filter((b) => parseFloat(b.balance) === 0);
    if (zeroBalances.length > 0) {
      console.log('');
      console.log(`  (Zero balance: ${zeroBalances.map((b) => b.symbol).join(', ')})`);
    }

    // Summary
    console.log('');
    console.log('─── Summary ───');
    const nonZero = balances.filter((b) => parseFloat(b.balance) > 0);
    console.log(`  Tokens with balance: ${nonZero.length}`);

    // Calculate stablecoin value
    let stablecoinValue = 0;
    for (const b of balances) {
      if (['USDC', 'USDC_E', 'USDT', 'DAI'].includes(b.token)) {
        stablecoinValue += parseFloat(b.balance);
      }
    }
    console.log(`  Stablecoin value: $${stablecoinValue.toFixed(2)}`);

    console.log('');
    console.log('─── Supported Tokens ───');
    console.log(`  ${Object.keys(POLYGON_TOKENS).join(', ')}`);

  } catch (err) {
    console.error(`Error: ${err instanceof Error ? err.message : err}`);
  }

  console.log('');
}

main().catch(console.error);

================================================================================
// File: scripts/wallet/test-wallet-operations.ts
================================================================================
/**
 * Test Wallet Operations
 *
 * Comprehensive test for all wallet-related operations that require a private key:
 * - Token balances
 * - Allowance checking
 * - Token approvals
 * - Swap operations (dry run)
 *
 * Usage:
 *   POLY_PRIVATE_KEY=0x... npx tsx scripts/test-wallet-operations.ts
 *   Or set PRIVATE_KEY in .env file
 */

import { ethers } from 'ethers';
import dotenv from 'dotenv';
import {
  SwapService,
  AuthorizationService,
  POLYGON_TOKENS,
} from '../src/index.js';

dotenv.config();

const PRIVATE_KEY = process.env.POLY_PRIVATE_KEY || process.env.PRIVATE_KEY;

if (!PRIVATE_KEY) {
  console.error('❌ Error: No private key found.');
  console.error('   Set POLY_PRIVATE_KEY or PRIVATE_KEY in environment or .env file');
  process.exit(1);
}

const POLYGON_RPC = 'https://polygon-rpc.com';

async function main() {
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║           POLY-SDK WALLET OPERATIONS TEST                  ║');
  console.log('╚════════════════════════════════════════════════════════════╝\n');

  // Initialize
  const provider = new ethers.providers.JsonRpcProvider(POLYGON_RPC);
  const signer = new ethers.Wallet(PRIVATE_KEY, provider);

  console.log(`Wallet Address: ${signer.address}`);
  console.log(`Network: Polygon Mainnet (${POLYGON_RPC})`);
  console.log('');

  // Test 1: Get native MATIC balance
  console.log('═══════════════════════════════════════════════════════════');
  console.log('Test 1: Native MATIC Balance');
  console.log('═══════════════════════════════════════════════════════════');
  try {
    const maticBalance = await provider.getBalance(signer.address);
    const maticFormatted = ethers.utils.formatEther(maticBalance);
    console.log(`  MATIC Balance: ${maticFormatted} MATIC`);

    if (parseFloat(maticFormatted) < 0.01) {
      console.log('  ⚠️  Warning: Low MATIC balance. Need MATIC for gas fees.');
    } else {
      console.log('  ✅ Sufficient MATIC for gas');
    }
  } catch (err) {
    console.log(`  ❌ Error: ${err instanceof Error ? err.message : err}`);
  }

  // Test 2: Get all token balances using SwapService
  console.log('\n═══════════════════════════════════════════════════════════');
  console.log('Test 2: Token Balances (SwapService.getBalances)');
  console.log('═══════════════════════════════════════════════════════════');
  try {
    const swapService = new SwapService(signer);
    const balances = await swapService.getBalances();

    console.log('  Token Balances:');
    for (const b of balances) {
      const amount = parseFloat(b.balance);
      const status = amount > 0 ? '✅' : '  ';
      console.log(`    ${status} ${b.symbol.padEnd(8)} ${b.balance}`);
    }

    // Calculate total stablecoin value
    let stablecoinValue = 0;
    for (const b of balances) {
      if (['USDC', 'USDC_E', 'USDT', 'DAI'].includes(b.token)) {
        stablecoinValue += parseFloat(b.balance);
      }
    }
    console.log(`\n  Total Stablecoin Value: $${stablecoinValue.toFixed(2)}`);
  } catch (err) {
    console.log(`  ❌ Error: ${err instanceof Error ? err.message : err}`);
  }

  // Test 3: Check allowances using AuthorizationService
  console.log('\n═══════════════════════════════════════════════════════════');
  console.log('Test 3: Trading Allowances (AuthorizationService)');
  console.log('═══════════════════════════════════════════════════════════');
  try {
    const authService = new AuthorizationService(signer);
    const result = await authService.checkAllowances();

    console.log(`  Wallet: ${result.wallet}`);
    console.log(`  USDC Balance: ${result.usdcBalance}`);
    console.log(`  Trading Ready: ${result.tradingReady ? '✅ Yes' : '❌ No'}`);

    console.log('\n  ERC20 Allowances:');
    for (const allowance of result.erc20Allowances) {
      const status = allowance.approved ? '✅' : '❌';
      console.log(`    ${status} ${allowance.contract}: ${allowance.allowance}`);
    }

    console.log('\n  ERC1155 Approvals:');
    for (const approval of result.erc1155Approvals) {
      const status = approval.approved ? '✅' : '❌';
      console.log(`    ${status} ${approval.contract}`);
    }

    if (result.issues.length > 0) {
      console.log('\n  Issues:');
      for (const issue of result.issues) {
        console.log(`    ⚠️  ${issue}`);
      }
    }
  } catch (err) {
    console.log(`  ❌ Error: ${err instanceof Error ? err.message : err}`);
  }

  // Test 4: Swap Quote (without executing)
  console.log('\n═══════════════════════════════════════════════════════════');
  console.log('Test 4: Swap Service (Quote Only - No Execution)');
  console.log('═══════════════════════════════════════════════════════════');
  try {
    const swapService = new SwapService(signer);

    // Check if we have any tokens to get a quote for
    const balances = await swapService.getBalances();
    const maticBalance = balances.find((b) => b.token === 'MATIC');
    const usdcBalance = balances.find((b) => b.token === 'USDC');

    if (maticBalance && parseFloat(maticBalance.balance) > 1) {
      console.log('  Checking swap quote: 1 MATIC -> USDC');
      // Note: We're not executing, just confirming the service initializes correctly
      console.log('  ✅ SwapService initialized successfully');
      console.log(`  Router: ${POLYGON_TOKENS.WMATIC} (WMATIC)`);
      console.log(`  Can swap: MATIC, WMATIC, USDC, USDC_E, USDT, DAI, WETH`);
    } else {
      console.log('  ℹ️  Insufficient MATIC balance for swap test');
      console.log('  ✅ SwapService initialized successfully');
    }
  } catch (err) {
    console.log(`  ❌ Error: ${err instanceof Error ? err.message : err}`);
  }

  // Test 5: Static wallet query (no signer needed)
  console.log('\n═══════════════════════════════════════════════════════════');
  console.log('Test 5: Static Wallet Query (Any Address)');
  console.log('═══════════════════════════════════════════════════════════');
  try {
    // Query a known top trader
    const topTrader = '0xc2e7800b5af46e6093872b177b7a5e7f0563be51';
    console.log(`  Querying wallet: ${topTrader}`);

    const balances = await SwapService.getWalletBalances(topTrader);
    const nonZero = balances.filter((b) => parseFloat(b.balance) > 0);

    console.log('  Balances:');
    for (const b of nonZero) {
      console.log(`    ${b.symbol.padEnd(8)} ${parseFloat(b.balance).toLocaleString()}`);
    }
    console.log('  ✅ Static query works without signer');
  } catch (err) {
    console.log(`  ❌ Error: ${err instanceof Error ? err.message : err}`);
  }

  // Summary
  console.log('\n═══════════════════════════════════════════════════════════');
  console.log('SUMMARY');
  console.log('═══════════════════════════════════════════════════════════');
  console.log(`
  ✅ Token balance queries work
  ✅ Allowance checking works
  ✅ SwapService initializes correctly
  ✅ Static wallet queries work

  To test actual transactions:
  - Use approve-trading if allowances are missing
  - Use swap if you want to exchange tokens
  - Use deposit if you want to deposit to Polymarket
  `);
}

main().catch(console.error);

================================================================================
// File: scripts/wallet/verify-wallet-tools.ts
================================================================================
/**
 * Verify Wallet Tools Implementation
 *
 * This script tests the wallet-related SDK and MCP tools:
 * 1. BridgeClient.getSupportedAssets() - Get supported deposit assets
 * 2. BridgeClient.createDepositAddresses() - Get deposit addresses
 * 3. AuthorizationService.checkAllowances() - Check allowances
 *
 * Usage:
 *   npx tsx scripts/verify-wallet-tools.ts
 *   POLY_PRIVKEY=0x... npx tsx scripts/verify-wallet-tools.ts
 */

import { Wallet, providers } from 'ethers';
import { BridgeClient, AuthorizationService } from '../src/index.js';

const PRIVATE_KEY = process.env.POLY_PRIVKEY || process.env.POLY_PRIVATE_KEY;
const RPC_URL = 'https://polygon-rpc.com';

async function main() {
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║          WALLET TOOLS VERIFICATION                          ║');
  console.log('╚════════════════════════════════════════════════════════════╝');
  console.log('');

  // Test 1: Get Supported Assets
  console.log('─── Test 1: BridgeClient.getSupportedAssets() ───');
  try {
    const bridge = new BridgeClient();
    const assets = await bridge.getSupportedAssets();
    console.log(`✅ Found ${assets.length} supported assets`);

    // Group by chain
    const chains = new Set<string>();
    for (const asset of assets) {
      chains.add(asset.chainName);
    }
    console.log(`   Chains: ${Array.from(chains).join(', ')}`);

    // Show first 3 assets as sample
    console.log('   Sample assets:');
    for (const asset of assets.slice(0, 3)) {
      console.log(`   - ${asset.chainName} ${asset.tokenSymbol}: min $${asset.minDepositUsd}`);
    }
  } catch (err) {
    console.log(`❌ Error: ${err instanceof Error ? err.message : err}`);
  }
  console.log('');

  // Test 2: Get Deposit Addresses (requires address, not private key)
  console.log('─── Test 2: BridgeClient.createDepositAddresses() ───');
  try {
    const bridge = new BridgeClient();
    // Use a test address
    const testAddress = '0xc2e7800b5af46e6093872b177b7a5e7f0563be51';
    const result = await bridge.createDepositAddresses(testAddress);
    console.log(`✅ Got deposit addresses for ${testAddress.slice(0, 10)}...`);
    console.log(`   EVM: ${result.address.evm.slice(0, 20)}...`);
    console.log(`   Solana: ${result.address.svm.slice(0, 20)}...`);
    console.log(`   Bitcoin: ${result.address.btc.slice(0, 20)}...`);
  } catch (err) {
    console.log(`❌ Error: ${err instanceof Error ? err.message : err}`);
  }
  console.log('');

  // Test 3: Check Allowances (requires private key)
  console.log('─── Test 3: AuthorizationService.checkAllowances() ───');
  if (!PRIVATE_KEY) {
    console.log('⚠️  Skipped: Set POLY_PRIVKEY to test allowance checking');
  } else {
    try {
      const provider = new providers.JsonRpcProvider(RPC_URL);
      const wallet = new Wallet(PRIVATE_KEY, provider);
      console.log(`   Wallet: ${wallet.address}`);

      const authService = new AuthorizationService(wallet);
      const result = await authService.checkAllowances();

      console.log(`✅ Allowance check completed`);
      console.log(`   USDC Balance: ${result.usdcBalance}`);
      console.log(`   Trading Ready: ${result.tradingReady ? '✅ Yes' : '❌ No'}`);

      if (result.issues.length > 0) {
        console.log('   Issues:');
        for (const issue of result.issues) {
          console.log(`   - ${issue}`);
        }
      }

      console.log('   ERC20 Allowances:');
      for (const a of result.erc20Allowances) {
        console.log(`   - ${a.contract}: ${a.approved ? '✅' : '❌'} (${a.allowance || 'N/A'})`);
      }

      console.log('   ERC1155 Approvals:');
      for (const a of result.erc1155Approvals) {
        console.log(`   - ${a.contract}: ${a.approved ? '✅' : '❌'}`);
      }
    } catch (err) {
      console.log(`❌ Error: ${err instanceof Error ? err.message : err}`);
    }
  }
  console.log('');

  console.log('═══════════════════════════════════════════════════════════');
  console.log('Verification complete.');
  console.log('');
  console.log('Architecture:');
  console.log('  SDK Layer:');
  console.log('    - BridgeClient.getSupportedAssets()');
  console.log('    - BridgeClient.createDepositAddresses()');
  console.log('    - depositUsdc() function');
  console.log('    - AuthorizationService.checkAllowances()');
  console.log('    - AuthorizationService.approveAll()');
  console.log('');
  console.log('  MCP Tools (call SDK):');
  console.log('    - get_supported_deposit_assets → BridgeClient');
  console.log('    - get_deposit_addresses → BridgeClient');
  console.log('    - deposit_usdc → depositUsdc()');
  console.log('    - check_allowances → AuthorizationService');
  console.log('    - approve_trading → AuthorizationService');
}

main().catch(console.error);

================================================================================
// File: sell2.mjs
================================================================================
import { TradingService, RateLimiter, createUnifiedCache } from './dist/index.js';
import { config } from 'dotenv';
config({ path: '../.env' });

const pk = process.env.POLY_PRIVKEY;
console.log('Using wallet:', pk ? pk.slice(0,6) + '...' : 'none');

const rl = new RateLimiter();
const cache = createUnifiedCache();
const t = new TradingService(rl, cache, { privateKey: pk });
await t.initialize();

console.log('Selling 6 Down @ 0.85...');
try {
  const r1 = await t.placeOrder({ tokenId: '110083725719357051319612248159302825704980332180179347898947550019023847291360', side: 'SELL', price: 0.85, size: 6, orderType: 'FOK' });
  console.log('Down:', r1.status);
} catch(e) { console.log('Down err:', e.message); }

console.log('Selling 6 Up @ 0.09...');
try {
  const r2 = await t.placeOrder({ tokenId: '50318096510989379471642196522417738596771229353769398494442652414102097488166', side: 'SELL', price: 0.09, size: 6, orderType: 'FOK' });
  console.log('Up:', r2.status);
} catch(e) { console.log('Up err:', e.message); }

================================================================================
// File: src/clients/bridge-client.ts
================================================================================
/**
 * Bridge Client for Polymarket Cross-Chain Deposits
 *
 * Enables depositing assets from multiple chains (Ethereum, etc.)
 * and having them automatically converted to USDC.e on Polygon for trading.
 *
 * Flow:
 * 1. Request deposit addresses for your Polymarket wallet
 * 2. Send assets to the unique deposit address for each chain/token
 * 3. Assets are automatically bridged and swapped to USDC.e on Polygon
 * 4. USDC.e is credited to your Polymarket account
 *
 * @see https://docs.polymarket.com/developers/misc-endpoints/bridge-deposit
 * @see https://docs.polymarket.com/developers/misc-endpoints/bridge-supported-assets
 */

// ===== Types =====

/**
 * Supported asset information from the bridge
 */
export interface BridgeSupportedAsset {
  /** Blockchain chain ID (e.g., 1 for Ethereum) */
  chainId: number;
  /** Human-readable chain name (e.g., "Ethereum") */
  chainName: string;
  /** Token contract address on the source chain */
  tokenAddress: string;
  /** Token symbol (e.g., "USDC", "ETH") */
  tokenSymbol: string;
  /** Token name (e.g., "USD Coin") */
  tokenName: string;
  /** Token decimals (e.g., 6 for USDC) */
  decimals: number;
  /** Minimum deposit amount in token units */
  minDeposit: string;
  /** Minimum deposit amount in USD */
  minDepositUsd: number;
  /** Whether this asset is currently active */
  active: boolean;
}

/**
 * Deposit address for a specific chain/token combination
 */
export interface DepositAddress {
  /** Blockchain chain ID */
  chainId: number;
  /** Human-readable chain name */
  chainName: string;
  /** Token contract address on source chain */
  tokenAddress: string;
  /** Token symbol */
  tokenSymbol: string;
  /** Unique deposit address to send funds to */
  depositAddress: string;
  /** Minimum deposit amount */
  minDeposit: string;
}

/**
 * Response from creating deposit addresses
 *
 * The Bridge API returns a single universal deposit address structure.
 * - EVM address: Used for all EVM chains (Ethereum, Polygon, Arbitrum, Base, Optimism)
 * - SVM address: Used for Solana
 * - BTC address: Used for Bitcoin
 *
 * @example Response from API:
 * ```json
 * {
 *   "address": {
 *     "evm": "0x1234...",
 *     "svm": "ABC123...",
 *     "btc": "bc1q..."
 *   }
 * }
 * ```
 */
export interface CreateDepositResponse {
  /** Universal deposit addresses for different chain types */
  address: {
    /** EVM deposit address (Ethereum, Polygon, Arbitrum, Base, Optimism) */
    evm: string;
    /** Solana deposit address */
    svm: string;
    /** Bitcoin deposit address */
    btc: string;
  };
}

/**
 * Deposit status tracking
 */
export interface DepositStatus {
  /** Unique deposit ID */
  depositId: string;
  /** Source chain ID */
  sourceChainId: number;
  /** Source transaction hash */
  sourceTxHash: string;
  /** Amount deposited */
  amount: string;
  /** Token symbol */
  tokenSymbol: string;
  /** Status of the deposit */
  status: 'pending' | 'bridging' | 'swapping' | 'completed' | 'failed';
  /** Destination transaction hash (when completed) */
  destinationTxHash?: string;
  /** USDC.e amount received (when completed) */
  usdceReceived?: string;
  /** Error message (if failed) */
  errorMessage?: string;
  /** Timestamp of last update */
  updatedAt: string;
}

/**
 * Bridge configuration
 */
export interface BridgeConfig {
  /** Base URL for the bridge API (default: https://bridge.polymarket.com) */
  baseUrl?: string;
  /** Request timeout in ms (default: 30000) */
  timeout?: number;
}

// ===== Constants =====

const BRIDGE_API_BASE = 'https://bridge.polymarket.com';

// Known chain information
export const SUPPORTED_CHAINS = {
  ETHEREUM: {
    chainId: 1,
    name: 'Ethereum',
    rpcUrl: 'https://eth.llamarpc.com',
  },
  POLYGON: {
    chainId: 137,
    name: 'Polygon',
    rpcUrl: 'https://polygon-rpc.com',
  },
} as const;

// Known token addresses
export const BRIDGE_TOKENS = {
  // Ethereum
  ETH_USDC: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  ETH_WETH: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  ETH_DAI: '0x6B175474E89094C44Da98b954EeDeaC495271d0F',

  // Polygon (destination)
  POLYGON_USDC_E: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
  POLYGON_NATIVE_USDC: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',
} as const;

// ===== Bridge Client =====

/**
 * Client for interacting with Polymarket's cross-chain bridge
 *
 * @example
 * ```typescript
 * const bridge = new BridgeClient();
 *
 * // Get supported assets
 * const assets = await bridge.getSupportedAssets();
 * console.log(`Supported: ${assets.map(a => a.tokenSymbol).join(', ')}`);
 *
 * // Create deposit addresses for your wallet
 * const deposit = await bridge.createDepositAddresses('0xYourAddress');
 * const ethUsdc = deposit.depositAddresses.find(
 *   d => d.chainName === 'Ethereum' && d.tokenSymbol === 'USDC'
 * );
 * console.log(`Send USDC on Ethereum to: ${ethUsdc.depositAddress}`);
 * ```
 */
export class BridgeClient {
  private baseUrl: string;
  private timeout: number;

  constructor(config: BridgeConfig = {}) {
    this.baseUrl = config.baseUrl || BRIDGE_API_BASE;
    this.timeout = config.timeout || 30000;
  }

  /**
   * Get all supported assets for bridge deposits
   *
   * @returns Array of supported assets with their chain/token details
   *
   * @example
   * ```typescript
   * const assets = await bridge.getSupportedAssets();
   * for (const asset of assets) {
   *   console.log(`${asset.chainName} ${asset.tokenSymbol}: min $${asset.minDepositUsd}`);
   * }
   * ```
   */
  async getSupportedAssets(): Promise<BridgeSupportedAsset[]> {
    const response = await this.fetch('/supported-assets') as {
      supportedAssets: Array<{
        chainId: string;
        chainName: string;
        token: {
          name: string;
          symbol: string;
          address: string;
          decimals: number;
        };
        minCheckoutUsd: number;
      }>;
    };

    // Normalize the API response to match our interface
    return response.supportedAssets.map((asset) => ({
      chainId: parseInt(asset.chainId, 10),
      chainName: asset.chainName,
      tokenSymbol: asset.token.symbol,
      tokenName: asset.token.name,
      tokenAddress: asset.token.address,
      decimals: asset.token.decimals,
      minDeposit: asset.minCheckoutUsd.toString(),
      minDepositUsd: asset.minCheckoutUsd,
      active: true,
    }));
  }

  /**
   * Get unique deposit addresses for a Polymarket wallet
   *
   * The Bridge API returns a universal deposit address structure:
   * - A single EVM address works for ALL EVM chains (Ethereum, Polygon, Arbitrum, Base, Optimism)
   * - A Solana address for SVM deposits
   * - A Bitcoin address for BTC deposits
   *
   * Funds sent to these addresses are automatically bridged to Polygon
   * and converted to USDC.e for your Polymarket account.
   *
   * @param walletAddress - Your Polymarket wallet address (EOA address)
   * @returns Universal deposit addresses for EVM, Solana, and Bitcoin
   *
   * @example
   * ```typescript
   * const result = await bridge.createDepositAddresses('0xYourPolymarketWallet');
   *
   * // The EVM address works for Ethereum, Polygon, Arbitrum, Base, Optimism
   * console.log(`EVM deposit address: ${result.address.evm}`);
   *
   * // For Solana deposits
   * console.log(`Solana deposit address: ${result.address.svm}`);
   *
   * // For Bitcoin deposits
   * console.log(`Bitcoin deposit address: ${result.address.btc}`);
   * ```
   */
  async createDepositAddresses(walletAddress: string): Promise<CreateDepositResponse> {
    const response = await this.fetch('/deposit', {
      method: 'POST',
      body: JSON.stringify({ address: walletAddress }),
    });

    return response as CreateDepositResponse;
  }

  /**
   * Get the EVM deposit address for a wallet
   *
   * This address works for ALL supported EVM chains:
   * - Ethereum (chainId: 1)
   * - Polygon (chainId: 137)
   * - Arbitrum (chainId: 42161)
   * - Base (chainId: 8453)
   * - Optimism (chainId: 10)
   *
   * @param walletAddress - Your Polymarket wallet address
   * @returns The universal EVM deposit address
   *
   * @example
   * ```typescript
   * const evmAddr = await bridge.getEvmDepositAddress('0xYourWallet');
   * // Send Native USDC on Polygon to this address
   * // Or send USDC on Ethereum to this address
   * console.log(`Deposit to: ${evmAddr}`);
   * ```
   */
  async getEvmDepositAddress(walletAddress: string): Promise<string> {
    const result = await this.createDepositAddresses(walletAddress);
    return result.address.evm;
  }

  /**
   * Get the Solana deposit address for a wallet
   *
   * @param walletAddress - Your Polymarket wallet address
   * @returns The Solana deposit address
   */
  async getSolanaDepositAddress(walletAddress: string): Promise<string> {
    const result = await this.createDepositAddresses(walletAddress);
    return result.address.svm;
  }

  /**
   * Get the Bitcoin deposit address for a wallet
   *
   * @param walletAddress - Your Polymarket wallet address
   * @returns The Bitcoin deposit address
   */
  async getBtcDepositAddress(walletAddress: string): Promise<string> {
    const result = await this.createDepositAddresses(walletAddress);
    return result.address.btc;
  }

  /**
   * @deprecated Use getEvmDepositAddress(), getSolanaDepositAddress(), or getBtcDepositAddress() instead.
   *
   * The Bridge API returns universal addresses by chain type (EVM/SVM/BTC),
   * not by specific chain/token combinations.
   *
   * For EVM chains (Ethereum, Polygon, Arbitrum, Base, Optimism), use getEvmDepositAddress()
   */
  async getDepositAddress(
    address: string,
    _chainId: number,
    _tokenSymbol: string
  ): Promise<DepositAddress | null> {
    // Return a compatibility shim - the EVM address works for all EVM chains
    const result = await this.createDepositAddresses(address);
    return {
      chainId: _chainId,
      chainName: 'Universal EVM',
      tokenAddress: '',
      tokenSymbol: _tokenSymbol,
      depositAddress: result.address.evm,
      minDeposit: '2', // Default minimum
    };
  }

  /**
   * Check if a chain/token combination is supported
   *
   * @param chainId - The chain ID to check
   * @param tokenSymbol - The token symbol to check
   * @returns True if supported, false otherwise
   */
  async isSupported(chainId: number, tokenSymbol: string): Promise<boolean> {
    const assets = await this.getSupportedAssets();
    return assets.some(
      (a) => a.chainId === chainId && a.tokenSymbol.toUpperCase() === tokenSymbol.toUpperCase()
    );
  }

  /**
   * Get minimum deposit amount for a chain/token
   *
   * @param chainId - The chain ID
   * @param tokenSymbol - The token symbol
   * @returns Minimum deposit info or null if not supported
   */
  async getMinDeposit(
    chainId: number,
    tokenSymbol: string
  ): Promise<{ amount: string; usd: number } | null> {
    const assets = await this.getSupportedAssets();
    const asset = assets.find(
      (a) => a.chainId === chainId && a.tokenSymbol.toUpperCase() === tokenSymbol.toUpperCase()
    );

    if (!asset) return null;

    return {
      amount: asset.minDeposit,
      usd: asset.minDepositUsd,
    };
  }

  /**
   * Format deposit instructions for a user
   *
   * @param walletAddress - The Polymarket wallet address
   * @returns Formatted instructions string
   */
  async getDepositInstructions(walletAddress: string): Promise<string> {
    const result = await this.createDepositAddresses(walletAddress);
    const assets = await this.getSupportedAssets();

    const lines: string[] = [
      '═══════════════════════════════════════════════════════════',
      '            POLYMARKET DEPOSIT INSTRUCTIONS',
      '═══════════════════════════════════════════════════════════',
      '',
      `Wallet: ${walletAddress}`,
      '',
      'Send assets to these addresses to deposit to your Polymarket account:',
      '(Assets will be automatically converted to USDC.e on Polygon)',
      '',
    ];

    // EVM Deposit Address (works for all EVM chains)
    lines.push('── EVM CHAINS ──');
    lines.push('(Ethereum, Polygon, Arbitrum, Base, Optimism)');
    lines.push('');
    lines.push(`  Universal EVM Address: ${result.address.evm}`);
    lines.push('');

    // Group assets by chain for display
    const evmChainIds = [1, 137, 42161, 8453, 10];
    const evmAssets = assets.filter((a) => evmChainIds.includes(a.chainId));

    // Group by chain
    const byChain = new Map<number, BridgeSupportedAsset[]>();
    for (const asset of evmAssets) {
      const existing = byChain.get(asset.chainId) || [];
      existing.push(asset);
      byChain.set(asset.chainId, existing);
    }

    for (const [chainId, chainAssets] of byChain) {
      const chainName = chainAssets[0]?.chainName || `Chain ${chainId}`;
      lines.push(`  ${chainName} (${chainId}):`);
      for (const asset of chainAssets) {
        lines.push(`    - ${asset.tokenSymbol}: min $${asset.minDepositUsd}`);
      }
      lines.push('');
    }

    // Solana Deposit Address
    lines.push('── SOLANA ──');
    lines.push(`  Address: ${result.address.svm}`);
    const solAssets = assets.filter((a) => a.chainName?.toLowerCase().includes('solana'));
    for (const asset of solAssets) {
      lines.push(`    - ${asset.tokenSymbol}: min $${asset.minDepositUsd}`);
    }
    lines.push('');

    // Bitcoin Deposit Address
    lines.push('── BITCOIN ──');
    lines.push(`  Address: ${result.address.btc}`);
    const btcAssets = assets.filter((a) => a.chainName?.toLowerCase().includes('bitcoin'));
    for (const asset of btcAssets) {
      lines.push(`    - ${asset.tokenSymbol}: min $${asset.minDepositUsd}`);
    }
    lines.push('');

    lines.push('═══════════════════════════════════════════════════════════');
    lines.push('');
    lines.push('IMPORTANT:');
    lines.push('  - Always send more than the minimum amount');
    lines.push('  - Deposits may take 1-30 minutes to process');
    lines.push('  - Check Polymarket balance after deposit completes');
    lines.push('  - Bridge fee is approximately 0.16%');
    lines.push('');

    return lines.join('\n');
  }

  // ===== Private Methods =====

  private async fetch(path: string, options: RequestInit = {}): Promise<unknown> {
    const url = `${this.baseUrl}${path}`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        signal: controller.signal,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Bridge API error (${response.status}): ${errorText}`);
      }

      return await response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
}

// ===== Deposit Execution =====

import { ethers } from 'ethers';

// ERC20 ABI for deposits
const ERC20_DEPOSIT_ABI = [
  'function balanceOf(address owner) view returns (uint256)',
  'function transfer(address to, uint256 amount) returns (bool)',
];

export interface DepositResult {
  success: boolean;
  txHash?: string;
  amount: string;
  depositAddress: string;
  error?: string;
}

export interface DepositOptions {
  /** Chain ID for the deposit (default: 137 for Polygon) */
  chainId?: number;
  /** Token to deposit: 'NATIVE_USDC' or 'USDC_E' (default: 'NATIVE_USDC') */
  token?: 'NATIVE_USDC' | 'USDC_E';
  /** Gas price multiplier (default: 1.2) */
  gasPriceMultiplier?: number;
}

/**
 * Deposit USDC to Polymarket via Bridge
 *
 * This function:
 * 1. Gets the deposit address for your wallet
 * 2. Transfers USDC to that address
 * 3. The bridge automatically converts it to USDC.e for your Polymarket account
 *
 * @param signer - Ethers wallet/signer to send from
 * @param amount - Amount in USDC (e.g., 10.5 for $10.50)
 * @param options - Deposit options
 * @returns Deposit result with transaction hash
 *
 * @example
 * ```typescript
 * const bridge = new BridgeClient();
 * const result = await bridge.depositUsdc(signer, 100);
 * console.log(`Deposited $100: ${result.txHash}`);
 * ```
 */
export async function depositUsdc(
  signer: ethers.Wallet,
  amount: number,
  options: DepositOptions = {}
): Promise<DepositResult> {
  const { token = 'NATIVE_USDC', gasPriceMultiplier = 1.2 } = options;

  // Validate minimum deposit
  if (amount < 2) {
    return {
      success: false,
      amount: amount.toString(),
      depositAddress: '',
      error: 'Minimum deposit is $2',
    };
  }

  // Get token address
  const tokenAddress =
    token === 'NATIVE_USDC' ? BRIDGE_TOKENS.POLYGON_NATIVE_USDC : BRIDGE_TOKENS.POLYGON_USDC_E;

  try {
    // Get deposit address
    const bridge = new BridgeClient();
    const depositAddr = await bridge.getEvmDepositAddress(signer.address);

    // Create token contract
    const tokenContract = new ethers.Contract(tokenAddress, ERC20_DEPOSIT_ABI, signer);

    // Check balance
    const balance = await tokenContract.balanceOf(signer.address);
    const amountWei = ethers.utils.parseUnits(amount.toString(), 6);

    if (balance.lt(amountWei)) {
      const balanceFormatted = ethers.utils.formatUnits(balance, 6);
      return {
        success: false,
        amount: amount.toString(),
        depositAddress: depositAddr,
        error: `Insufficient balance. Have: ${balanceFormatted}, Need: ${amount}`,
      };
    }

    // Get gas price with buffer
    const feeData = await signer.provider!.getFeeData();
    const gasPrice = feeData.gasPrice
      ? feeData.gasPrice.mul(Math.floor(gasPriceMultiplier * 100)).div(100)
      : undefined;

    // Execute transfer
    const tx = await tokenContract.transfer(depositAddr, amountWei, {
      gasPrice,
    });

    const receipt = await tx.wait();

    if (receipt.status !== 1) {
      return {
        success: false,
        txHash: tx.hash,
        amount: amount.toString(),
        depositAddress: depositAddr,
        error: 'Transaction failed',
      };
    }

    return {
      success: true,
      txHash: tx.hash,
      amount: amount.toString(),
      depositAddress: depositAddr,
    };
  } catch (err) {
    return {
      success: false,
      amount: amount.toString(),
      depositAddress: '',
      error: err instanceof Error ? err.message : 'Unknown error',
    };
  }
}

// ===== Swap and Deposit =====

import { SwapService, POLYGON_TOKENS, TOKEN_DECIMALS } from '../services/swap-service.js';

export interface SwapAndDepositOptions {
  /** Slippage tolerance for swap (default: 0.5%) */
  slippage?: number;
  /** Gas price multiplier (default: 1.2) */
  gasPriceMultiplier?: number;
}

export interface SwapAndDepositResult {
  success: boolean;
  /** Swap transaction hash (if swap was needed) */
  swapTxHash?: string;
  /** Deposit transaction hash */
  depositTxHash?: string;
  /** Input token */
  tokenIn: string;
  /** Amount of input token */
  amountIn: string;
  /** Amount of USDC after swap */
  usdcAmount: string;
  /** Deposit address */
  depositAddress: string;
  /** Error message if failed */
  error?: string;
}

/**
 * Swap any supported Polygon token to USDC and deposit to Polymarket
 *
 * Supported tokens: MATIC, WMATIC, USDC, USDC_E, USDT, DAI, WETH
 *
 * Flow:
 * 1. If token is not USDC, swap to USDC using QuickSwap
 * 2. Deposit USDC to the bridge deposit address
 *
 * @param signer - Ethers wallet/signer
 * @param token - Token symbol to deposit (e.g., 'MATIC', 'WETH', 'USDT')
 * @param amount - Amount to deposit in token units
 * @param options - Swap and deposit options
 * @returns Result with transaction hashes
 *
 * @example
 * ```typescript
 * // Deposit 10 MATIC
 * const result = await swapAndDeposit(signer, 'MATIC', '10');
 *
 * // Deposit 100 USDT
 * const result = await swapAndDeposit(signer, 'USDT', '100');
 *
 * // Deposit 0.1 WETH
 * const result = await swapAndDeposit(signer, 'WETH', '0.1');
 * ```
 */
export async function swapAndDeposit(
  signer: ethers.Wallet,
  token: string,
  amount: string,
  options: SwapAndDepositOptions = {}
): Promise<SwapAndDepositResult> {
  const { slippage = 0.5, gasPriceMultiplier = 1.2 } = options;

  const upperToken = token.toUpperCase();

  try {
    const swapService = new SwapService(signer);
    const bridge = new BridgeClient();

    // Get deposit address
    const depositAddr = await bridge.getEvmDepositAddress(signer.address);

    // If already USDC, skip swap
    if (upperToken === 'USDC' || upperToken === 'NATIVE_USDC') {
      const result = await depositUsdc(signer, parseFloat(amount), {
        token: 'NATIVE_USDC',
        gasPriceMultiplier,
      });

      return {
        success: result.success,
        depositTxHash: result.txHash,
        tokenIn: upperToken,
        amountIn: amount,
        usdcAmount: amount,
        depositAddress: depositAddr,
        error: result.error,
      };
    }

    if (upperToken === 'USDC_E') {
      const result = await depositUsdc(signer, parseFloat(amount), {
        token: 'USDC_E',
        gasPriceMultiplier,
      });

      return {
        success: result.success,
        depositTxHash: result.txHash,
        tokenIn: upperToken,
        amountIn: amount,
        usdcAmount: amount,
        depositAddress: depositAddr,
        error: result.error,
      };
    }

    // Check balance
    const balance = await swapService.getBalance(token);
    if (parseFloat(balance) < parseFloat(amount)) {
      return {
        success: false,
        tokenIn: upperToken,
        amountIn: amount,
        usdcAmount: '0',
        depositAddress: depositAddr,
        error: `Insufficient ${upperToken} balance. Have: ${balance}, Need: ${amount}`,
      };
    }

    // Swap to USDC
    const swapResult = await swapService.swapToUsdc(token, amount, {
      usdcType: 'NATIVE_USDC',
      slippage,
    });

    if (!swapResult.success) {
      return {
        success: false,
        tokenIn: upperToken,
        amountIn: amount,
        usdcAmount: '0',
        depositAddress: depositAddr,
        error: `Swap failed: ${swapResult.transactionHash}`,
      };
    }

    // Get USDC balance after swap
    const usdcBalance = await swapService.getBalance('USDC');

    // Deposit USDC
    const depositResult = await depositUsdc(signer, parseFloat(usdcBalance), {
      token: 'NATIVE_USDC',
      gasPriceMultiplier,
    });

    return {
      success: depositResult.success,
      swapTxHash: swapResult.transactionHash,
      depositTxHash: depositResult.txHash,
      tokenIn: upperToken,
      amountIn: amount,
      usdcAmount: usdcBalance,
      depositAddress: depositAddr,
      error: depositResult.error,
    };
  } catch (err) {
    return {
      success: false,
      tokenIn: upperToken,
      amountIn: amount,
      usdcAmount: '0',
      depositAddress: '',
      error: err instanceof Error ? err.message : 'Unknown error',
    };
  }
}

/**
 * Get list of supported tokens for swap and deposit
 */
export function getSupportedDepositTokens(): string[] {
  return Object.keys(POLYGON_TOKENS);
}

// ===== Utility Functions =====

/**
 * Calculate the expected USDC.e output after bridge fees
 *
 * Note: This is an estimate. Actual output depends on bridge/swap fees.
 *
 * @param amount - Input amount in source token
 * @param tokenSymbol - Source token symbol
 * @returns Estimated USDC.e output
 */
export function estimateBridgeOutput(amount: number, tokenSymbol: string): number {
  // Typical bridge fees: ~0.5-1%
  // Swap fees: ~0.3%
  const totalFeePercent = 0.01; // 1% estimate

  // For stablecoins, 1:1 minus fees
  if (['USDC', 'USDT', 'DAI', 'BUSD'].includes(tokenSymbol.toUpperCase())) {
    return amount * (1 - totalFeePercent);
  }

  // For ETH and other tokens, would need price oracle
  // This is just a placeholder
  return amount * (1 - totalFeePercent);
}

/**
 * Get explorer URL for a deposit transaction
 *
 * @param chainId - The chain ID
 * @param txHash - The transaction hash
 * @returns Block explorer URL
 */
export function getExplorerUrl(chainId: number, txHash: string): string {
  switch (chainId) {
    case 1:
      return `https://etherscan.io/tx/${txHash}`;
    case 137:
      return `https://polygonscan.com/tx/${txHash}`;
    case 10:
      return `https://optimistic.etherscan.io/tx/${txHash}`;
    case 42161:
      return `https://arbiscan.io/tx/${txHash}`;
    case 8453:
      return `https://basescan.org/tx/${txHash}`;
    default:
      return `https://blockscan.com/tx/${txHash}`;
  }
}

================================================================================
// File: src/clients/ctf-client.ts
================================================================================
/**
 * CTF (Conditional Token Framework) Client
 *
 * Provides on-chain operations for Polymarket's conditional tokens:
 * - Split: USDC → YES + NO token pair
 * - Merge: YES + NO → USDC
 * - Redeem: Winning tokens → USDC (after market resolution)
 *
 * ⚠️ CRITICAL: Polymarket CTF uses USDC.e (bridged), NOT native USDC!
 *
 * | Token         | Address                                    | CTF Compatible |
 * |---------------|--------------------------------------------|-----------------
 * | USDC.e        | 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 | ✅ Yes         |
 * | Native USDC   | 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359 | ❌ No          |
 *
 * Common Mistake:
 * - Your wallet has native USDC but CTF operations fail
 * - Solution: Use SwapService.transferUsdcE() or swap native USDC to USDC.e
 *
 * Based on: docs/01-product-research/06-poly-sdk/05-ctf-integration-plan.md
 *
 * Contract: Gnosis Conditional Tokens on Polygon
 * https://docs.polymarket.com/developers/CTF/overview
 */

import { ethers, Contract, Wallet, BigNumber } from 'ethers';

// ===== Contract Addresses (Polygon Mainnet) =====

export const CTF_CONTRACT = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';

/**
 * USDC.e (Bridged USDC) - The ONLY USDC accepted by Polymarket CTF
 *
 * ⚠️ WARNING: This is NOT native USDC (0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359)
 *
 * If your wallet has native USDC but CTF operations fail with "Insufficient USDC balance",
 * you need to swap your native USDC to USDC.e first using:
 * - SwapService.swap('USDC', 'USDC_E', amount)
 * - Or transfer USDC.e using SwapService.transferUsdcE()
 */
export const USDC_CONTRACT = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';

/** Native USDC on Polygon - NOT compatible with CTF */
export const NATIVE_USDC_CONTRACT = '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359';

export const NEG_RISK_CTF_EXCHANGE = '0xC5d563A36AE78145C45a50134d48A1215220f80a';
export const NEG_RISK_ADAPTER = '0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296';

// USDC.e uses 6 decimals
export const USDC_DECIMALS = 6;

// ===== ABIs =====

const CTF_ABI = [
  // Split: USDC → YES + NO
  'function splitPosition(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] partition, uint256 amount) external',
  // Merge: YES + NO → USDC
  'function mergePositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] partition, uint256 amount) external',
  // Redeem: Winning tokens → USDC
  'function redeemPositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] indexSets) external',
  // Balance query
  'function balanceOf(address account, uint256 positionId) view returns (uint256)',
  // Check if condition is resolved
  'function payoutNumerators(bytes32 conditionId, uint256 outcomeIndex) view returns (uint256)',
  'function payoutDenominator(bytes32 conditionId) view returns (uint256)',
];

const ERC20_ABI = [
  'function approve(address spender, uint256 amount) returns (bool)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function balanceOf(address account) view returns (uint256)',
  'function decimals() view returns (uint8)',
];

// ===== Types =====

export interface CTFConfig {
  /** Private key for signing transactions */
  privateKey: string;
  /** RPC URL (default: Polygon mainnet) */
  rpcUrl?: string;
  /** Chain ID (default: 137 for Polygon) */
  chainId?: number;
  /** Gas price multiplier (default: 1.2) */
  gasPriceMultiplier?: number;
  /** Transaction confirmation blocks (default: 1) */
  confirmations?: number;
  /** Transaction timeout in ms (default: 60000) */
  txTimeout?: number;
}

export interface GasEstimate {
  /** Estimated gas units */
  gasUnits: string;
  /** Gas price in gwei */
  gasPriceGwei: string;
  /** Estimated cost in MATIC */
  costMatic: string;
  /** Estimated cost in USDC (at current MATIC price) */
  costUsdc: string;
  /** MATIC/USDC price used */
  maticPrice: number;
}

export interface TransactionStatus {
  txHash: string;
  status: 'pending' | 'confirmed' | 'failed' | 'reverted';
  confirmations: number;
  blockNumber?: number;
  gasUsed?: string;
  effectiveGasPrice?: string;
  errorReason?: string;
}

/** Common revert reasons */
export enum RevertReason {
  INSUFFICIENT_BALANCE = 'INSUFFICIENT_BALANCE',
  INSUFFICIENT_ALLOWANCE = 'INSUFFICIENT_ALLOWANCE',
  CONDITION_NOT_RESOLVED = 'CONDITION_NOT_RESOLVED',
  INVALID_PARTITION = 'INVALID_PARTITION',
  INVALID_CONDITION = 'INVALID_CONDITION',
  EXECUTION_REVERTED = 'EXECUTION_REVERTED',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}

export interface SplitResult {
  success: boolean;
  txHash: string;
  amount: string;
  yesTokens: string;
  noTokens: string;
  gasUsed?: string;
}

export interface MergeResult {
  success: boolean;
  txHash: string;
  amount: string;
  usdcReceived: string;
  gasUsed?: string;
}

export interface RedeemResult {
  success: boolean;
  txHash: string;
  /** Winning outcome (e.g., 'YES', 'NO', 'Up', 'Down', 'Team1', 'Team2') */
  outcome: string;
  tokensRedeemed: string;
  usdcReceived: string;
  gasUsed?: string;
}

export interface PositionBalance {
  conditionId: string;
  yesBalance: string;
  noBalance: string;
  yesPositionId: string;
  noPositionId: string;
}

export interface TokenIds {
  yesTokenId: string;
  noTokenId: string;
}

export interface MarketResolution {
  conditionId: string;
  isResolved: boolean;
  /** Winning outcome (e.g., 'YES', 'NO') - determined by payout numerators */
  winningOutcome?: string;
  payoutNumerators: [number, number];
  payoutDenominator: number;
}

// ===== CTF Client =====

// Default MATIC price (updated via getMaticPrice)
const DEFAULT_MATIC_PRICE = 0.50;

export class CTFClient {
  private provider: ethers.providers.JsonRpcProvider;
  private wallet: Wallet;
  private ctfContract: Contract;
  private usdcContract: Contract;
  private gasPriceMultiplier: number;
  private confirmations: number;
  private txTimeout: number;
  private cachedMaticPrice: number = DEFAULT_MATIC_PRICE;
  private maticPriceLastUpdated: number = 0;

  constructor(config: CTFConfig) {
    const rpcUrl = config.rpcUrl || 'https://polygon-rpc.com';
    this.provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    this.wallet = new Wallet(config.privateKey, this.provider);
    this.ctfContract = new Contract(CTF_CONTRACT, CTF_ABI, this.wallet);
    this.usdcContract = new Contract(USDC_CONTRACT, ERC20_ABI, this.wallet);
    this.gasPriceMultiplier = config.gasPriceMultiplier || 1.2;
    this.confirmations = config.confirmations || 1;
    this.txTimeout = config.txTimeout || 60000;
  }

  /**
   * Get wallet address
   */
  getAddress(): string {
    return this.wallet.address;
  }

  /**
   * Get USDC.e (bridged USDC) balance - the token used by Polymarket CTF
   *
   * ⚠️ Note: This returns USDC.e balance, NOT native USDC balance.
   * Polymarket CTF only accepts USDC.e (0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).
   *
   * Common issue: Your wallet shows USDC balance but this returns 0
   * - This means you have native USDC, not USDC.e
   * - Use SwapService.swap('USDC', 'USDC_E', amount) to convert
   */
  async getUsdcBalance(): Promise<string> {
    const balance = await this.usdcContract.balanceOf(this.wallet.address);
    return ethers.utils.formatUnits(balance, USDC_DECIMALS);
  }

  /**
   * Get native USDC balance (for comparison/debugging)
   *
   * This is NOT the token used by CTF. Use getUsdcBalance() for CTF operations.
   */
  async getNativeUsdcBalance(): Promise<string> {
    const nativeUsdcContract = new Contract(NATIVE_USDC_CONTRACT, ERC20_ABI, this.provider);
    const balance = await nativeUsdcContract.balanceOf(this.wallet.address);
    return ethers.utils.formatUnits(balance, USDC_DECIMALS);
  }

  /**
   * Check if wallet is ready for CTF trading operations
   *
   * Verifies:
   * - Has sufficient USDC.e (not native USDC)
   * - Has MATIC for gas fees
   *
   * @param amount - Minimum USDC.e amount needed (e.g., "100" for 100 USDC.e)
   * @returns Ready status with balances and suggestions
   *
   * @example
   * ```typescript
   * const status = await ctf.checkReadyForCTF('100');
   * if (!status.ready) {
   *   console.log(status.suggestion);
   *   // "You have 50 native USDC but 0 USDC.e. Swap native USDC to USDC.e first."
   * }
   * ```
   */
  async checkReadyForCTF(amount: string): Promise<{
    ready: boolean;
    usdcEBalance: string;
    nativeUsdcBalance: string;
    maticBalance: string;
    suggestion?: string;
  }> {
    const [usdcE, nativeUsdc, matic] = await Promise.all([
      this.getUsdcBalance(),
      this.getNativeUsdcBalance(),
      this.provider.getBalance(this.wallet.address),
    ]);

    const usdcEBalance = parseFloat(usdcE);
    const nativeUsdcBalance = parseFloat(nativeUsdc);
    const maticBalance = parseFloat(ethers.utils.formatEther(matic));
    const amountNeeded = parseFloat(amount);

    const result = {
      ready: false,
      usdcEBalance: usdcE,
      nativeUsdcBalance: nativeUsdc,
      maticBalance: ethers.utils.formatEther(matic),
      suggestion: undefined as string | undefined,
    };

    // Check MATIC for gas
    if (maticBalance < 0.01) {
      result.suggestion = `Insufficient MATIC for gas fees. Have: ${maticBalance.toFixed(4)} MATIC, need at least 0.01 MATIC.`;
      return result;
    }

    // Check USDC.e balance
    if (usdcEBalance < amountNeeded) {
      if (nativeUsdcBalance >= amountNeeded) {
        result.suggestion = `You have ${nativeUsdcBalance.toFixed(2)} native USDC but only ${usdcEBalance.toFixed(2)} USDC.e. ` +
          `Polymarket CTF requires USDC.e. Use SwapService.swap('USDC', 'USDC_E', '${amount}') to convert.`;
      } else if (nativeUsdcBalance > 0) {
        result.suggestion = `Insufficient USDC.e. Have: ${usdcEBalance.toFixed(2)} USDC.e + ${nativeUsdcBalance.toFixed(2)} native USDC, need: ${amount} USDC.e. ` +
          `Swap all native USDC to USDC.e, then add more funds.`;
      } else {
        result.suggestion = `Insufficient USDC.e. Have: ${usdcEBalance.toFixed(2)} USDC.e, need: ${amount} USDC.e.`;
      }
      return result;
    }

    result.ready = true;
    return result;
  }

  /**
   * Split USDC into YES + NO tokens
   *
   * @param conditionId - Market condition ID
   * @param amount - USDC amount (e.g., "100" for 100 USDC)
   * @returns SplitResult with transaction details
   *
   * @example
   * ```typescript
   * const result = await ctf.split(conditionId, "100");
   * console.log(`Split ${result.amount} USDC into tokens`);
   * console.log(`TX: ${result.txHash}`);
   * ```
   */
  async split(conditionId: string, amount: string): Promise<SplitResult> {
    const amountWei = ethers.utils.parseUnits(amount, USDC_DECIMALS);

    // 1. Check USDC balance
    const balance = await this.usdcContract.balanceOf(this.wallet.address);
    if (balance.lt(amountWei)) {
      throw new Error(`Insufficient USDC balance. Have: ${ethers.utils.formatUnits(balance, USDC_DECIMALS)}, Need: ${amount}`);
    }

    // 2. Check and approve USDC if needed
    const allowance = await this.usdcContract.allowance(this.wallet.address, CTF_CONTRACT);
    if (allowance.lt(amountWei)) {
      const approveTx = await this.usdcContract.approve(
        CTF_CONTRACT,
        ethers.constants.MaxUint256,
        await this.getGasOptions()
      );
      await approveTx.wait();
    }

    // 3. Execute split
    // Partition [1, 2] represents [YES, NO] outcomes
    const tx = await this.ctfContract.splitPosition(
      USDC_CONTRACT,
      ethers.constants.HashZero, // parentCollectionId = 0 for Polymarket
      conditionId,
      [1, 2], // partition for YES/NO
      amountWei,
      await this.getGasOptions()
    );

    const receipt = await tx.wait();

    return {
      success: true,
      txHash: receipt.transactionHash,
      amount,
      yesTokens: amount, // 1:1 split
      noTokens: amount,
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Merge YES + NO tokens back to USDC
   *
   * @param conditionId - Market condition ID
   * @param amount - Number of token pairs to merge (e.g., "100" for 100 YES + 100 NO)
   * @returns MergeResult with transaction details
   *
   * @example
   * ```typescript
   * // After buying 100 YES and 100 NO via TradingClient
   * const result = await ctf.merge(conditionId, "100");
   * console.log(`Received ${result.usdcReceived} USDC`);
   * ```
   */
  async merge(conditionId: string, amount: string): Promise<MergeResult> {
    const amountWei = ethers.utils.parseUnits(amount, USDC_DECIMALS);

    // Check token balances
    const balances = await this.getPositionBalance(conditionId);
    const yesBalance = ethers.utils.parseUnits(balances.yesBalance, USDC_DECIMALS);
    const noBalance = ethers.utils.parseUnits(balances.noBalance, USDC_DECIMALS);

    if (yesBalance.lt(amountWei) || noBalance.lt(amountWei)) {
      throw new Error(
        `Insufficient token balance. Need ${amount} of each. Have: YES=${balances.yesBalance}, NO=${balances.noBalance}`
      );
    }

    // Execute merge
    const tx = await this.ctfContract.mergePositions(
      USDC_CONTRACT,
      ethers.constants.HashZero,
      conditionId,
      [1, 2],
      amountWei,
      await this.getGasOptions()
    );

    const receipt = await tx.wait();

    return {
      success: true,
      txHash: receipt.transactionHash,
      amount,
      usdcReceived: amount, // 1:1 merge
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Merge YES and NO tokens back into USDC using explicit token IDs
   *
   * This method uses the provided token IDs for balance checking, which is
   * necessary when working with Polymarket CLOB markets where token IDs
   * don't match the calculated position IDs.
   *
   * @param conditionId - Market condition ID
   * @param tokenIds - Token IDs from CLOB API
   * @param amount - Amount of tokens to merge
   * @returns MergeResult with transaction details
   */
  async mergeByTokenIds(conditionId: string, tokenIds: TokenIds, amount: string): Promise<MergeResult> {
    const amountWei = ethers.utils.parseUnits(amount, USDC_DECIMALS);

    // Check token balances using the provided token IDs
    const balances = await this.getPositionBalanceByTokenIds(conditionId, tokenIds);
    const yesBalance = ethers.utils.parseUnits(balances.yesBalance, USDC_DECIMALS);
    const noBalance = ethers.utils.parseUnits(balances.noBalance, USDC_DECIMALS);

    if (yesBalance.lt(amountWei) || noBalance.lt(amountWei)) {
      throw new Error(
        `Insufficient token balance. Need ${amount} of each. Have: YES=${balances.yesBalance}, NO=${balances.noBalance}`
      );
    }

    // Execute merge
    const tx = await this.ctfContract.mergePositions(
      USDC_CONTRACT,
      ethers.constants.HashZero,
      conditionId,
      [1, 2],
      amountWei,
      await this.getGasOptions()
    );

    const receipt = await tx.wait();

    return {
      success: true,
      txHash: receipt.transactionHash,
      amount,
      usdcReceived: amount, // 1:1 merge
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Redeem winning tokens after market resolution (Standard CTF)
   *
   * ⚠️ IMPORTANT: This method uses standard CTF position ID calculation.
   * It is ONLY suitable for:
   * - Standard Gnosis CTF markets (non-Polymarket)
   * - Markets where position IDs are calculated from conditionId using standard formula
   * - Direct CTF contract interactions without CLOB
   *
   * ❌ DO NOT USE for Polymarket CLOB markets!
   * Polymarket uses custom token IDs that differ from standard CTF position IDs.
   * For Polymarket, use `redeemByTokenIds()` instead.
   *
   * Position ID calculation: keccak256(collectionId, conditionId, indexSet)
   * - This formula may NOT match Polymarket's token IDs
   *
   * @param conditionId - Market condition ID
   * @param outcome - 'YES' or 'NO' (optional, auto-detects if not provided)
   * @returns RedeemResult with transaction details
   *
   * @example
   * ```typescript
   * // For standard CTF markets (NOT Polymarket)
   * const result = await ctf.redeem(conditionId);
   * console.log(`Redeemed ${result.tokensRedeemed} ${result.outcome} tokens`);
   * ```
   *
   * @see redeemByTokenIds - Use this for Polymarket CLOB markets
   */
  async redeem(conditionId: string, outcome?: string): Promise<RedeemResult> {
    // Check resolution status
    const resolution = await this.getMarketResolution(conditionId);
    if (!resolution.isResolved) {
      throw new Error('Market is not resolved yet');
    }

    // Auto-detect outcome if not provided
    const winningOutcome = outcome || resolution.winningOutcome;
    if (!winningOutcome) {
      throw new Error('Could not determine winning outcome');
    }

    // Get token balance
    const balances = await this.getPositionBalance(conditionId);
    const tokenBalance = winningOutcome === 'YES' ? balances.yesBalance : balances.noBalance;

    if (parseFloat(tokenBalance) === 0) {
      throw new Error(`No ${winningOutcome} tokens to redeem`);
    }

    // indexSets: [1] for YES, [2] for NO
    const indexSets = winningOutcome === 'YES' ? [1] : [2];

    const tx = await this.ctfContract.redeemPositions(
      USDC_CONTRACT,
      ethers.constants.HashZero,
      conditionId,
      indexSets,
      await this.getGasOptions()
    );

    const receipt = await tx.wait();

    return {
      success: true,
      txHash: receipt.transactionHash,
      outcome: winningOutcome,
      tokensRedeemed: tokenBalance,
      usdcReceived: tokenBalance, // 1:1 for winning outcome
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Redeem winning tokens using Polymarket token IDs (Polymarket CLOB)
   *
   * ✅ USE THIS for Polymarket CLOB markets!
   *
   * Polymarket uses custom token IDs that are different from standard CTF position IDs.
   * These token IDs are provided by the CLOB API and must be used for:
   * - Querying balances (getPositionBalanceByTokenIds)
   * - Redeeming positions (this method)
   * - Trading via CLOB API
   *
   * Why Polymarket token IDs differ:
   * - Polymarket wraps CTF positions into ERC-1155 tokens with custom IDs
   * - The token IDs from CLOB API (e.g., "25064375...") are NOT the same as
   *   calculated position IDs from keccak256(collectionId, conditionId, indexSet)
   *
   * @param conditionId - The condition ID of the market
   * @param tokenIds - The Polymarket token IDs for YES and NO outcomes (from CLOB API)
   * @param outcome - Optional: which outcome to redeem ('YES' or 'NO'). Auto-detects if not provided.
   * @returns RedeemResult with transaction details
   *
   * @example
   * ```typescript
   * // For Polymarket CLOB markets
   * const tokenIds = {
   *   yesTokenId: '25064375110792967023484002819116042931016336431092144471807003884255851454283',
   *   noTokenId: '98190367690492181203391990709979106077460946443309150166954079213761598385827',
   * };
   * const result = await ctf.redeemByTokenIds(conditionId, tokenIds);
   * console.log(`Redeemed ${result.tokensRedeemed} ${result.outcome} tokens`);
   * console.log(`Received ${result.usdcReceived} USDC`);
   * ```
   *
   * @see redeem - Only use for standard CTF markets (non-Polymarket)
   */
  async redeemByTokenIds(
    conditionId: string,
    tokenIds: TokenIds,
    outcome?: string
  ): Promise<RedeemResult> {
    // Check resolution status
    const resolution = await this.getMarketResolution(conditionId);
    if (!resolution.isResolved) {
      throw new Error('Market is not resolved yet');
    }

    // Auto-detect outcome if not provided
    const winningOutcome = outcome || resolution.winningOutcome;
    if (!winningOutcome) {
      throw new Error('Could not determine winning outcome');
    }

    // Get token balance using Polymarket token IDs
    const balances = await this.getPositionBalanceByTokenIds(conditionId, tokenIds);
    const tokenBalance = winningOutcome === 'YES' ? balances.yesBalance : balances.noBalance;

    if (parseFloat(tokenBalance) === 0) {
      throw new Error(`No ${winningOutcome} tokens to redeem`);
    }

    // indexSets: [1] for YES, [2] for NO
    const indexSets = winningOutcome === 'YES' ? [1] : [2];

    const tx = await this.ctfContract.redeemPositions(
      USDC_CONTRACT,
      ethers.constants.HashZero,
      conditionId,
      indexSets,
      await this.getGasOptions()
    );

    const receipt = await tx.wait();

    return {
      success: true,
      txHash: receipt.transactionHash,
      outcome: winningOutcome,
      tokensRedeemed: tokenBalance,
      usdcReceived: tokenBalance, // 1:1 for winning outcome
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Get token balances for a market using calculated position IDs
   *
   * NOTE: This method calculates position IDs from conditionId, which may not match
   * the token IDs used by Polymarket's CLOB API. For accurate balances when working
   * with CLOB markets, use getPositionBalanceByTokenIds() with the token IDs from
   * the CLOB API.
   *
   * @deprecated Use getPositionBalanceByTokenIds for CLOB markets
   */
  async getPositionBalance(conditionId: string): Promise<PositionBalance> {
    const yesPositionId = this.calculatePositionId(conditionId, 1);
    const noPositionId = this.calculatePositionId(conditionId, 2);

    const [yesBalance, noBalance] = await Promise.all([
      this.ctfContract.balanceOf(this.wallet.address, yesPositionId),
      this.ctfContract.balanceOf(this.wallet.address, noPositionId),
    ]);

    return {
      conditionId,
      yesBalance: ethers.utils.formatUnits(yesBalance, USDC_DECIMALS),
      noBalance: ethers.utils.formatUnits(noBalance, USDC_DECIMALS),
      yesPositionId,
      noPositionId,
    };
  }

  /**
   * Get token balances using CLOB API token IDs
   *
   * This is the recommended method for checking balances when working with
   * Polymarket CLOB markets. The token IDs should be obtained from the CLOB API
   * (e.g., from ClobApiClient.getMarket()).
   *
   * @param conditionId - Market condition ID (for reference)
   * @param tokenIds - Token IDs from CLOB API { yesTokenId, noTokenId }
   * @returns PositionBalance with accurate balances
   *
   * @example
   * ```typescript
   * // Get token IDs from CLOB API
   * const market = await clobApi.getMarket(conditionId);
   * const tokenIds = {
   *   yesTokenId: market.tokens[0].tokenId,
   *   noTokenId: market.tokens[1].tokenId,
   * };
   *
   * // Check balances
   * const balance = await ctf.getPositionBalanceByTokenIds(conditionId, tokenIds);
   * console.log(`YES: ${balance.yesBalance}, NO: ${balance.noBalance}`);
   * ```
   */
  async getPositionBalanceByTokenIds(
    conditionId: string,
    tokenIds: TokenIds
  ): Promise<PositionBalance> {
    const [yesBalance, noBalance] = await Promise.all([
      this.ctfContract.balanceOf(this.wallet.address, tokenIds.yesTokenId),
      this.ctfContract.balanceOf(this.wallet.address, tokenIds.noTokenId),
    ]);

    return {
      conditionId,
      yesBalance: ethers.utils.formatUnits(yesBalance, USDC_DECIMALS),
      noBalance: ethers.utils.formatUnits(noBalance, USDC_DECIMALS),
      yesPositionId: tokenIds.yesTokenId,
      noPositionId: tokenIds.noTokenId,
    };
  }

  /**
   * Check if a market is resolved and get payout info
   */
  async getMarketResolution(conditionId: string): Promise<MarketResolution> {
    const [yesNumerator, noNumerator, denominator] = await Promise.all([
      this.ctfContract.payoutNumerators(conditionId, 0),
      this.ctfContract.payoutNumerators(conditionId, 1),
      this.ctfContract.payoutDenominator(conditionId),
    ]);

    const isResolved = denominator.gt(0);
    let winningOutcome: 'YES' | 'NO' | undefined;

    if (isResolved) {
      if (yesNumerator.gt(0) && noNumerator.eq(0)) {
        winningOutcome = 'YES';
      } else if (noNumerator.gt(0) && yesNumerator.eq(0)) {
        winningOutcome = 'NO';
      }
      // If both are non-zero, it's a split resolution (rare)
    }

    return {
      conditionId,
      isResolved,
      winningOutcome,
      payoutNumerators: [yesNumerator.toNumber(), noNumerator.toNumber()],
      payoutDenominator: denominator.toNumber(),
    };
  }

  /**
   * Estimate gas for split operation
   */
  async estimateSplitGas(conditionId: string, amount: string): Promise<string> {
    const amountWei = ethers.utils.parseUnits(amount, USDC_DECIMALS);
    try {
      const gas = await this.ctfContract.estimateGas.splitPosition(
        USDC_CONTRACT,
        ethers.constants.HashZero,
        conditionId,
        [1, 2],
        amountWei
      );
      return gas.toString();
    } catch {
      // Default estimate if call fails (e.g., insufficient balance)
      return '250000';
    }
  }

  /**
   * Estimate gas for merge operation
   */
  async estimateMergeGas(conditionId: string, amount: string): Promise<string> {
    const amountWei = ethers.utils.parseUnits(amount, USDC_DECIMALS);
    try {
      const gas = await this.ctfContract.estimateGas.mergePositions(
        USDC_CONTRACT,
        ethers.constants.HashZero,
        conditionId,
        [1, 2],
        amountWei
      );
      return gas.toString();
    } catch {
      return '200000';
    }
  }

  // ===== Gas Estimation (Phase 3) =====

  /**
   * Get detailed gas estimate for a split operation
   */
  async getDetailedSplitGasEstimate(conditionId: string, amount: string): Promise<GasEstimate> {
    const gasUnits = await this.estimateSplitGas(conditionId, amount);
    return this.calculateGasCost(gasUnits);
  }

  /**
   * Get detailed gas estimate for a merge operation
   */
  async getDetailedMergeGasEstimate(conditionId: string, amount: string): Promise<GasEstimate> {
    const gasUnits = await this.estimateMergeGas(conditionId, amount);
    return this.calculateGasCost(gasUnits);
  }

  /**
   * Get current gas price info
   */
  async getGasPrice(): Promise<{ gwei: string; wei: string }> {
    const gasPrice = await this.provider.getGasPrice();
    return {
      gwei: ethers.utils.formatUnits(gasPrice, 'gwei'),
      wei: gasPrice.toString(),
    };
  }

  /**
   * Get or refresh MATIC price (cached for 5 minutes)
   */
  async getMaticPrice(): Promise<number> {
    const now = Date.now();
    const cacheAge = now - this.maticPriceLastUpdated;

    // Use cache if less than 5 minutes old
    if (cacheAge < 5 * 60 * 1000 && this.maticPriceLastUpdated > 0) {
      return this.cachedMaticPrice;
    }

    // In production, this would fetch from an oracle or price feed
    // For now, we return a reasonable estimate
    // Could integrate with Chainlink price feeds or CoinGecko API
    this.cachedMaticPrice = DEFAULT_MATIC_PRICE;
    this.maticPriceLastUpdated = now;

    return this.cachedMaticPrice;
  }

  /**
   * Set MATIC price manually (for testing or when external price is available)
   */
  setMaticPrice(price: number): void {
    this.cachedMaticPrice = price;
    this.maticPriceLastUpdated = Date.now();
  }

  // ===== Transaction Monitoring (Phase 3) =====

  /**
   * Get transaction status with detailed info
   */
  async getTransactionStatus(txHash: string): Promise<TransactionStatus> {
    try {
      const receipt = await this.provider.getTransactionReceipt(txHash);

      if (!receipt) {
        // Transaction is pending
        const tx = await this.provider.getTransaction(txHash);
        if (!tx) {
          return {
            txHash,
            status: 'failed',
            confirmations: 0,
            errorReason: 'Transaction not found',
          };
        }
        return {
          txHash,
          status: 'pending',
          confirmations: 0,
        };
      }

      const currentBlock = await this.provider.getBlockNumber();
      const confirmations = currentBlock - receipt.blockNumber + 1;

      if (receipt.status === 0) {
        // Transaction reverted
        const reason = await this.getRevertReason(txHash);
        return {
          txHash,
          status: 'reverted',
          confirmations,
          blockNumber: receipt.blockNumber,
          gasUsed: receipt.gasUsed.toString(),
          effectiveGasPrice: receipt.effectiveGasPrice?.toString(),
          errorReason: reason,
        };
      }

      return {
        txHash,
        status: 'confirmed',
        confirmations,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString(),
        effectiveGasPrice: receipt.effectiveGasPrice?.toString(),
      };
    } catch (error) {
      return {
        txHash,
        status: 'failed',
        confirmations: 0,
        errorReason: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Wait for transaction confirmation with timeout
   */
  async waitForTransaction(txHash: string, confirmations?: number): Promise<TransactionStatus> {
    const targetConfirmations = confirmations ?? this.confirmations;
    const startTime = Date.now();

    while (Date.now() - startTime < this.txTimeout) {
      const status = await this.getTransactionStatus(txHash);

      if (status.status === 'reverted' || status.status === 'failed') {
        return status;
      }

      if (status.status === 'confirmed' && status.confirmations >= targetConfirmations) {
        return status;
      }

      // Wait 2 seconds before checking again
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    return {
      txHash,
      status: 'pending',
      confirmations: 0,
      errorReason: `Timeout after ${this.txTimeout}ms`,
    };
  }

  /**
   * Parse revert reason from transaction
   */
  async getRevertReason(txHash: string): Promise<string> {
    try {
      const tx = await this.provider.getTransaction(txHash);
      if (!tx) return RevertReason.UNKNOWN;

      const receipt = await this.provider.getTransactionReceipt(txHash);
      if (!receipt || receipt.status !== 0) return RevertReason.UNKNOWN;

      // Try to call the transaction to get the revert reason
      try {
        await this.provider.call(tx as ethers.providers.TransactionRequest, tx.blockNumber);
        return RevertReason.UNKNOWN;
      } catch (error: unknown) {
        const err = error as { reason?: string; message?: string; data?: string };
        if (err.reason) return err.reason;
        if (err.message) {
          // Parse common error messages
          if (err.message.includes('insufficient balance')) {
            return RevertReason.INSUFFICIENT_BALANCE;
          }
          if (err.message.includes('allowance')) {
            return RevertReason.INSUFFICIENT_ALLOWANCE;
          }
          if (err.message.includes('condition not resolved')) {
            return RevertReason.CONDITION_NOT_RESOLVED;
          }
          return err.message;
        }
        return RevertReason.EXECUTION_REVERTED;
      }
    } catch {
      return RevertReason.UNKNOWN;
    }
  }

  // ===== Position Tracking (Phase 3) =====

  /**
   * Get all positions for the wallet across multiple markets
   */
  async getAllPositions(conditionIds: string[]): Promise<PositionBalance[]> {
    const positions: PositionBalance[] = [];

    for (const conditionId of conditionIds) {
      try {
        const balance = await this.getPositionBalance(conditionId);
        // Only include non-zero balances
        if (parseFloat(balance.yesBalance) > 0 || parseFloat(balance.noBalance) > 0) {
          positions.push(balance);
        }
      } catch {
        // Skip errors for individual markets
      }
    }

    return positions;
  }

  /**
   * Check if wallet has sufficient tokens for merge
   *
   * @deprecated Use canMergeWithTokenIds for CLOB markets
   */
  async canMerge(conditionId: string, amount: string): Promise<{ canMerge: boolean; reason?: string }> {
    try {
      const balances = await this.getPositionBalance(conditionId);
      return this.checkMergeBalance(balances, amount);
    } catch (error) {
      return {
        canMerge: false,
        reason: error instanceof Error ? error.message : 'Failed to check balances'
      };
    }
  }

  /**
   * Check if wallet has sufficient tokens for merge using CLOB token IDs
   *
   * @param conditionId - Market condition ID
   * @param tokenIds - Token IDs from CLOB API
   * @param amount - Amount to merge
   */
  async canMergeWithTokenIds(
    conditionId: string,
    tokenIds: TokenIds,
    amount: string
  ): Promise<{ canMerge: boolean; reason?: string }> {
    try {
      const balances = await this.getPositionBalanceByTokenIds(conditionId, tokenIds);
      return this.checkMergeBalance(balances, amount);
    } catch (error) {
      return {
        canMerge: false,
        reason: error instanceof Error ? error.message : 'Failed to check balances'
      };
    }
  }

  private checkMergeBalance(
    balances: PositionBalance,
    amount: string
  ): { canMerge: boolean; reason?: string } {
    const amountNum = parseFloat(amount);
    const yesBalance = parseFloat(balances.yesBalance);
    const noBalance = parseFloat(balances.noBalance);

    if (yesBalance < amountNum) {
      return {
        canMerge: false,
        reason: `Insufficient YES tokens. Have: ${yesBalance}, Need: ${amountNum}`
      };
    }
    if (noBalance < amountNum) {
      return {
        canMerge: false,
        reason: `Insufficient NO tokens. Have: ${noBalance}, Need: ${amountNum}`
      };
    }

    return { canMerge: true };
  }

  /**
   * Check if wallet has sufficient USDC for split
   */
  async canSplit(amount: string): Promise<{ canSplit: boolean; reason?: string }> {
    try {
      const balance = await this.getUsdcBalance();
      const balanceNum = parseFloat(balance);
      const amountNum = parseFloat(amount);

      if (balanceNum < amountNum) {
        return {
          canSplit: false,
          reason: `Insufficient USDC. Have: ${balance}, Need: ${amount}`
        };
      }

      return { canSplit: true };
    } catch (error) {
      return {
        canSplit: false,
        reason: error instanceof Error ? error.message : 'Failed to check balance'
      };
    }
  }

  /**
   * Get total portfolio value across positions
   */
  async getPortfolioValue(positions: PositionBalance[], prices: Map<string, { yes: number; no: number }>): Promise<{
    totalValue: number;
    breakdown: Array<{
      conditionId: string;
      yesValue: number;
      noValue: number;
      totalValue: number;
    }>;
  }> {
    let totalValue = 0;
    const breakdown: Array<{
      conditionId: string;
      yesValue: number;
      noValue: number;
      totalValue: number;
    }> = [];

    for (const position of positions) {
      const price = prices.get(position.conditionId);
      if (!price) continue;

      const yesValue = parseFloat(position.yesBalance) * price.yes;
      const noValue = parseFloat(position.noBalance) * price.no;
      const positionValue = yesValue + noValue;

      totalValue += positionValue;
      breakdown.push({
        conditionId: position.conditionId,
        yesValue,
        noValue,
        totalValue: positionValue,
      });
    }

    return { totalValue, breakdown };
  }

  // ===== Private Helpers =====

  /**
   * Calculate position ID for a given outcome (INTERNAL USE ONLY)
   *
   * ⚠️ WARNING: This calculation does NOT produce correct Polymarket token IDs!
   *
   * Polymarket uses custom token IDs that differ from standard CTF position ID calculation.
   * The token IDs from CLOB API (e.g., "104173557214744537570424345347209544585775842950109756851652855913015295701992")
   * are NOT the same as what this function calculates.
   *
   * For Polymarket CLOB markets, ALWAYS:
   * 1. Get token IDs from CLOB API: https://clob.polymarket.com/markets/{conditionId}
   * 2. Use getPositionBalanceByTokenIds() instead of getPositionBalance()
   * 3. Use mergeByTokenIds() instead of merge()
   * 4. Use redeemByTokenIds() instead of redeem()
   *
   * This method is kept for potential non-Polymarket CTF markets only.
   *
   * @deprecated Use CLOB API token IDs for Polymarket markets
   */
  private calculatePositionId(conditionId: string, indexSet: number): string {
    // Collection ID - must use solidityPack (abi.encodePacked) to match CTF contract
    const collectionId = ethers.utils.keccak256(
      ethers.utils.solidityPack(
        ['bytes32', 'bytes32', 'uint256'],
        [ethers.constants.HashZero, conditionId, indexSet]
      )
    );

    // Position ID - must use solidityPack (abi.encodePacked) to match CTF contract
    const positionId = ethers.utils.keccak256(
      ethers.utils.solidityPack(
        ['address', 'bytes32'],
        [USDC_CONTRACT, collectionId]
      )
    );

    return positionId;
  }

  /**
   * Get gas options for Polygon network using EIP-1559
   *
   * Polygon requires higher priority fees than default ethers.js estimates.
   * Uses minimum 30 gwei priority fee to ensure transactions don't get stuck.
   */
  private async getGasOptions(): Promise<{
    maxPriorityFeePerGas: BigNumber;
    maxFeePerGas: BigNumber;
  }> {
    const feeData = await this.provider.getFeeData();
    const baseFee = feeData.lastBaseFeePerGas || feeData.gasPrice || ethers.utils.parseUnits('100', 'gwei');

    // Minimum 30 gwei priority fee for Polygon
    const minPriorityFee = ethers.utils.parseUnits('30', 'gwei');
    const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas && feeData.maxPriorityFeePerGas.gt(minPriorityFee)
      ? feeData.maxPriorityFeePerGas
      : minPriorityFee;

    // Apply multiplier to base fee and add priority fee
    const adjustedBaseFee = baseFee.mul(Math.floor(this.gasPriceMultiplier * 100)).div(100);
    const maxFeePerGas = adjustedBaseFee.add(maxPriorityFeePerGas);

    return { maxPriorityFeePerGas, maxFeePerGas };
  }

  /**
   * Calculate gas cost from gas units
   */
  private async calculateGasCost(gasUnits: string): Promise<GasEstimate> {
    const gasOptions = await this.getGasOptions();
    const effectiveGasPrice = gasOptions.maxFeePerGas;

    const gasUnitsNum = BigNumber.from(gasUnits);
    const costWei = gasUnitsNum.mul(effectiveGasPrice);
    const costMatic = parseFloat(ethers.utils.formatEther(costWei));

    const maticPrice = await this.getMaticPrice();
    const costUsdc = costMatic * maticPrice;

    return {
      gasUnits,
      gasPriceGwei: ethers.utils.formatUnits(effectiveGasPrice, 'gwei'),
      costMatic: costMatic.toFixed(6),
      costUsdc: costUsdc.toFixed(4),
      maticPrice,
    };
  }
}

// ===== Utility Functions =====

/**
 * Calculate condition ID from oracle, question ID, and outcome count
 * This is rarely needed as Polymarket provides conditionId directly
 */
export function calculateConditionId(
  oracle: string,
  questionId: string,
  outcomeSlotCount: number = 2
): string {
  return ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(
      ['address', 'bytes32', 'uint256'],
      [oracle, questionId, outcomeSlotCount]
    )
  );
}

/**
 * Parse USDC amount to BigNumber (6 decimals)
 */
export function parseUsdc(amount: string): BigNumber {
  return ethers.utils.parseUnits(amount, USDC_DECIMALS);
}

/**
 * Format BigNumber to USDC string (6 decimals)
 */
export function formatUsdc(amount: BigNumber): string {
  return ethers.utils.formatUnits(amount, USDC_DECIMALS);
}

================================================================================
// File: src/clients/data-api.ts
================================================================================
/**
 * Data API Client for Polymarket
 * Handles: positions, activity, trades, leaderboard
 */

import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { CACHE_TTL } from '../core/unified-cache.js';
import { PolymarketError } from '../core/errors.js';

const DATA_API_BASE = 'https://data-api.polymarket.com';

// ===== Types =====

export interface Position {
  // Wallet identifier
  proxyWallet?: string;

  // Core identifiers
  asset: string; // ERC-1155 Token ID
  conditionId: string;
  outcome: string;
  outcomeIndex: number;

  // Position data
  size: number;
  avgPrice: number;
  curPrice?: number;
  totalBought?: number;

  // Value calculations
  initialValue?: number;
  currentValue?: number;
  cashPnl?: number; // Unrealized PnL
  percentPnl?: number;
  realizedPnl?: number;
  percentRealizedPnl?: number;

  // Market metadata (from API)
  title: string;
  slug?: string;
  icon?: string;
  eventId?: string;
  eventSlug?: string;

  // Opposite side info (for binary markets)
  oppositeOutcome?: string;
  oppositeAsset?: string;

  // Status fields (from API)
  redeemable?: boolean;
  mergeable?: boolean;
  endDate?: string;
  negativeRisk?: boolean;
}

export interface Activity {
  // Transaction type
  type: 'TRADE' | 'SPLIT' | 'MERGE' | 'REDEEM' | 'REWARD' | 'CONVERSION';
  side: 'BUY' | 'SELL';

  // Trade data
  size: number;
  price: number;
  usdcSize?: number;

  // Market identifiers
  asset: string;
  conditionId: string;
  outcome: string;
  outcomeIndex?: number;

  // Transaction info
  timestamp: number;
  transactionHash: string;

  // Market metadata (from API)
  title?: string;
  slug?: string;

  // Trader info (from API - returned as "name")
  name?: string;
}

export interface Trade {
  // Identifiers (id is optional - not always returned by API)
  id?: string;
  market: string; // conditionId (may come as "conditionId" from API)
  asset: string;

  // Trade data
  side: 'BUY' | 'SELL';
  price: number;
  size: number;
  outcome: string;
  outcomeIndex: number;

  // Transaction info
  timestamp: number;
  transactionHash: string;
  proxyWallet?: string;

  // Market metadata (from API)
  title?: string;
  slug?: string;
  icon?: string;
  eventSlug?: string;

  // Trader info (from API)
  name?: string;
  pseudonym?: string;
  bio?: string;
  profileImage?: string;
  profileImageOptimized?: string;
}

/**
 * Leaderboard entry from Polymarket Data API
 *
 * @see https://docs.polymarket.com/api-reference/core/get-trader-leaderboard-rankings
 *
 * Note: API 只返回 rank, proxyWallet, userName, vol, pnl, profileImage, xUsername, verifiedBadge
 * positions 和 trades 字段 API 通常返回 null，需要调用 Profile API 获取详细数据
 */
export interface LeaderboardEntry {
  /** 钱包地址 (从 proxyWallet 标准化) */
  address: string;

  /** 排名 (从 string 转为 number) */
  rank: number;
  /** 盈亏 (USDC) */
  pnl: number;
  /** 交易量 (USDC, 从 vol 重命名) */
  volume: number;

  /** 用户名 */
  userName?: string;
  /** Twitter 用户名 */
  xUsername?: string;
  /** 是否已验证 */
  verifiedBadge?: boolean;
  /** 头像 URL */
  profileImage?: string;

  /** 持仓数量 (API 通常返回 null，需要 Profile API) */
  positions?: number;
  /** 交易次数 (API 通常返回 null，需要 Profile API) */
  trades?: number;
}

/**
 * Leaderboard result from Polymarket Data API
 *
 * @see https://docs.polymarket.com/api-reference/core/get-trader-leaderboard-rankings
 *
 * ## 设计说明
 * Polymarket API 返回纯数组，不包含分页元数据 (无 total, offset, limit)。
 * 本接口添加辅助字段以方便前端分页:
 * - `hasMore`: 推断值，当 entries.length === request.limit 时为 true
 * - `request`: 请求参数回显，方便计算页码
 *
 * ## 为什么不返回 total?
 * 因为 API 不提供，我们不伪造。用 hasMore 来判断是否有下一页。
 */
export interface LeaderboardResult {
  /** API 返回的排行榜条目 */
  entries: LeaderboardEntry[];
  /** 是否可能有更多数据 (entries.length === request.limit) */
  hasMore: boolean;
  /** 请求参数回显，方便前端分页计算 */
  request: {
    offset: number;
    limit: number;
  };
}

// ===== Leaderboard Parameters =====

/**
 * Time period for leaderboard filtering
 */
export type LeaderboardTimePeriod = 'DAY' | 'WEEK' | 'MONTH' | 'ALL';

/**
 * Ordering criteria for leaderboard
 */
export type LeaderboardOrderBy = 'PNL' | 'VOL';

/**
 * Market category for leaderboard filtering
 */
export type LeaderboardCategory =
  | 'OVERALL'
  | 'POLITICS'
  | 'SPORTS'
  | 'CRYPTO'
  | 'CULTURE'
  | 'MENTIONS'
  | 'WEATHER'
  | 'ECONOMICS'
  | 'TECH'
  | 'FINANCE';

/**
 * Leaderboard query parameters
 * @see https://docs.polymarket.com/api-reference/core/get-trader-leaderboard-rankings
 */
export interface LeaderboardParams {
  /** Time period for leaderboard results (default: DAY) */
  timePeriod?: LeaderboardTimePeriod;
  /** Ordering criteria (default: PNL) */
  orderBy?: LeaderboardOrderBy;
  /** Market category filter (default: OVERALL) */
  category?: LeaderboardCategory;
  /** Max number of traders to return (1-50, default: 25) */
  limit?: number;
  /** Starting index for pagination (0-1000, default: 0) */
  offset?: number;
  /** Filter by specific user address */
  user?: string;
  /** Filter by username */
  userName?: string;
}

// ===== Parameter Types (P0/P1/P2 Gap Analysis) =====

/**
 * Activity query parameters
 * @see https://docs.polymarket.com/developers/misc-endpoints/data-api-activity
 */
export interface ActivityParams {
  /** Maximum number of results (0-500, default: 100) */
  limit?: number;
  /** Pagination offset (0-10000) */
  offset?: number;
  /** Start timestamp (Unix seconds) - filter activities after this time */
  start?: number;
  /** End timestamp (Unix seconds) - filter activities before this time */
  end?: number;
  /** Activity type filter */
  type?: 'TRADE' | 'SPLIT' | 'MERGE' | 'REDEEM' | 'REWARD' | 'CONVERSION';
  /** Trade side filter */
  side?: 'BUY' | 'SELL';
  /** Market condition IDs to filter */
  market?: string[];
  /** Event IDs to filter */
  eventId?: number[];
  /** Sort field */
  sortBy?: 'TIMESTAMP' | 'TOKENS' | 'CASH';
  /** Sort direction */
  sortDirection?: 'ASC' | 'DESC';
}

/**
 * Positions query parameters
 * @see https://docs.polymarket.com/developers/misc-endpoints/data-api-get-positions
 */
export interface PositionsParams {
  /** Maximum number of results (0-500, default: 100) */
  limit?: number;
  /** Pagination offset (0-10000) */
  offset?: number;
  /** Market condition IDs to filter */
  market?: string[];
  /** Event IDs to filter */
  eventId?: number[];
  /** Minimum position size to include (default: 1) */
  sizeThreshold?: number;
  /** Only return redeemable positions */
  redeemable?: boolean;
  /** Only return mergeable positions */
  mergeable?: boolean;
  /** Search by title */
  title?: string;
  /** Sort field */
  sortBy?: 'CURRENT' | 'INITIAL' | 'TOKENS' | 'CASHPNL' | 'PERCENTPNL' | 'TITLE' | 'RESOLVING' | 'PRICE' | 'AVGPRICE';
  /** Sort direction */
  sortDirection?: 'ASC' | 'DESC';
}

/**
 * Trades query parameters
 */
export interface TradesParams {
  /** Maximum number of results (default: 500) */
  limit?: number;
  /** Market condition ID to filter */
  market?: string;
  /** User wallet address to filter */
  user?: string;
  /** Only return taker trades */
  takerOnly?: boolean;
  /** Filter by cash or token amount */
  filterType?: 'CASH' | 'TOKENS';
  /** Minimum amount threshold */
  filterAmount?: number;
  /** Trade side filter */
  side?: 'BUY' | 'SELL';
  /** Start timestamp (Unix milliseconds) - filter trades after this time */
  startTimestamp?: number;
  /** End timestamp (Unix milliseconds) - filter trades before this time */
  endTimestamp?: number;
}

/**
 * Closed positions query parameters
 * @see https://docs.polymarket.com/api-reference/core/get-closed-positions-for-a-user
 */
export interface ClosedPositionsParams {
  /** Maximum number of results (0-50, default: 10) */
  limit?: number;
  /** Pagination offset (0-100000) */
  offset?: number;
  /** Market condition IDs to filter */
  market?: string[];
  /** Event IDs to filter */
  eventId?: number[];
  /** Search by title (max 100 chars) */
  title?: string;
  /** Sort field */
  sortBy?: 'REALIZEDPNL' | 'TITLE' | 'PRICE' | 'AVGPRICE' | 'TIMESTAMP';
  /** Sort direction */
  sortDirection?: 'ASC' | 'DESC';
}

/**
 * Closed position entry
 */
export interface ClosedPosition {
  proxyWallet: string;
  asset: string;
  conditionId: string;

  // Trade data
  avgPrice: number;
  totalBought: number;
  realizedPnl: number;
  curPrice: number;  // Settlement price (0 or 1)
  timestamp: number;

  // Market info
  title: string;
  slug?: string;
  icon?: string;
  eventSlug?: string;
  outcome: string;
  outcomeIndex: number;
  oppositeOutcome?: string;
  oppositeAsset?: string;
  endDate?: string;
}

/**
 * Holders query parameters
 */
export interface HoldersParams {
  /** Market condition ID (required) */
  market: string;
  /** Maximum number of results */
  limit?: number;
}

/**
 * Account value response
 */
export interface AccountValue {
  user: string;
  value: number;
}

/**
 * Market holder entry
 */
export interface MarketHolder {
  proxyWallet: string;
  size: number;
  outcome: string;
  value?: number;
  userName?: string;
  profileImage?: string;
}

// ===== Client =====

export class DataApiClient {
  constructor(
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache
  ) {}

  // ===== Wallet-related =====

  /**
   * Get positions for a wallet address
   *
   * @param address - Wallet address
   * @param params - Query parameters (P0/P1: limit, offset, sortBy, sortDirection, market, etc.)
   *
   * @example
   * ```typescript
   * // Get all positions
   * const positions = await client.getPositions(address);
   *
   * // Get positions sorted by PnL (highest first)
   * const topPnl = await client.getPositions(address, {
   *   sortBy: 'CASHPNL',
   *   sortDirection: 'DESC',
   *   limit: 10,
   * });
   *
   * // Get only redeemable positions
   * const redeemable = await client.getPositions(address, { redeemable: true });
   * ```
   */
  async getPositions(address: string, params?: PositionsParams): Promise<Position[]> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams({ user: address });

      // P0: limit, offset
      if (params?.limit !== undefined) query.set('limit', String(params.limit));
      if (params?.offset !== undefined) query.set('offset', String(params.offset));

      // P1: sortBy, sortDirection, market
      if (params?.sortBy) query.set('sortBy', params.sortBy);
      if (params?.sortDirection) query.set('sortDirection', params.sortDirection);
      if (params?.market) {
        params.market.forEach((m) => query.append('market', m));
      }
      if (params?.eventId) {
        params.eventId.forEach((id) => query.append('eventId', String(id)));
      }

      // P1: sizeThreshold, redeemable, mergeable, title
      if (params?.sizeThreshold !== undefined) query.set('sizeThreshold', String(params.sizeThreshold));
      if (params?.redeemable !== undefined) query.set('redeemable', String(params.redeemable));
      if (params?.mergeable !== undefined) query.set('mergeable', String(params.mergeable));
      if (params?.title) query.set('title', params.title);

      const response = await fetch(`${DATA_API_BASE}/positions?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      return this.normalizePositions(data);
    });
  }

  /**
   * Get closed positions for a wallet address
   *
   * @param address - Wallet address
   * @param params - Query parameters
   *
   * @example
   * ```typescript
   * // Get closed positions sorted by realized PnL
   * const closed = await client.getClosedPositions(address);
   *
   * // Get recent settlements
   * const recent = await client.getClosedPositions(address, {
   *   sortBy: 'TIMESTAMP',
   *   sortDirection: 'DESC',
   *   limit: 20,
   * });
   * ```
   */
  async getClosedPositions(address: string, params?: ClosedPositionsParams): Promise<ClosedPosition[]> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams({ user: address });

      // Pagination
      if (params?.limit !== undefined) query.set('limit', String(params.limit));
      if (params?.offset !== undefined) query.set('offset', String(params.offset));

      // Filters
      if (params?.market) {
        params.market.forEach((m) => query.append('market', m));
      }
      if (params?.eventId) {
        params.eventId.forEach((id) => query.append('eventId', String(id)));
      }
      if (params?.title) query.set('title', params.title);

      // Sorting
      if (params?.sortBy) query.set('sortBy', params.sortBy);
      if (params?.sortDirection) query.set('sortDirection', params.sortDirection);

      const response = await fetch(`${DATA_API_BASE}/closed-positions?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      return this.normalizeClosedPositions(data);
    });
  }

  /**
   * Get activity for a wallet address
   *
   * @param address - Wallet address
   * @param params - Query parameters (P0: start, end, offset; P1: market, sortBy, etc.)
   *
   * @example
   * ```typescript
   * // Get recent activity
   * const activity = await client.getActivity(address, { limit: 50 });
   *
   * // Get activity in a time range (Unix seconds)
   * const dayAgo = Math.floor(Date.now() / 1000) - 86400;
   * const recent = await client.getActivity(address, {
   *   start: dayAgo,
   *   limit: 100,
   * });
   *
   * // Paginate through all activity
   * const page2 = await client.getActivity(address, { offset: 100, limit: 100 });
   * ```
   */
  async getActivity(address: string, params?: ActivityParams): Promise<Activity[]> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams({ user: address });

      // Basic params
      query.set('limit', String(params?.limit ?? 100));

      // P0: offset, start, end (time filtering and pagination)
      if (params?.offset !== undefined) query.set('offset', String(params.offset));
      if (params?.start !== undefined) query.set('start', String(params.start));
      if (params?.end !== undefined) query.set('end', String(params.end));

      // P1: type, side, market, eventId
      if (params?.type) query.set('type', params.type);
      if (params?.side) query.set('side', params.side);
      if (params?.market) {
        params.market.forEach((m) => query.append('market', m));
      }
      if (params?.eventId) {
        params.eventId.forEach((id) => query.append('eventId', String(id)));
      }

      // P2: sortBy, sortDirection
      if (params?.sortBy) query.set('sortBy', params.sortBy);
      if (params?.sortDirection) query.set('sortDirection', params.sortDirection);

      const response = await fetch(`${DATA_API_BASE}/activity?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      return this.normalizeActivities(data);
    });
  }

  /**
   * Get all activity for a wallet (auto-pagination)
   *
   * **⚠️ IMPORTANT: API Limitation**
   * The Polymarket API has a hard offset limit of 10,000. This means:
   * - Maximum ~10,500 records can be retrieved via offset pagination
   * - For active traders, this may only cover a few hours of history
   * - Use `start` and `end` params for time-based filtering to access older data
   *
   * @param address - Wallet address
   * @param params - Query parameters (use `start`/`end` for time filtering)
   * @param maxItems - Maximum items to fetch (default: 10000, capped by API offset limit)
   *
   * @example
   * ```typescript
   * // Get all recent activity (limited by API offset)
   * const allActivity = await client.getAllActivity(address);
   *
   * // Get activity for a specific time window (recommended for complete history)
   * const oneWeekAgo = Math.floor(Date.now() / 1000) - 7 * 24 * 60 * 60;
   * const weekActivity = await client.getAllActivity(address, { start: oneWeekAgo });
   * ```
   */
  async getAllActivity(
    address: string,
    params?: Omit<ActivityParams, 'offset' | 'limit'>,
    maxItems = 10000
  ): Promise<Activity[]> {
    const all: Activity[] = [];
    const limit = 500; // Max allowed by API
    const API_OFFSET_LIMIT = 10000; // Hard limit from Polymarket API
    let offset = 0;

    while (all.length < maxItems && offset < API_OFFSET_LIMIT) {
      const page = await this.getActivity(address, { ...params, limit, offset });
      all.push(...page);
      if (page.length < limit) break; // No more data
      offset += limit;
    }

    // Warn if we hit the API offset limit
    if (offset >= API_OFFSET_LIMIT && all.length >= API_OFFSET_LIMIT) {
      console.warn(
        `[DataApiClient] Hit API offset limit (${API_OFFSET_LIMIT}). ` +
          'Use time filtering (start/end params) to access older activity data.'
      );
    }

    return all.slice(0, maxItems);
  }

  // ===== Trade-related =====

  /**
   * Get recent trades
   *
   * @param params - Query parameters (P2: user, side, takerOnly, etc.)
   *
   * @example
   * ```typescript
   * // Get market trades
   * const trades = await client.getTrades({ market: conditionId, limit: 100 });
   *
   * // Get user trades (P2)
   * const userTrades = await client.getTrades({ user: address, limit: 50 });
   *
   * // Get only buy trades
   * const buys = await client.getTrades({ market: conditionId, side: 'BUY' });
   * ```
   */
  async getTrades(params?: TradesParams): Promise<Trade[]> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams();
      // Request more if we need to filter by time (to ensure we get enough after filtering)
      const requestLimit = (params?.startTimestamp || params?.endTimestamp)
        ? Math.min((params?.limit ?? 500) * 3, 1000)
        : (params?.limit ?? 500);
      query.set('limit', String(requestLimit));

      // Basic filters
      if (params?.market) query.set('market', params.market);

      // P2: user filter
      if (params?.user) query.set('user', params.user);

      // P2: additional filters
      if (params?.side) query.set('side', params.side);
      if (params?.takerOnly !== undefined) query.set('takerOnly', String(params.takerOnly));
      if (params?.filterType) query.set('filterType', params.filterType);
      if (params?.filterAmount !== undefined) query.set('filterAmount', String(params.filterAmount));

      const response = await fetch(`${DATA_API_BASE}/trades?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      let trades = this.normalizeTrades(data);

      // Apply timestamp filters client-side (API may not support these directly)
      if (params?.startTimestamp) {
        trades = trades.filter(t => t.timestamp >= params.startTimestamp!);
      }
      if (params?.endTimestamp) {
        trades = trades.filter(t => t.timestamp <= params.endTimestamp!);
      }

      // Apply limit after filtering
      if (params?.limit && trades.length > params.limit) {
        trades = trades.slice(0, params.limit);
      }

      return trades;
    });
  }

  /**
   * Get trades for a specific market
   */
  async getTradesByMarket(conditionId: string, limit = 500): Promise<Trade[]> {
    return this.getTrades({ market: conditionId, limit });
  }

  /**
   * Get trades for a specific user (P2)
   */
  async getTradesByUser(address: string, params?: Omit<TradesParams, 'user'>): Promise<Trade[]> {
    return this.getTrades({ ...params, user: address });
  }

  // ===== Leaderboard =====

  /**
   * Fetch leaderboard entries from Polymarket Data API
   *
   * @see https://docs.polymarket.com/api-reference/core/get-trader-leaderboard-rankings
   *
   * ## API 返回字段
   * 原始 API 只返回以下字段:
   * - rank (string) - 排名
   * - proxyWallet (string) - 钱包地址
   * - userName (string) - 用户名
   * - vol (number) - 交易量
   * - pnl (number) - 盈亏
   * - profileImage (string) - 头像 URL
   * - xUsername (string | null) - Twitter 用户名
   * - verifiedBadge (boolean) - 是否已验证
   *
   * ## API 不返回的字段
   * 以下字段需要调用 Profile API 获取:
   * - tradeCount, buyCount, sellCount
   * - positionCount, winRate
   * - unrealizedPnl (需要从 positions 计算)
   *
   * ## 分页说明
   * - API 返回纯数组，无 total 字段
   * - hasMore 是推断值: entries.length === limit 时为 true
   * - request 是请求参数回显，方便前端分页
   *
   * @param params - Query parameters
   * @param params.timePeriod - Time period: 'DAY', 'WEEK', 'MONTH', 'ALL' (default: 'ALL')
   * @param params.orderBy - Order by: 'PNL', 'VOL' (default: 'PNL')
   * @param params.category - Category filter (default: 'OVERALL')
   * @param params.limit - Max entries per page (1-50, default: 50)
   * @param params.offset - Pagination offset (0-1000, default: 0)
   *
   * @example
   * ```typescript
   * // Get this week's top traders by PnL
   * const result = await client.fetchLeaderboard({ timePeriod: 'WEEK', limit: 20 });
   * console.log(result.entries);   // actual traders from API
   * console.log(result.hasMore);   // true if may have more data
   * console.log(result.request);   // { offset: 0, limit: 20 }
   *
   * // Pagination
   * const page2 = await client.fetchLeaderboard({ timePeriod: 'WEEK', limit: 20, offset: 20 });
   * ```
   */
  async fetchLeaderboard(params?: LeaderboardParams): Promise<LeaderboardResult> {
    const {
      timePeriod = 'ALL',
      orderBy = 'PNL',
      category = 'OVERALL',
      limit = 50,
      offset = 0,
      user,
      userName,
    } = params || {};

    const cacheKey = `leaderboard:${timePeriod}:${orderBy}:${category}:${offset}:${limit}`;

    return this.cache.getOrSet(cacheKey, CACHE_TTL.LEADERBOARD, async () => {
      const query = new URLSearchParams({
        timePeriod,
        orderBy,
        category,
        limit: String(limit),
        offset: String(offset),
      });

      if (user) query.set('user', user);
      if (userName) query.set('userName', userName);

      return this.rateLimiter.execute(ApiType.DATA_API, async () => {
        const response = await fetch(
          `${DATA_API_BASE}/v1/leaderboard?${query}`
        );
        if (!response.ok)
          throw PolymarketError.fromHttpError(
            response.status,
            await response.json().catch(() => null)
          );

        const data = (await response.json()) as unknown[];
        const entries = this.normalizeLeaderboardEntries(data);

        return {
          entries,
          hasMore: entries.length === limit,
          request: { offset, limit },
        };
      });
    });
  }

  /**
   * Get all leaderboard entries up to a max count
   */
  async getAllLeaderboard(maxEntries = 500): Promise<LeaderboardEntry[]> {
    const all: LeaderboardEntry[] = [];
    let offset = 0;
    const limit = 50;

    while (all.length < maxEntries) {
      const result = await this.fetchLeaderboard({ limit, offset });
      all.push(...result.entries);
      if (!result.hasMore) break;
      offset += limit;
    }

    return all.slice(0, maxEntries);
  }

  // ===== Value & Holders (P1/P2) =====

  /**
   * Get account total value (P1)
   *
   * @param address - Wallet address
   * @param markets - Optional: filter by specific markets
   *
   * @example
   * ```typescript
   * const { value } = await client.getAccountValue(address);
   * console.log(`Total account value: $${value.toFixed(2)}`);
   * ```
   */
  async getAccountValue(address: string, markets?: string[]): Promise<AccountValue> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams({ user: address });
      if (markets) {
        markets.forEach((m) => query.append('market', m));
      }

      const response = await fetch(`${DATA_API_BASE}/value?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );

      // API returns array: [{ user, value }]
      const data = (await response.json()) as Array<{ user: string; value: number }>;
      if (Array.isArray(data) && data.length > 0) {
        return {
          user: String(data[0].user),
          value: Number(data[0].value) || 0,
        };
      }
      return { user: address, value: 0 };
    });
  }

  /**
   * Get market holders (P2)
   *
   * Returns top holders for a specific market. Note: This endpoint can timeout
   * for large markets.
   *
   * @param params - Query parameters (market is required)
   *
   * @example
   * ```typescript
   * const holders = await client.getMarketHolders({
   *   market: conditionId,
   *   limit: 20,
   * });
   * ```
   */
  async getMarketHolders(params: HoldersParams): Promise<MarketHolder[]> {
    return this.rateLimiter.execute(ApiType.DATA_API, async () => {
      const query = new URLSearchParams({ market: params.market });
      if (params.limit !== undefined) query.set('limit', String(params.limit));

      const response = await fetch(`${DATA_API_BASE}/holders?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );

      const data = (await response.json()) as unknown[];
      return this.normalizeHolders(data);
    });
  }

  // ===== Data Normalization =====

  private normalizePositions(data: unknown[]): Position[] {
    if (!Array.isArray(data)) return [];
    return data.map((item) => {
      const p = item as Record<string, unknown>;
      return {
        // Wallet identifier
        proxyWallet: p.proxyWallet !== undefined ? String(p.proxyWallet) : undefined,

        // Core identifiers
        asset: String(p.asset || ''),
        conditionId: String(p.conditionId || ''),
        outcome: String(p.outcome || ''),
        // Only use outcomeIndex if provided by API - don't infer from outcome name
        // (non-binary markets have arbitrary outcome names)
        outcomeIndex: typeof p.outcomeIndex === 'number' ? p.outcomeIndex : 0,

        // Position data
        size: Number(p.size),
        avgPrice: Number(p.avgPrice),
        curPrice: p.curPrice !== undefined ? Number(p.curPrice) : undefined,
        totalBought: p.totalBought !== undefined ? Number(p.totalBought) : undefined,

        // Value calculations
        initialValue:
          p.initialValue !== undefined ? Number(p.initialValue) : undefined,
        currentValue:
          p.currentValue !== undefined ? Number(p.currentValue) : undefined,
        cashPnl: p.cashPnl !== undefined ? Number(p.cashPnl) : undefined,
        percentPnl:
          p.percentPnl !== undefined ? Number(p.percentPnl) : undefined,
        realizedPnl:
          p.realizedPnl !== undefined ? Number(p.realizedPnl) : undefined,
        percentRealizedPnl:
          p.percentRealizedPnl !== undefined ? Number(p.percentRealizedPnl) : undefined,

        // Market metadata
        title: String(p.title || ''),
        slug: p.slug !== undefined ? String(p.slug) : undefined,
        icon: p.icon !== undefined ? String(p.icon) : undefined,
        eventId: p.eventId !== undefined ? String(p.eventId) : undefined,
        eventSlug: p.eventSlug !== undefined ? String(p.eventSlug) : undefined,

        // Opposite side info
        oppositeOutcome: p.oppositeOutcome !== undefined ? String(p.oppositeOutcome) : undefined,
        oppositeAsset: p.oppositeAsset !== undefined ? String(p.oppositeAsset) : undefined,

        // Status fields
        redeemable: p.redeemable !== undefined ? Boolean(p.redeemable) : undefined,
        mergeable: p.mergeable !== undefined ? Boolean(p.mergeable) : undefined,
        endDate: p.endDate !== undefined ? String(p.endDate) : undefined,
        negativeRisk: p.negativeRisk !== undefined ? Boolean(p.negativeRisk) : undefined,
      };
    });
  }

  private normalizeClosedPositions(data: unknown[]): ClosedPosition[] {
    if (!Array.isArray(data)) return [];
    return data.map((item) => {
      const p = item as Record<string, unknown>;
      return {
        proxyWallet: String(p.proxyWallet || ''),
        asset: String(p.asset || ''),
        conditionId: String(p.conditionId || ''),

        // Trade data
        avgPrice: Number(p.avgPrice) || 0,
        totalBought: Number(p.totalBought) || 0,
        realizedPnl: Number(p.realizedPnl) || 0,
        curPrice: Number(p.curPrice) || 0,
        timestamp: this.normalizeTimestamp(p.timestamp),

        // Market info
        title: String(p.title || ''),
        slug: p.slug !== undefined ? String(p.slug) : undefined,
        icon: p.icon !== undefined ? String(p.icon) : undefined,
        eventSlug: p.eventSlug !== undefined ? String(p.eventSlug) : undefined,
        outcome: String(p.outcome || ''),
        // Only use outcomeIndex if provided by API - don't infer from outcome name
        outcomeIndex: typeof p.outcomeIndex === 'number' ? p.outcomeIndex : 0,
        oppositeOutcome: p.oppositeOutcome !== undefined ? String(p.oppositeOutcome) : undefined,
        oppositeAsset: p.oppositeAsset !== undefined ? String(p.oppositeAsset) : undefined,
        endDate: p.endDate !== undefined ? String(p.endDate) : undefined,
      };
    });
  }

  private normalizeActivities(data: unknown[]): Activity[] {
    if (!Array.isArray(data)) return [];
    return data.map((item) => {
      const a = item as Record<string, unknown>;
      return {
        // Transaction type
        type: String(a.type) as Activity['type'],
        side: String(a.side) as Activity['side'],

        // Trade data
        size: Number(a.size),
        price: Number(a.price),
        usdcSize:
          a.usdcSize !== undefined
            ? Number(a.usdcSize)
            : Number(a.size) * Number(a.price),

        // Market identifiers
        asset: String(a.asset || ''),
        conditionId: String(a.conditionId || ''),
        outcome: String(a.outcome || ''),
        outcomeIndex:
          a.outcomeIndex !== undefined ? Number(a.outcomeIndex) : undefined,

        // Transaction info
        timestamp: this.normalizeTimestamp(a.timestamp),
        transactionHash: String(a.transactionHash || ''),

        // Market metadata
        title: a.title !== undefined ? String(a.title) : undefined,
        slug: a.slug !== undefined ? String(a.slug) : undefined,

        // Trader info
        name: a.name !== undefined ? String(a.name) : undefined,
      };
    });
  }

  private normalizeTrades(data: unknown[]): Trade[] {
    if (!Array.isArray(data)) return [];
    return data.map((item) => {
      const t = item as Record<string, unknown>;
      return {
        // Identifiers
        id: t.id !== undefined ? String(t.id) : undefined,
        market: String(t.market || t.conditionId || ''),
        asset: String(t.asset || ''),

        // Trade data
        side: String(t.side) as Trade['side'],
        price: Number(t.price),
        size: Number(t.size),
        outcome: String(t.outcome || ''),
        // Only use outcomeIndex if provided by API - don't infer from outcome name
        outcomeIndex: typeof t.outcomeIndex === 'number' ? t.outcomeIndex : 0,

        // Transaction info
        timestamp: this.normalizeTimestamp(t.timestamp),
        transactionHash: String(t.transactionHash || ''),
        proxyWallet:
          t.proxyWallet !== undefined ? String(t.proxyWallet) : undefined,

        // Market metadata
        title: t.title !== undefined ? String(t.title) : undefined,
        slug: t.slug !== undefined ? String(t.slug) : undefined,
        icon: t.icon !== undefined ? String(t.icon) : undefined,
        eventSlug: t.eventSlug !== undefined ? String(t.eventSlug) : undefined,

        // Trader info
        name: t.name !== undefined ? String(t.name) : undefined,
        pseudonym: t.pseudonym !== undefined ? String(t.pseudonym) : undefined,
        bio: t.bio !== undefined ? String(t.bio) : undefined,
        profileImage: t.profileImage !== undefined ? String(t.profileImage) : undefined,
        profileImageOptimized: t.profileImageOptimized !== undefined ? String(t.profileImageOptimized) : undefined,
      };
    });
  }

  private normalizeTimestamp(ts: unknown): number {
    if (typeof ts === 'number') {
      // If timestamp is in seconds, convert to milliseconds
      return ts < 1e12 ? ts * 1000 : ts;
    }
    if (typeof ts === 'string') {
      const num = parseInt(ts, 10);
      return num < 1e12 ? num * 1000 : num;
    }
    return Date.now();
  }

  private normalizeLeaderboardEntries(data: unknown[]): LeaderboardEntry[] {
    if (!Array.isArray(data)) return [];
    return data.map((item) => {
      const e = item as Record<string, unknown>;
      return {
        // Wallet identifier
        address: String(e.proxyWallet || e.address || ''),

        // Ranking data
        rank: typeof e.rank === 'number' ? e.rank : parseInt(String(e.rank), 10) || 0,
        pnl: Number(e.pnl) || 0,
        volume: Number(e.vol || e.volume) || 0,

        // User profile
        userName: e.userName !== undefined ? String(e.userName) : undefined,
        xUsername: e.xUsername !== undefined ? String(e.xUsername) : undefined,
        verifiedBadge: Boolean(e.verifiedBadge),
        profileImage: e.profileImage !== undefined ? String(e.profileImage) : undefined,

        // Activity counts (optional - API often returns null)
        positions: e.positions != null ? Number(e.positions) : undefined,
        trades: e.trades != null ? Number(e.trades) : undefined,
      };
    });
  }

  private normalizeHolders(data: unknown[]): MarketHolder[] {
    if (!Array.isArray(data)) return [];

    // The API returns grouped by token: [{ token, holders: [...] }, { token, holders: [...] }]
    // We need to flatten this and normalize each holder
    const result: MarketHolder[] = [];

    for (const item of data) {
      const tokenGroup = item as Record<string, unknown>;

      // Check if this is the grouped format (has 'holders' array)
      if (Array.isArray(tokenGroup.holders)) {
        for (const holder of tokenGroup.holders as Record<string, unknown>[]) {
          result.push({
            proxyWallet: String(holder.proxyWallet || holder.address || ''),
            size: Number(holder.amount || holder.size) || 0,
            // Map outcomeIndex to outcome name (0 = Yes/Up, 1 = No/Down)
            outcome: holder.outcomeIndex === 0 ? 'Yes' : holder.outcomeIndex === 1 ? 'No' : String(holder.outcome || ''),
            value: holder.value !== undefined ? Number(holder.value) : undefined,
            userName: holder.name !== undefined ? String(holder.name) : (holder.userName !== undefined ? String(holder.userName) : undefined),
            profileImage: holder.profileImage !== undefined ? String(holder.profileImage) : undefined,
          });
        }
      } else {
        // Fallback: flat format (for backwards compatibility)
        const h = tokenGroup;
        result.push({
          proxyWallet: String(h.proxyWallet || h.address || ''),
          size: Number(h.amount || h.size) || 0,
          outcome: h.outcomeIndex === 0 ? 'Yes' : h.outcomeIndex === 1 ? 'No' : String(h.outcome || ''),
          value: h.value !== undefined ? Number(h.value) : undefined,
          userName: h.name !== undefined ? String(h.name) : (h.userName !== undefined ? String(h.userName) : undefined),
          profileImage: h.profileImage !== undefined ? String(h.profileImage) : undefined,
        });
      }
    }

    return result;
  }
}

================================================================================
// File: src/clients/gamma-api.ts
================================================================================
/**
 * Gamma API Client for Polymarket
 *
 * The Gamma API provides rich market discovery and metadata. Unlike the CLOB API
 * which is focused on trading, Gamma is optimized for browsing, searching, and
 * discovering prediction markets.
 *
 * @remarks
 * - Base URL: https://gamma-api.polymarket.com
 * - Best for: Market discovery, trending markets, event groupings
 * - Rate limits are automatically handled by the RateLimiter
 *
 * @example
 * ```typescript
 * import { GammaApiClient, RateLimiter, Cache } from '@catalyst-team/poly-sdk';
 *
 * const client = new GammaApiClient(new RateLimiter(), new Cache());
 *
 * // Get trending markets by 24h volume
 * const trending = await client.getTrendingMarkets(20);
 *
 * // Search for specific markets
 * const btcMarkets = await client.getMarkets({
 *   active: true,
 *   closed: false,
 *   order: 'volume24hr',
 *   ascending: false,
 *   limit: 10,
 * });
 * ```
 *
 * @see {@link https://docs.polymarket.com/#gamma-api Gamma API Documentation}
 *
 * @module clients/gamma-api
 */

import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { PolymarketError } from '../core/errors.js';

/** Gamma API base URL */
const GAMMA_API_BASE = 'https://gamma-api.polymarket.com';

// ===== Types =====

/**
 * Market information from the Gamma API
 *
 * @remarks
 * Gamma markets include rich metadata like volume statistics, price changes,
 * and liquidity metrics that are useful for market discovery and analysis.
 */
export interface GammaMarket {
  /**
   * Internal Gamma market ID
   */
  id: string;

  /**
   * Condition ID matching the CLOB API
   * @example "0x82ace55cdcba920112a2b3548f21e6e117730144db4dd580456aaecf1a2ad751"
   */
  conditionId: string;

  /**
   * URL-friendly market slug
   * @example "will-btc-reach-100k-by-end-of-2024"
   */
  slug: string;

  /**
   * The prediction market question
   */
  question: string;

  /**
   * Detailed description and resolution criteria
   */
  description?: string;

  /**
   * Outcome names (typically ["Yes", "No"])
   */
  outcomes: string[];

  /**
   * Current prices for each outcome (0-1 range)
   * @example [0.65, 0.35] for 65% YES probability
   */
  outcomePrices: number[];

  /**
   * Total trading volume (lifetime, in USDC)
   */
  volume: number;

  /**
   * 24-hour trading volume (in USDC)
   */
  volume24hr?: number;

  /**
   * 7-day trading volume (in USDC)
   */
  volume1wk?: number;

  /**
   * Current available liquidity (in USDC)
   */
  liquidity: number;

  /**
   * Bid-ask spread (as decimal, e.g., 0.02 = 2%)
   */
  spread?: number;

  /**
   * 24-hour price change (as decimal, e.g., 0.05 = +5%)
   */
  oneDayPriceChange?: number;

  /**
   * 7-day price change (as decimal)
   */
  oneWeekPriceChange?: number;

  /**
   * Last traded price for the YES outcome
   */
  lastTradePrice?: number;

  /**
   * Best bid price for YES outcome
   */
  bestBid?: number;

  /**
   * Best ask price for YES outcome
   */
  bestAsk?: number;

  /**
   * Market end/resolution date
   */
  endDate: Date;

  /**
   * When the market was created
   * @remarks For crypto 15m markets, this is ~24h before trading starts
   */
  createdAt?: Date;

  /**
   * When the market became ready (NOT trading start time!)
   * @remarks For crypto 15m markets, this is close to createdAt.
   * The actual trading start time should be parsed from the slug.
   */
  startDate?: Date;

  /**
   * When the market started accepting orders
   */
  acceptingOrdersTimestamp?: Date;

  /**
   * Whether the market is currently active
   */
  active: boolean;

  /**
   * Whether the market has been resolved
   */
  closed: boolean;

  /**
   * URL to market image
   */
  image?: string;

  /**
   * URL to market icon
   */
  icon?: string;

  /**
   * Category tags (e.g., ["crypto", "bitcoin", "finance"])
   */
  tags?: string[];
}

/**
 * Event grouping from the Gamma API
 *
 * @remarks
 * Events group related markets together. For example, a "2024 US Election"
 * event might contain markets for each candidate and related predictions.
 */
export interface GammaEvent {
  /**
   * Internal Gamma event ID
   */
  id: string;

  /**
   * URL-friendly event slug
   */
  slug: string;

  /**
   * Event title
   * @example "2024 US Presidential Election"
   */
  title: string;

  /**
   * Event description
   */
  description?: string;

  /**
   * Markets belonging to this event
   */
  markets: GammaMarket[];

  /**
   * Event start date
   */
  startDate?: Date;

  /**
   * Event end date
   */
  endDate?: Date;

  /**
   * URL to event image
   */
  image?: string;
}

/**
 * Parameters for searching/filtering markets
 */
export interface MarketSearchParams {
  /**
   * Filter by market slug
   */
  slug?: string;

  /**
   * Filter by condition ID
   */
  conditionId?: string;

  /**
   * Filter by active status
   */
  active?: boolean;

  /**
   * Filter by closed status
   */
  closed?: boolean;

  /**
   * Maximum number of results (default: 100)
   */
  limit?: number;

  /**
   * Offset for pagination
   */
  offset?: number;

  /**
   * Sort field (e.g., "volume24hr", "liquidity", "endDate")
   */
  order?: string;

  /**
   * Sort direction (true = ascending, false = descending)
   */
  ascending?: boolean;

  /**
   * Filter by tag (e.g., "15-min", "5-min", "hourly", "daily")
   * Used for recurring short-term markets
   */
  tag?: string;
}

// ===== Client =====

/**
 * Gamma API client for market discovery and metadata
 *
 * @remarks
 * Use this client for:
 * - Discovering trending markets
 * - Searching for specific topics
 * - Getting market metadata and statistics
 * - Browsing events and market groupings
 *
 * For orderbook data and trading, use {@link ClobApiClient} and {@link TradingClient}.
 *
 * @example
 * ```typescript
 * const client = new GammaApiClient(rateLimiter, cache);
 *
 * // Find top volume markets
 * const trending = await client.getTrendingMarkets(20);
 * for (const market of trending) {
 *   console.log(market.question, '$' + market.volume24hr.toLocaleString());
 * }
 * ```
 */
export class GammaApiClient {
  /**
   * Creates a new Gamma API client
   *
   * @param rateLimiter - Rate limiter instance for API throttling
   * @param cache - Cache instance for storing data (supports both legacy Cache and CacheAdapter)
   */
  constructor(
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache
  ) {}

  // ===== Market Queries =====

  /**
   * Get markets with optional filters and sorting
   *
   * @param params - Search and filter parameters
   * @returns Array of markets matching the criteria
   *
   * @remarks
   * Common sort fields:
   * - `volume24hr` - 24-hour trading volume
   * - `liquidity` - Available liquidity
   * - `endDate` - Market end date
   * - `volume` - Lifetime volume
   *
   * @example
   * ```typescript
   * // Get active markets sorted by 24h volume
   * const markets = await client.getMarkets({
   *   active: true,
   *   closed: false,
   *   order: 'volume24hr',
   *   ascending: false,
   *   limit: 50,
   * });
   *
   * // Search by slug
   * const market = await client.getMarkets({
   *   slug: 'will-btc-reach-100k',
   *   limit: 1,
   * });
   * ```
   */
  async getMarkets(params?: MarketSearchParams): Promise<GammaMarket[]> {
    const query = new URLSearchParams();
    if (params?.slug) query.set('slug', params.slug);
    if (params?.conditionId) query.set('condition_id', params.conditionId);
    if (params?.active !== undefined) query.set('active', String(params.active));
    if (params?.closed !== undefined) query.set('closed', String(params.closed));
    if (params?.limit) query.set('limit', String(params.limit));
    if (params?.offset) query.set('offset', String(params.offset));
    if (params?.order) query.set('order', params.order);
    if (params?.ascending !== undefined)
      query.set('ascending', String(params.ascending));
    if (params?.tag) query.set('tag', params.tag);

    return this.rateLimiter.execute(ApiType.GAMMA_API, async () => {
      const response = await fetch(`${GAMMA_API_BASE}/markets?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      if (!Array.isArray(data)) return [];
      return data.map((item) => this.normalizeMarket(item as Record<string, unknown>));
    });
  }

  /**
   * Get a single market by its URL slug
   *
   * @param slug - The URL-friendly market slug
   * @returns The market if found, null otherwise
   *
   * @example
   * ```typescript
   * const market = await client.getMarketBySlug('will-btc-reach-100k');
   * if (market) {
   *   console.log(market.question);
   * }
   * ```
   */
  async getMarketBySlug(slug: string): Promise<GammaMarket | null> {
    const markets = await this.getMarkets({ slug, limit: 1 });
    return markets[0] || null;
  }

  /**
   * Get a single market by condition ID
   *
   * @param conditionId - The unique condition identifier
   * @returns The market if found, null otherwise
   *
   * @remarks
   * For more reliable market data by condition ID, prefer {@link ClobApiClient.getMarket}.
   *
   * @example
   * ```typescript
   * const market = await client.getMarketByConditionId('0x82ace55...');
   * ```
   */
  async getMarketByConditionId(conditionId: string): Promise<GammaMarket | null> {
    const markets = await this.getMarkets({ conditionId, limit: 1 });
    return markets[0] || null;
  }

  // ===== Event Queries =====

  /**
   * Get events with optional filters
   *
   * @param params - Filter parameters
   * @param params.slug - Filter by event slug
   * @param params.active - Filter by active status
   * @param params.limit - Maximum results to return
   * @returns Array of events matching the criteria
   *
   * @example
   * ```typescript
   * // Get all active events
   * const events = await client.getEvents({ active: true, limit: 20 });
   *
   * // Get a specific event by slug
   * const election = await client.getEvents({ slug: '2024-us-election' });
   * ```
   */
  async getEvents(params?: {
    slug?: string;
    active?: boolean;
    limit?: number;
  }): Promise<GammaEvent[]> {
    const query = new URLSearchParams();
    if (params?.slug) query.set('slug', params.slug);
    if (params?.active !== undefined) query.set('active', String(params.active));
    if (params?.limit) query.set('limit', String(params.limit));

    return this.rateLimiter.execute(ApiType.GAMMA_API, async () => {
      const response = await fetch(`${GAMMA_API_BASE}/events?${query}`);
      if (!response.ok)
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      const data = (await response.json()) as unknown[];
      if (!Array.isArray(data)) return [];
      return data.map((item) => this.normalizeEvent(item as Record<string, unknown>));
    });
  }

  /**
   * Get a single event by its URL slug
   *
   * @param slug - The URL-friendly event slug
   * @returns The event if found, null otherwise
   *
   * @example
   * ```typescript
   * const event = await client.getEventBySlug('2024-us-election');
   * if (event) {
   *   console.log(`${event.title} has ${event.markets.length} markets`);
   * }
   * ```
   */
  async getEventBySlug(slug: string): Promise<GammaEvent | null> {
    const events = await this.getEvents({ slug, limit: 1 });
    return events[0] || null;
  }

  /**
   * Get a single event by its ID
   *
   * @param id - The internal event ID
   * @returns The event if found, null otherwise
   *
   * @example
   * ```typescript
   * const event = await client.getEventById('12345');
   * ```
   */
  async getEventById(id: string): Promise<GammaEvent | null> {
    return this.rateLimiter.execute(ApiType.GAMMA_API, async () => {
      const response = await fetch(`${GAMMA_API_BASE}/events/${id}`);
      if (!response.ok) {
        if (response.status === 404) return null;
        throw PolymarketError.fromHttpError(
          response.status,
          await response.json().catch(() => null)
        );
      }
      const data = (await response.json()) as Record<string, unknown>;
      return this.normalizeEvent(data);
    });
  }

  // ===== Trending =====

  /**
   * Get trending markets sorted by 24-hour volume
   *
   * @param limit - Maximum number of markets to return (default: 20)
   * @returns Array of active markets sorted by volume
   *
   * @remarks
   * This is a convenience method equivalent to:
   * ```typescript
   * getMarkets({
   *   active: true,
   *   closed: false,
   *   order: 'volume24hr',
   *   ascending: false,
   *   limit,
   * })
   * ```
   *
   * @example
   * ```typescript
   * // Get top 10 trending markets
   * const trending = await client.getTrendingMarkets(10);
   *
   * for (const market of trending) {
   *   console.log(`${market.question}`);
   *   console.log(`  24h Volume: $${market.volume24hr?.toLocaleString()}`);
   *   console.log(`  YES Price: ${(market.outcomePrices[0] * 100).toFixed(1)}%`);
   * }
   * ```
   */
  async getTrendingMarkets(limit = 20): Promise<GammaMarket[]> {
    return this.getMarkets({
      active: true,
      closed: false,
      order: 'volume24hr',
      ascending: false,
      limit,
    });
  }

  // ===== Data Normalization =====

  private normalizeMarket(m: Record<string, unknown>): GammaMarket {
    return {
      id: String(m.id || ''),
      conditionId: String(m.conditionId || ''),
      slug: String(m.slug || ''),
      question: String(m.question || ''),
      description: m.description ? String(m.description) : undefined,
      outcomes: this.parseJsonArray(m.outcomes, ['Yes', 'No']),
      outcomePrices: this.parseJsonArray(m.outcomePrices, [0.5, 0.5]).map(
        Number
      ),
      volume: Number(m.volume || 0),
      volume24hr: m.volume24hr !== undefined ? Number(m.volume24hr) : undefined,
      volume1wk: m.volume1wk !== undefined ? Number(m.volume1wk) : undefined,
      liquidity: Number(m.liquidity || 0),
      spread: m.spread !== undefined ? Number(m.spread) : undefined,
      oneDayPriceChange:
        m.oneDayPriceChange !== undefined
          ? Number(m.oneDayPriceChange)
          : undefined,
      oneWeekPriceChange:
        m.oneWeekPriceChange !== undefined
          ? Number(m.oneWeekPriceChange)
          : undefined,
      lastTradePrice:
        m.lastTradePrice !== undefined ? Number(m.lastTradePrice) : undefined,
      bestBid: m.bestBid !== undefined ? Number(m.bestBid) : undefined,
      bestAsk: m.bestAsk !== undefined ? Number(m.bestAsk) : undefined,
      endDate: new Date(String(m.endDate || Date.now())),
      createdAt: m.createdAt ? new Date(String(m.createdAt)) : undefined,
      startDate: m.startDate ? new Date(String(m.startDate)) : undefined,
      acceptingOrdersTimestamp: m.acceptingOrdersTimestamp
        ? new Date(String(m.acceptingOrdersTimestamp))
        : undefined,
      active: Boolean(m.active),
      closed: Boolean(m.closed),
      image: m.image ? String(m.image) : undefined,
      icon: m.icon ? String(m.icon) : undefined,
      tags: m.tags ? this.parseJsonArray(m.tags, []) : undefined,
    };
  }

  private normalizeEvent(e: Record<string, unknown>): GammaEvent {
    const markets = e.markets;
    return {
      id: String(e.id || ''),
      slug: String(e.slug || ''),
      title: String(e.title || ''),
      description: e.description ? String(e.description) : undefined,
      markets: Array.isArray(markets)
        ? markets.map((m: Record<string, unknown>) => this.normalizeMarket(m))
        : [],
      startDate: e.startDate ? new Date(String(e.startDate)) : undefined,
      endDate: e.endDate ? new Date(String(e.endDate)) : undefined,
      image: e.image ? String(e.image) : undefined,
    };
  }

  private parseJsonArray<T>(value: unknown, fallback: T[]): T[] {
    if (Array.isArray(value)) return value as T[];
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch {
        return fallback;
      }
    }
    return fallback;
  }
}

================================================================================
// File: src/clients/subgraph.ts
================================================================================
/**
 * Polymarket Subgraph Client
 *
 * 官方文档: https://docs.polymarket.com/developers/subgraph/overview
 * Schema 仓库: https://github.com/Polymarket/polymarket-subgraph
 *
 * 5 个 Subgraph:
 * - Positions (0.0.7): 用户余额、Net 余额
 * - PnL (0.0.14): 用户持仓、PnL、Condition 结算状态
 * - Activity (0.0.4): Split/Merge/Redemption 事件
 * - OI (0.0.6): 市场/全局 Open Interest
 * - Orderbook (0.0.1): 订单成交事件
 */

import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import type { UnifiedCache } from '../core/unified-cache.js';

// ==================== 端点配置 ====================

export const SUBGRAPH_ENDPOINTS = {
  positions: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/positions-subgraph/0.0.7/gn',
  pnl: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn',
  activity: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/0.0.4/gn',
  oi: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/oi-subgraph/0.0.6/gn',
  orderbook: 'https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/orderbook-subgraph/0.0.1/gn',
} as const;

export type SubgraphName = keyof typeof SUBGRAPH_ENDPOINTS;

// ==================== 类型定义 ====================

// Positions Subgraph
export interface UserBalance {
  id: string;
  user: string;
  asset: string;
  balance: string; // BigInt as string
}

export interface NetUserBalance {
  id: string;
  user: string;
  asset: string;
  balance: string;
}

// PnL Subgraph
export interface UserPosition {
  id: string;
  user: string;
  tokenId: string; // BigInt as string
  amount: string;
  avgPrice: string;
  realizedPnl: string;
  totalBought: string;
}

export interface Condition {
  id: string;
  positionIds: string[];
  payoutNumerators: string[];
  payoutDenominator: string;
}

// Activity Subgraph
export interface Split {
  id: string;
  timestamp: string;
  stakeholder: string;
  condition: string;
  amount: string;
}

export interface Merge {
  id: string;
  timestamp: string;
  stakeholder: string;
  condition: string;
  amount: string;
}

export interface Redemption {
  id: string;
  timestamp: string;
  redeemer: string;
  condition: string;
  payout: string;
}

// OI Subgraph
export interface MarketOpenInterest {
  id: string; // condition id
  amount: string;
}

export interface GlobalOpenInterest {
  id: string;
  amount: string;
}

// Orderbook Subgraph
export interface OrderFilledEvent {
  id: string;
  transactionHash: string;
  timestamp: string;
  orderHash: string;
  maker: string;
  taker: string;
  makerAssetId: string;
  takerAssetId: string;
  makerAmountFilled: string;
  takerAmountFilled: string;
  fee: string;
}

export interface MarketData {
  id: string;
  volume: string;
}

// ==================== 查询参数 ====================

export interface SubgraphQueryParams {
  first?: number;
  skip?: number;
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
  where?: Record<string, unknown>;
}

// ==================== 响应类型 ====================

interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{ message: string; locations?: unknown[] }>;
}

// ==================== 客户端实现 ====================

export class SubgraphClient {
  constructor(
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache
  ) {}

  /**
   * 执行 GraphQL 查询
   */
  private async query<T>(subgraph: SubgraphName, queryStr: string): Promise<T> {
    const endpoint = SUBGRAPH_ENDPOINTS[subgraph];
    const cacheKey = `subgraph:${subgraph}:${queryStr}`;

    // 检查缓存
    const cached = await this.cache.get<T>(cacheKey);
    if (cached !== undefined) {
      return cached;
    }

    // 限流并执行请求
    const data = await this.rateLimiter.execute(ApiType.SUBGRAPH, async () => {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: queryStr }),
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(`Subgraph request failed: HTTP ${response.status} - ${text.slice(0, 200)}`);
      }

      const result = (await response.json()) as GraphQLResponse<T>;

      if (result.errors && result.errors.length > 0) {
        throw new Error(`GraphQL error: ${result.errors.map((e) => e.message).join(', ')}`);
      }

      if (!result.data) {
        throw new Error(`No data returned from subgraph. Response: ${JSON.stringify(result).slice(0, 200)}`);
      }

      return result.data;
    });

    // 缓存结果 (短 TTL，subgraph 数据更新较快)
    await this.cache.set(cacheKey, data, 30_000);

    return data;
  }

  /**
   * 构建查询字符串
   */
  private buildQuery(
    entityName: string,
    fields: string[],
    params: SubgraphQueryParams = {}
  ): string {
    const args: string[] = [];

    if (params.first !== undefined) {
      args.push(`first: ${params.first}`);
    }
    if (params.skip !== undefined) {
      args.push(`skip: ${params.skip}`);
    }
    if (params.orderBy) {
      args.push(`orderBy: ${params.orderBy}`);
    }
    if (params.orderDirection) {
      args.push(`orderDirection: ${params.orderDirection}`);
    }
    if (params.where && Object.keys(params.where).length > 0) {
      // Build where clause manually to avoid JSON quote issues
      const whereParts = Object.entries(params.where).map(([key, value]) => {
        if (typeof value === 'string') {
          return `${key}: "${value}"`;
        }
        return `${key}: ${JSON.stringify(value)}`;
      });
      args.push(`where: { ${whereParts.join(', ')} }`);
    }

    const argsStr = args.length > 0 ? `(${args.join(', ')})` : '';
    const fieldsStr = fields.join('\n      ');

    return `{
      ${entityName}${argsStr} {
        ${fieldsStr}
      }
    }`;
  }

  // ==================== Positions Subgraph ====================

  /**
   * 获取用户余额
   */
  async getUserBalances(user: string, params: SubgraphQueryParams = {}): Promise<UserBalance[]> {
    const query = this.buildQuery(
      'userBalances',
      ['id', 'user', 'asset', 'balance'],
      {
        ...params,
        where: { ...params.where, user: user.toLowerCase() },
      }
    );
    const result = await this.query<{ userBalances: UserBalance[] }>('positions', query);
    return result.userBalances;
  }

  /**
   * 获取 Net 用户余额
   */
  async getNetUserBalances(user: string, params: SubgraphQueryParams = {}): Promise<NetUserBalance[]> {
    const query = this.buildQuery(
      'netUserBalances',
      ['id', 'user', 'asset', 'balance'],
      {
        ...params,
        where: { ...params.where, user: user.toLowerCase() },
      }
    );
    const result = await this.query<{ netUserBalances: NetUserBalance[] }>('positions', query);
    return result.netUserBalances;
  }

  // ==================== PnL Subgraph ====================

  /**
   * 获取用户持仓 (含 PnL)
   */
  async getUserPositions(user: string, params: SubgraphQueryParams = {}): Promise<UserPosition[]> {
    const query = this.buildQuery(
      'userPositions',
      ['id', 'user', 'tokenId', 'amount', 'avgPrice', 'realizedPnl', 'totalBought'],
      {
        orderBy: 'realizedPnl',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, user: user.toLowerCase() },
      }
    );
    const result = await this.query<{ userPositions: UserPosition[] }>('pnl', query);
    return result.userPositions;
  }

  /**
   * 获取 Condition 结算状态
   */
  async getConditions(params: SubgraphQueryParams = {}): Promise<Condition[]> {
    const query = this.buildQuery(
      'conditions',
      ['id', 'positionIds', 'payoutNumerators', 'payoutDenominator'],
      params
    );
    const result = await this.query<{ conditions: Condition[] }>('pnl', query);
    return result.conditions;
  }

  /**
   * 获取单个 Condition
   */
  async getCondition(conditionId: string): Promise<Condition | null> {
    const query = `{
      condition(id: "${conditionId.toLowerCase()}") {
        id
        positionIds
        payoutNumerators
        payoutDenominator
      }
    }`;
    const result = await this.query<{ condition: Condition | null }>('pnl', query);
    return result.condition;
  }

  /**
   * 检查 Condition 是否已结算
   */
  async isConditionResolved(conditionId: string): Promise<boolean> {
    const condition = await this.getCondition(conditionId);
    if (!condition) return false;
    return condition.payoutNumerators.length > 0 && condition.payoutDenominator !== '0';
  }

  // ==================== Activity Subgraph ====================

  /**
   * 获取用户的 Split 事件
   */
  async getSplits(user: string, params: SubgraphQueryParams = {}): Promise<Split[]> {
    const query = this.buildQuery(
      'splits',
      ['id', 'timestamp', 'stakeholder', 'condition', 'amount'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, stakeholder: user.toLowerCase() },
      }
    );
    const result = await this.query<{ splits: Split[] }>('activity', query);
    return result.splits;
  }

  /**
   * 获取用户的 Merge 事件
   */
  async getMerges(user: string, params: SubgraphQueryParams = {}): Promise<Merge[]> {
    const query = this.buildQuery(
      'merges',
      ['id', 'timestamp', 'stakeholder', 'condition', 'amount'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, stakeholder: user.toLowerCase() },
      }
    );
    const result = await this.query<{ merges: Merge[] }>('activity', query);
    return result.merges;
  }

  /**
   * 获取用户的 Redemption 事件
   */
  async getRedemptions(user: string, params: SubgraphQueryParams = {}): Promise<Redemption[]> {
    const query = this.buildQuery(
      'redemptions',
      ['id', 'timestamp', 'redeemer', 'condition', 'payout'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, redeemer: user.toLowerCase() },
      }
    );
    const result = await this.query<{ redemptions: Redemption[] }>('activity', query);
    return result.redemptions;
  }

  /**
   * 获取最近的 Redemption 事件 (不限用户)
   */
  async getRecentRedemptions(params: SubgraphQueryParams = {}): Promise<Redemption[]> {
    const query = this.buildQuery(
      'redemptions',
      ['id', 'timestamp', 'redeemer', 'condition', 'payout'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        first: 100,
        ...params,
      }
    );
    const result = await this.query<{ redemptions: Redemption[] }>('activity', query);
    return result.redemptions;
  }

  // ==================== OI Subgraph ====================

  /**
   * 获取市场 Open Interest
   */
  async getMarketOpenInterest(conditionId: string): Promise<MarketOpenInterest | null> {
    const query = `{
      marketOpenInterest(id: "${conditionId.toLowerCase()}") {
        id
        amount
      }
    }`;
    const result = await this.query<{ marketOpenInterest: MarketOpenInterest | null }>('oi', query);
    return result.marketOpenInterest;
  }

  /**
   * 获取 Top 市场按 OI 排序
   */
  async getTopMarketsByOI(params: SubgraphQueryParams = {}): Promise<MarketOpenInterest[]> {
    const query = this.buildQuery(
      'marketOpenInterests',
      ['id', 'amount'],
      {
        orderBy: 'amount',
        orderDirection: 'desc',
        first: 50,
        ...params,
      }
    );
    const result = await this.query<{ marketOpenInterests: MarketOpenInterest[] }>('oi', query);
    return result.marketOpenInterests;
  }

  /**
   * 获取全局 Open Interest
   */
  async getGlobalOpenInterest(): Promise<string> {
    const query = `{
      globalOpenInterests(first: 1) {
        id
        amount
      }
    }`;
    const result = await this.query<{ globalOpenInterests: GlobalOpenInterest[] }>('oi', query);
    return result.globalOpenInterests[0]?.amount || '0';
  }

  // ==================== Orderbook Subgraph ====================

  /**
   * 获取订单成交事件
   */
  async getOrderFilledEvents(params: SubgraphQueryParams = {}): Promise<OrderFilledEvent[]> {
    const query = this.buildQuery(
      'orderFilledEvents',
      ['id', 'transactionHash', 'timestamp', 'orderHash', 'maker', 'taker', 'makerAssetId', 'takerAssetId', 'makerAmountFilled', 'takerAmountFilled', 'fee'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        first: 100,
        ...params,
      }
    );
    const result = await this.query<{ orderFilledEvents: OrderFilledEvent[] }>('orderbook', query);
    return result.orderFilledEvents;
  }

  /**
   * 获取用户作为 maker 的成交事件
   */
  async getMakerFills(maker: string, params: SubgraphQueryParams = {}): Promise<OrderFilledEvent[]> {
    const query = this.buildQuery(
      'orderFilledEvents',
      ['id', 'transactionHash', 'timestamp', 'orderHash', 'maker', 'taker', 'makerAssetId', 'takerAssetId', 'makerAmountFilled', 'takerAmountFilled', 'fee'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, maker: maker.toLowerCase() },
      }
    );
    const result = await this.query<{ orderFilledEvents: OrderFilledEvent[] }>('orderbook', query);
    return result.orderFilledEvents;
  }

  /**
   * 获取用户作为 taker 的成交事件
   */
  async getTakerFills(taker: string, params: SubgraphQueryParams = {}): Promise<OrderFilledEvent[]> {
    const query = this.buildQuery(
      'orderFilledEvents',
      ['id', 'transactionHash', 'timestamp', 'orderHash', 'maker', 'taker', 'makerAssetId', 'takerAssetId', 'makerAmountFilled', 'takerAmountFilled', 'fee'],
      {
        orderBy: 'timestamp',
        orderDirection: 'desc',
        ...params,
        where: { ...params.where, taker: taker.toLowerCase() },
      }
    );
    const result = await this.query<{ orderFilledEvents: OrderFilledEvent[] }>('orderbook', query);
    return result.orderFilledEvents;
  }

  /**
   * 获取市场数据
   */
  async getMarketData(assetId: string): Promise<MarketData | null> {
    const query = `{
      marketData(id: "${assetId}") {
        id
        volume
      }
    }`;
    const result = await this.query<{ marketData: MarketData | null }>('orderbook', query);
    return result.marketData;
  }

  // ==================== 便捷方法 ====================

  /**
   * 获取用户完整的链上活动摘要
   */
  async getUserActivitySummary(user: string): Promise<{
    positions: UserPosition[];
    splits: Split[];
    merges: Merge[];
    redemptions: Redemption[];
    makerFills: OrderFilledEvent[];
    takerFills: OrderFilledEvent[];
  }> {
    const [positions, splits, merges, redemptions, makerFills, takerFills] = await Promise.all([
      this.getUserPositions(user, { first: 100 }),
      this.getSplits(user, { first: 50 }),
      this.getMerges(user, { first: 50 }),
      this.getRedemptions(user, { first: 50 }),
      this.getMakerFills(user, { first: 50 }),
      this.getTakerFills(user, { first: 50 }),
    ]);

    return { positions, splits, merges, redemptions, makerFills, takerFills };
  }
}

================================================================================
// File: src/index.ts
================================================================================
/**
 * @catalyst-team/poly-sdk
 *
 * Unified SDK for Polymarket APIs
 * - Data API (positions, activity, trades, leaderboard)
 * - Gamma API (markets, events, trending)
 * - CLOB API (orderbook, market info, trading)
 * - Services (WalletService, MarketService)
 */

// Core infrastructure
export { RateLimiter, ApiType } from './core/rate-limiter.js';
export { Cache, CACHE_TTL } from './core/cache.js';
export { PolymarketError, ErrorCode, withRetry } from './core/errors.js';
export * from './core/types.js';

// Cache integration (new)
export type { UnifiedCache } from './core/unified-cache.js';
export { createUnifiedCache } from './core/unified-cache.js';

// API Clients
export { DataApiClient } from './clients/data-api.js';
export type {
  Position,
  Activity,
  Trade,
  LeaderboardEntry,
  LeaderboardResult,
  // Leaderboard parameters (supports time period filtering)
  LeaderboardParams,
  LeaderboardTimePeriod,
  LeaderboardOrderBy,
  LeaderboardCategory,
  // P0/P1/P2 Gap Analysis types
  ActivityParams,
  PositionsParams,
  TradesParams,
  HoldersParams,
  AccountValue,
  MarketHolder,
  // Closed positions
  ClosedPosition,
  ClosedPositionsParams,
} from './clients/data-api.js';

export { GammaApiClient } from './clients/gamma-api.js';
export type {
  GammaMarket,
  GammaEvent,
  MarketSearchParams,
} from './clients/gamma-api.js';

// ClobApiClient has been removed - use TradingService instead
// TradingService provides getMarket(), getProcessedOrderbook(), etc.

// Subgraph Client (on-chain data via Goldsky)
export { SubgraphClient, SUBGRAPH_ENDPOINTS } from './clients/subgraph.js';
export type {
  SubgraphName,
  SubgraphQueryParams,
  // Positions Subgraph
  UserBalance,
  NetUserBalance,
  // PnL Subgraph
  UserPosition,
  Condition,
  // Activity Subgraph
  Split,
  Merge,
  Redemption,
  // OI Subgraph
  MarketOpenInterest,
  GlobalOpenInterest,
  // Orderbook Subgraph
  OrderFilledEvent,
  MarketData,
} from './clients/subgraph.js';

// Services
export { WalletService } from './services/wallet-service.js';
export type {
  WalletProfile,
  WalletActivityOptions,
  WalletActivitySummary,
  SellActivityResult,
  // Time-based leaderboard types
  TimePeriod,
  LeaderboardSortBy,
  PeriodLeaderboardEntry,
  PeriodLeaderboardResult,
  WalletPeriodStats,
  // PnL calculation types
  ParsedTrade,
  TokenPosition,
  UserPeriodStats,
} from './services/wallet-service.js';

export { MarketService, getIntervalMs as getIntervalMsService } from './services/market-service.js';
export type { ResolvedMarketTokens } from './services/market-service.js';

// Real-time (V2 - using official @polymarket/real-time-data-client)
export { RealtimeServiceV2 } from './services/realtime-service-v2.js';
export type {
  RealtimeServiceConfig,
  OrderbookSnapshot,
  LastTradeInfo,
  PriceChange,
  TickSizeChange,
  MarketEvent,
  UserOrder,
  UserTrade,
  ActivityTrade,
  CryptoPrice,
  EquityPrice,
  Comment,
  Reaction,
  RFQRequest,
  RFQQuote,
  Subscription,
  MarketSubscription,
  MarketDataHandlers,
  UserDataHandlers,
  ActivityHandlers,
  CryptoPriceHandlers,
  EquityPriceHandlers,
} from './services/realtime-service-v2.js';

// RealtimeService (legacy) has been removed - use RealtimeServiceV2 instead

// ArbitrageService (Real-time arbitrage detection, execution, rebalancing, and settlement)
export { ArbitrageService } from './services/arbitrage-service.js';
export type {
  ArbitrageMarketConfig,
  ArbitrageServiceConfig,
  ArbitrageOpportunity as ArbitrageServiceOpportunity,
  ArbitrageExecutionResult,
  ArbitrageServiceEvents,
  OrderbookState,
  BalanceState,
  // Rebalancer types
  RebalanceAction,
  RebalanceResult,
  // Settle types
  SettleResult,
  // Clear position types (smart settle)
  ClearPositionResult,
  ClearAction,
  // Scanning types
  ScanCriteria,
  ScanResult,
} from './services/arbitrage-service.js';

// SmartMoneyService - Smart Money detection and Copy Trading
export {
  SmartMoneyService,
  categorizeMarket,
  CATEGORY_KEYWORDS,
} from './services/smart-money-service.js';
export type {
  SmartMoneyWallet,
  SmartMoneyTrade,
  AutoCopyTradingOptions,
  AutoCopyTradingStats,
  AutoCopyTradingSubscription,
  SmartMoneyServiceConfig,
  // Leaderboard & Report types
  LeaderboardOptions,
  SmartMoneyLeaderboardEntry,
  SmartMoneyLeaderboardResult,
  PeriodRanking,
  WalletReport,
  WalletComparison,
  // Report types (02-smart-money)
  MarketCategory,
  DailySummary,
  CategoryStats,
  TradeRecord,
  PositionSummary,
  ClosedMarketSummary,
  DailyWalletReport,
  DataRange,
  PerformanceMetrics,
  MarketStats,
  TradingPatterns,
  CurrentPositionsSummary,
  WalletLifecycleReport,
  PieSlice,
  PieChartData,
  BarItem,
  BarChartData,
  MonthlyPnLItem,
  MonthlyPnLData,
  ChartMetadata,
  WalletChartData,
  ReportProgressCallback,
  LifecycleReportOptions,
  TextReport,
} from './services/smart-money-service.js';

// DipArbService - Dip Arbitrage for 15m/5m UP/DOWN markets
export { DipArbService } from './services/dip-arb-service.js';
export type {
  DipArbServiceConfig,
  DipArbMarketConfig,
  DipArbRoundState,
  DipArbStats,
  DipArbSignal,
  DipArbLeg1Signal,
  DipArbLeg2Signal,
  DipArbExecutionResult,
  DipArbRoundResult,
  DipArbNewRoundEvent,
  DipArbPriceUpdateEvent,
  DipArbScanOptions,
  DipArbFindAndStartOptions,
  DipArbAutoRotateConfig,
  DipArbSettleResult,
  DipArbRotateEvent,
  DipArbSide,
  DipArbUnderlying,
  DipArbPhase,
  DipArbLegInfo,
} from './services/dip-arb-types.js';

// BinanceService - BTC/ETH/SOL K-line data from Binance
export { BinanceService } from './services/binance-service.js';
export type {
  BinanceKLine,
  BinanceSymbol,
  BinanceInterval,
  BinanceKLineOptions,
} from './services/binance-service.js';

// TradingService - Unified trading and market data
export {
  TradingService,
  POLYGON_MAINNET,
  POLYGON_AMOY,
  // Polymarket order minimum requirements
  MIN_ORDER_VALUE_USDC,
  MIN_ORDER_SIZE_SHARES,
} from './services/trading-service.js';
export type {
  TradingServiceConfig,
  // Order types - Side and OrderType are re-exported from core/types.ts via trading-service.ts
  // They are also exported via `export * from './core/types.js'` above
  ApiCredentials,
  LimitOrderParams,
  MarketOrderParams,
  // Results
  Order,
  OrderResult,
  TradeInfo,
  // Rewards
  UserEarning,
  MarketReward,
} from './services/trading-service.js';

// Market types from MarketService
// Note: Side and Orderbook are now in core/types.ts (exported via `export * from './core/types.js'` above)
export type {
  Market,
  MarketToken,
  PricePoint,
  PriceHistoryParams,
  PriceHistoryIntervalString,
} from './services/market-service.js';

// TradingClient (legacy) has been removed - use TradingService instead
// TradingService provides all trading functionality with proper type exports

// CTF (Conditional Token Framework)
// NOTE: USDC_CONTRACT is USDC.e (bridged), required for Polymarket CTF
// NATIVE_USDC_CONTRACT is native USDC, NOT compatible with CTF
export {
  CTFClient,
  CTF_CONTRACT,
  USDC_CONTRACT,           // USDC.e (0x2791...) - Required for CTF
  NATIVE_USDC_CONTRACT,    // Native USDC (0x3c49...) - NOT for CTF
  NEG_RISK_CTF_EXCHANGE,
  NEG_RISK_ADAPTER,
  USDC_DECIMALS,
  calculateConditionId,
  parseUsdc,
  formatUsdc,
} from './clients/ctf-client.js';
export type {
  CTFConfig,
  SplitResult,
  MergeResult,
  RedeemResult,
  PositionBalance,
  MarketResolution,
  GasEstimate,
  TransactionStatus,
  TokenIds,
} from './clients/ctf-client.js';
export { RevertReason } from './clients/ctf-client.js';

// Bridge (Cross-chain Deposits)
export {
  BridgeClient,
  SUPPORTED_CHAINS,
  BRIDGE_TOKENS,
  estimateBridgeOutput,
  getExplorerUrl,
  depositUsdc,
  swapAndDeposit,
  getSupportedDepositTokens,
} from './clients/bridge-client.js';
export type {
  BridgeSupportedAsset,
  DepositAddress,
  CreateDepositResponse,
  DepositStatus,
  BridgeConfig,
  DepositResult,
  DepositOptions,
  SwapAndDepositOptions,
  SwapAndDepositResult,
} from './clients/bridge-client.js';

// Swap Service (DEX swaps on Polygon)
export {
  SwapService,
  QUICKSWAP_ROUTER,
  POLYGON_TOKENS,
  TOKEN_DECIMALS,
} from './services/swap-service.js';
export type {
  SupportedToken,
  SwapQuote,
  SwapResult,
  TokenBalance,
  TransferResult,
} from './services/swap-service.js';

// Authorization (ERC20/ERC1155 Approvals)
export { AuthorizationService } from './services/authorization-service.js';
export type {
  AllowanceInfo,
  AllowancesResult,
  ApprovalTxResult,
  ApprovalsResult,
  AuthorizationServiceConfig,
} from './services/authorization-service.js';

// OnchainService (Unified on-chain operations: CTF + Authorization + Swaps)
export { OnchainService } from './services/onchain-service.js';
export type {
  OnchainServiceConfig,
  ReadyStatus,
  TokenBalances,
} from './services/onchain-service.js';

// Price Utilities
export {
  roundPrice,
  roundSize,
  validatePrice,
  validateSize,
  calculateBuyAmount,
  calculateSellPayout,
  calculateSharesForAmount,
  calculateSpread,
  calculateMidpoint,
  formatPrice,
  formatUSDC,
  calculatePnL,
  checkArbitrage,
  getEffectivePrices,
  ROUNDING_CONFIG,
} from './utils/price-utils.js';
export type { TickSize } from './utils/price-utils.js';

// NOTE: MCP tools have been moved to @catalyst-team/poly-mcp package
// See packages/poly-mcp/

// ===== Main SDK Class =====

import { RateLimiter } from './core/rate-limiter.js';
import { DataApiClient } from './clients/data-api.js';
import { GammaApiClient } from './clients/gamma-api.js';
import { SubgraphClient } from './clients/subgraph.js';
import { WalletService } from './services/wallet-service.js';
import { MarketService } from './services/market-service.js';
import { TradingService } from './services/trading-service.js';
import { RealtimeServiceV2 } from './services/realtime-service-v2.js';
import { SmartMoneyService } from './services/smart-money-service.js';
import { BinanceService } from './services/binance-service.js';
import { DipArbService } from './services/dip-arb-service.js';
import type { UnifiedMarket, ProcessedOrderbook, ArbitrageOpportunity, KLineInterval, KLineCandle, DualKLineData, PolySDKOptions } from './core/types.js';
import { createUnifiedCache, type UnifiedCache } from './core/unified-cache.js';

// Re-export for backward compatibility
export interface PolymarketSDKConfig extends PolySDKOptions {}

export class PolymarketSDK {
  // Infrastructure
  private rateLimiter: RateLimiter;
  private cache: UnifiedCache;

  // API Clients
  public readonly dataApi: DataApiClient;
  public readonly gammaApi: GammaApiClient;
  public readonly tradingService: TradingService;
  public readonly subgraph: SubgraphClient;

  // Services
  public readonly wallets: WalletService;
  public readonly markets: MarketService;
  public readonly realtime: RealtimeServiceV2;
  public readonly smartMoney: SmartMoneyService;
  public readonly binance: BinanceService;
  public readonly dipArb: DipArbService;

  // Initialization state
  private _initialized = false;

  constructor(config: PolymarketSDKConfig = {}) {
    // Initialize infrastructure
    this.rateLimiter = new RateLimiter();

    // Create unified cache (supports both legacy Cache and CacheAdapter)
    this.cache = createUnifiedCache(config.cache);

    // Initialize API clients
    this.dataApi = new DataApiClient(this.rateLimiter, this.cache);
    this.gammaApi = new GammaApiClient(this.rateLimiter, this.cache);

    // TradingService requires a private key - use provided key or dummy key for read-only
    const privateKey = config.privateKey || '0x' + '1'.repeat(64);
    this.tradingService = new TradingService(this.rateLimiter, this.cache, {
      privateKey,
      chainId: config.chainId,
      credentials: config.creds,
    });

    this.subgraph = new SubgraphClient(this.rateLimiter, this.cache);

    // Initialize services
    this.wallets = new WalletService(this.dataApi, this.subgraph, this.cache);
    this.binance = new BinanceService(this.rateLimiter, this.cache);
    this.markets = new MarketService(this.gammaApi, this.dataApi, this.rateLimiter, this.cache, undefined, this.binance);
    this.realtime = new RealtimeServiceV2();
    this.smartMoney = new SmartMoneyService(
      this.wallets,
      this.realtime,
      this.tradingService,
      {},  // default config
      this.dataApi  // pass dataApi for report generation
    );

    // Initialize DipArbService
    this.dipArb = new DipArbService(
      this.realtime,
      this.tradingService,
      this.markets,
      config.privateKey,
      config.chainId
    );
  }

  // ===== Static Factory Methods =====

  /**
   * Create and initialize SDK in one call
   *
   * @example
   * ```typescript
   * const sdk = await PolymarketSDK.create({ privateKey: '...' });
   * // Ready to trade and track smart money
   * ```
   */
  static async create(config: PolymarketSDKConfig = {}): Promise<PolymarketSDK> {
    const sdk = new PolymarketSDK(config);
    await sdk.start();
    return sdk;
  }

  // ===== Lifecycle Methods =====

  /**
   * Initialize the SDK (required for trading operations)
   */
  async initialize(): Promise<void> {
    if (this._initialized) return;
    await this.tradingService.initialize();
    this._initialized = true;
  }

  /**
   * Check if SDK is initialized
   */
  isInitialized(): boolean {
    return this._initialized;
  }

  /**
   * Start SDK - initialize trading + connect WebSocket
   *
   * One method to do everything:
   * - Initialize trading service (derive API credentials)
   * - Connect WebSocket
   * - Wait for connection
   *
   * @example
   * ```typescript
   * const sdk = new PolymarketSDK({ privateKey: '...' });
   * await sdk.start();
   * // Ready to use
   * ```
   */
  async start(options: { timeout?: number } = {}): Promise<void> {
    await this.initialize();
    this.connect();
    await this.waitForConnection(options.timeout ?? 10000);
  }

  /**
   * Connect to realtime WebSocket (required for smart money tracking)
   */
  connect(): void {
    this.realtime.connect();
  }

  /**
   * Wait for WebSocket connection
   */
  async waitForConnection(timeoutMs: number = 10000): Promise<void> {
    // Already connected
    if (this.realtime.isConnected?.()) {
      return;
    }

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Connection timeout')), timeoutMs);
      this.realtime.once('connected', () => {
        clearTimeout(timeout);
        resolve();
      });
    });
  }

  /**
   * Stop SDK - disconnect all services and clean up
   */
  stop(): void {
    this.dipArb.stop();
    this.smartMoney.disconnect();
    this.realtime.disconnect();
  }

  /**
   * Disconnect all services and clean up
   * @deprecated Use stop() instead
   */
  disconnect(): void {
    this.stop();
  }

  // ===== Unified Market Access =====

  /**
   * Get market by slug or condition ID
   * Delegates to MarketService which handles merging Gamma and CLOB data
   */
  async getMarket(identifier: string): Promise<UnifiedMarket> {
    return this.markets.getMarket(identifier);
  }

  // ===== Orderbook Analysis =====

  /**
   * Get processed orderbook with analytics
   */
  async getOrderbook(conditionId: string): Promise<ProcessedOrderbook> {
    return this.markets.getProcessedOrderbook(conditionId);
  }

  /**
   * Detect arbitrage opportunity
   *
   * 使用有效价格计算套利机会（正确考虑镜像订单）
   * 详细文档见: docs/01-polymarket-orderbook-arbitrage.md
   */
  async detectArbitrage(
    conditionId: string,
    threshold = 0.005
  ): Promise<ArbitrageOpportunity | null> {
    const orderbook = await this.getOrderbook(conditionId);
    const { effectivePrices, longArbProfit, shortArbProfit } = orderbook.summary;

    if (longArbProfit > threshold) {
      return {
        type: 'long',
        profit: longArbProfit,
        action: `Buy YES @ ${effectivePrices.effectiveBuyYes.toFixed(4)} + Buy NO @ ${effectivePrices.effectiveBuyNo.toFixed(4)}, merge for 1 USDC`,
        expectedProfit: longArbProfit,
      };
    }

    if (shortArbProfit > threshold) {
      return {
        type: 'short',
        profit: shortArbProfit,
        action: `Split 1 USDC, Sell YES @ ${effectivePrices.effectiveSellYes.toFixed(4)} + Sell NO @ ${effectivePrices.effectiveSellNo.toFixed(4)}`,
        expectedProfit: shortArbProfit,
      };
    }

    return null;
  }

  // ===== Cache Management =====

  /**
   * Clear all cached data
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Invalidate cache for a specific market
   */
  invalidateMarketCache(conditionId: string): void {
    this.cache.invalidate(conditionId);
  }
}

================================================================================
// File: src/services/arbitrage-service.ts
================================================================================
/**
 * ArbitrageService - Real-time Arbitrage Detection and Execution
 *
 * Uses WebSocket for real-time orderbook monitoring and automatically
 * detects arbitrage opportunities in Polymarket binary markets.
 *
 * Strategy:
 * - Long Arb: Buy YES + NO (effective cost < $1) → Merge → $1 USDC
 * - Short Arb: Sell pre-held YES + NO tokens (effective revenue > $1)
 *
 * Features:
 * - Real-time orderbook monitoring via WebSocket
 * - Automatic arbitrage detection using effective prices
 * - Configurable profit threshold and trade sizes
 * - Auto-execute mode or event-based manual mode
 * - Balance tracking and position management
 *
 * Based on: scripts/arb/faze-bo3-arb.ts
 * Docs: docs/arbitrage.md
 */

import { EventEmitter } from 'events';
import {
  RealtimeServiceV2,
  type MarketSubscription,
  type OrderbookSnapshot,
} from './realtime-service-v2.js';
import { TradingService } from './trading-service.js';
import { MarketService } from './market-service.js';
import { CTFClient, type TokenIds } from '../clients/ctf-client.js';
import { GammaApiClient } from '../clients/gamma-api.js';
import { RateLimiter } from '../core/rate-limiter.js';
import { createUnifiedCache } from '../core/unified-cache.js';
import { getEffectivePrices } from '../utils/price-utils.js';
import type { BookUpdate } from '../core/types.js';

// ===== Types =====

export interface ArbitrageMarketConfig {
  /** Market name for logging */
  name: string;
  /** Condition ID */
  conditionId: string;
  /** YES token ID from CLOB API */
  yesTokenId: string;
  /** NO token ID from CLOB API */
  noTokenId: string;
  /** Outcome names [YES, NO] */
  outcomes?: [string, string];
}

export interface ArbitrageServiceConfig {
  /** Private key for trading (optional for monitor-only mode) */
  privateKey?: string;
  /** RPC URL for CTF operations */
  rpcUrl?: string;
  /** Minimum profit threshold (default: 0.005 = 0.5%) */
  profitThreshold?: number;
  /** Minimum trade size in USDC (default: 5) */
  minTradeSize?: number;
  /** Maximum single trade size in USDC (default: 100) */
  maxTradeSize?: number;
  /** Minimum token reserve for short arb (default: 10) */
  minTokenReserve?: number;
  /** Auto-execute mode (default: false) */
  autoExecute?: boolean;
  /** Enable logging (default: true) */
  enableLogging?: boolean;
  /** Cooldown between executions in ms (default: 5000) */
  executionCooldown?: number;

  // ===== Rebalancer Config =====
  /** Enable auto-rebalancing (default: false) */
  enableRebalancer?: boolean;
  /** Minimum USDC ratio 0-1 (default: 0.2 = 20%) - Split if below */
  minUsdcRatio?: number;
  /** Maximum USDC ratio 0-1 (default: 0.8 = 80%) - Merge if above */
  maxUsdcRatio?: number;
  /** Target USDC ratio when rebalancing (default: 0.5 = 50%) */
  targetUsdcRatio?: number;
  /** Max YES/NO imbalance before auto-fix (default: 5 tokens) */
  imbalanceThreshold?: number;
  /** Rebalance check interval in ms (default: 10000) */
  rebalanceInterval?: number;
  /** Minimum cooldown between rebalance actions in ms (default: 30000) */
  rebalanceCooldown?: number;
  /** Size safety factor 0-1 (default: 0.8) - use only 80% of orderbook depth to prevent partial fills */
  sizeSafetyFactor?: number;
  /** Auto-fix imbalance after failed execution (default: true) */
  autoFixImbalance?: boolean;
}

export interface RebalanceAction {
  type: 'split' | 'merge' | 'sell_yes' | 'sell_no' | 'none';
  amount: number;
  reason: string;
  priority: number;
}

export interface RebalanceResult {
  success: boolean;
  action: RebalanceAction;
  txHash?: string;
  error?: string;
}

export interface SettleResult {
  market: ArbitrageMarketConfig;
  yesBalance: number;
  noBalance: number;
  pairedTokens: number;
  unpairedYes: number;
  unpairedNo: number;
  merged: boolean;
  mergeAmount?: number;
  mergeTxHash?: string;
  usdcRecovered?: number;
  error?: string;
}

export interface ClearPositionResult {
  market: ArbitrageMarketConfig;
  marketStatus: 'active' | 'resolved' | 'unknown';
  yesBalance: number;
  noBalance: number;
  actions: ClearAction[];
  totalUsdcRecovered: number;
  success: boolean;
  error?: string;
}

export interface ClearAction {
  type: 'merge' | 'sell_yes' | 'sell_no' | 'redeem';
  amount: number;
  usdcResult: number;
  txHash?: string;
  success: boolean;
  error?: string;
}

// ===== Market Scanning Types =====

export interface ScanCriteria {
  /** Minimum 24h volume in USDC (default: 1000) */
  minVolume24h?: number;
  /** Maximum 24h volume (optional) */
  maxVolume24h?: number;
  /** Keywords to filter markets (optional) */
  keywords?: string[];
  /** Maximum number of markets to scan (default: 100) */
  limit?: number;
}

export interface ScanResult {
  /** Market config ready to use with start() */
  market: ArbitrageMarketConfig;
  /** Best arbitrage type */
  arbType: 'long' | 'short' | 'none';
  /** Profit rate (e.g., 0.01 = 1%) */
  profitRate: number;
  /** Profit percentage */
  profitPercent: number;
  /** Effective prices */
  effectivePrices: {
    buyYes: number;
    buyNo: number;
    sellYes: number;
    sellNo: number;
    longCost: number;
    shortRevenue: number;
  };
  /** 24h volume */
  volume24h: number;
  /** Available size on orderbook */
  availableSize: number;
  /** Score 0-100 */
  score: number;
  /** Description */
  description: string;
}

export interface OrderbookState {
  yesBids: Array<{ price: number; size: number }>;
  yesAsks: Array<{ price: number; size: number }>;
  noBids: Array<{ price: number; size: number }>;
  noAsks: Array<{ price: number; size: number }>;
  lastUpdate: number;
}

export interface BalanceState {
  usdc: number;
  yesTokens: number;
  noTokens: number;
  lastUpdate: number;
}

export interface ArbitrageOpportunity {
  type: 'long' | 'short';
  /** Profit rate (0.01 = 1%) */
  profitRate: number;
  /** Profit in percentage */
  profitPercent: number;
  /** Effective buy/sell prices */
  effectivePrices: {
    buyYes: number;
    buyNo: number;
    sellYes: number;
    sellNo: number;
  };
  /** Maximum executable size based on orderbook depth */
  maxOrderbookSize: number;
  /** Maximum executable size based on balance */
  maxBalanceSize: number;
  /** Recommended trade size */
  recommendedSize: number;
  /** Estimated profit in USDC */
  estimatedProfit: number;
  /** Description */
  description: string;
  /** Timestamp */
  timestamp: number;
}

export interface ArbitrageExecutionResult {
  success: boolean;
  type: 'long' | 'short';
  size: number;
  profit: number;
  txHashes: string[];
  error?: string;
  executionTimeMs: number;
}

export interface ArbitrageServiceEvents {
  opportunity: (opportunity: ArbitrageOpportunity) => void;
  execution: (result: ArbitrageExecutionResult) => void;
  balanceUpdate: (balance: BalanceState) => void;
  orderbookUpdate: (orderbook: OrderbookState) => void;
  rebalance: (result: RebalanceResult) => void;
  settle: (result: SettleResult) => void;
  error: (error: Error) => void;
  started: (market: ArbitrageMarketConfig) => void;
  stopped: () => void;
}

// ===== ArbitrageService =====

export class ArbitrageService extends EventEmitter {
  private realtimeService: RealtimeServiceV2;
  private marketSubscription: MarketSubscription | null = null;
  private ctf: CTFClient | null = null;
  private tradingService: TradingService | null = null;
  private rateLimiter: RateLimiter;

  private market: ArbitrageMarketConfig | null = null;
  private config: Omit<Required<ArbitrageServiceConfig>, 'privateKey' | 'rpcUrl' | 'rebalanceInterval'> & {
    privateKey?: string;
    rpcUrl?: string;
    rebalanceIntervalMs: number;
  };

  private orderbook: OrderbookState = {
    yesBids: [],
    yesAsks: [],
    noBids: [],
    noAsks: [],
    lastUpdate: 0,
  };

  private balance: BalanceState = {
    usdc: 0,
    yesTokens: 0,
    noTokens: 0,
    lastUpdate: 0,
  };

  private isExecuting = false;
  private lastExecutionTime = 0;
  private lastRebalanceTime = 0;
  private balanceUpdateInterval: ReturnType<typeof setInterval> | null = null;
  private rebalanceInterval: ReturnType<typeof setInterval> | null = null;
  private isRunning = false;
  private totalCapital = 0;

  // Statistics
  private stats = {
    opportunitiesDetected: 0,
    executionsAttempted: 0,
    executionsSucceeded: 0,
    totalProfit: 0,
    startTime: 0,
  };

  constructor(config: ArbitrageServiceConfig = {}) {
    super();

    this.config = {
      privateKey: config.privateKey,
      rpcUrl: config.rpcUrl || 'https://polygon-rpc.com',
      profitThreshold: config.profitThreshold ?? 0.005,
      minTradeSize: config.minTradeSize ?? 5,
      maxTradeSize: config.maxTradeSize ?? 100,
      minTokenReserve: config.minTokenReserve ?? 10,
      autoExecute: config.autoExecute ?? false,
      enableLogging: config.enableLogging ?? true,
      executionCooldown: config.executionCooldown ?? 5000,
      // Rebalancer config
      enableRebalancer: config.enableRebalancer ?? false,
      minUsdcRatio: config.minUsdcRatio ?? 0.2,
      maxUsdcRatio: config.maxUsdcRatio ?? 0.8,
      targetUsdcRatio: config.targetUsdcRatio ?? 0.5,
      imbalanceThreshold: config.imbalanceThreshold ?? 5,
      rebalanceIntervalMs: config.rebalanceInterval ?? 10000,
      rebalanceCooldown: config.rebalanceCooldown ?? 30000,
      // Execution safety
      sizeSafetyFactor: config.sizeSafetyFactor ?? 0.8,
      autoFixImbalance: config.autoFixImbalance ?? true,
    };

    this.rateLimiter = new RateLimiter();
    this.realtimeService = new RealtimeServiceV2({ debug: false });

    // Initialize trading clients if private key provided
    if (this.config.privateKey) {
      this.ctf = new CTFClient({
        privateKey: this.config.privateKey,
        rpcUrl: this.config.rpcUrl,
      });

      const cache = createUnifiedCache();
      this.tradingService = new TradingService(this.rateLimiter, cache, {
        privateKey: this.config.privateKey,
        chainId: 137,
      });
    }

    // RealtimeServiceV2 event handlers are set up during subscription
  }

  // ===== Public API =====

  /**
   * Start monitoring a market for arbitrage opportunities
   */
  async start(market: ArbitrageMarketConfig): Promise<void> {
    if (this.isRunning) {
      throw new Error('ArbitrageService is already running. Call stop() first.');
    }

    this.market = market;
    this.isRunning = true;
    this.stats.startTime = Date.now();

    this.log(`Starting arbitrage monitor for: ${market.name}`);
    this.log(`Condition ID: ${market.conditionId.slice(0, 20)}...`);
    this.log(`Profit Threshold: ${(this.config.profitThreshold * 100).toFixed(2)}%`);
    this.log(`Auto Execute: ${this.config.autoExecute ? 'YES' : 'NO'}`);

    // Initialize trading service
    if (this.tradingService) {
      await this.tradingService.initialize();
      this.log(`Wallet: ${this.ctf?.getAddress()}`);
      await this.updateBalance();
      this.log(`USDC Balance: ${this.balance.usdc.toFixed(2)}`);
      this.log(`YES Tokens: ${this.balance.yesTokens.toFixed(2)}`);
      this.log(`NO Tokens: ${this.balance.noTokens.toFixed(2)}`);

      // Calculate total capital (USDC + paired tokens)
      const pairedTokens = Math.min(this.balance.yesTokens, this.balance.noTokens);
      this.totalCapital = this.balance.usdc + pairedTokens;
      this.log(`Total Capital: ${this.totalCapital.toFixed(2)}`);

      // Start balance update interval
      this.balanceUpdateInterval = setInterval(() => this.updateBalance(), 30000);

      // Start rebalancer if enabled
      if (this.config.enableRebalancer) {
        this.log(`Rebalancer: ENABLED (USDC range: ${(this.config.minUsdcRatio * 100).toFixed(0)}%-${(this.config.maxUsdcRatio * 100).toFixed(0)}%, target: ${(this.config.targetUsdcRatio * 100).toFixed(0)}%)`);
        this.rebalanceInterval = setInterval(
          () => this.checkAndRebalance(),
          this.config.rebalanceIntervalMs
        );
      }
    } else {
      this.log('No wallet configured - monitoring only');
    }

    // Connect and subscribe to WebSocket
    this.realtimeService.connect();
    this.marketSubscription = this.realtimeService.subscribeMarkets(
      [market.yesTokenId, market.noTokenId],
      {
        onOrderbook: (book: OrderbookSnapshot) => {
          // Convert OrderbookSnapshot to BookUpdate format
          const bookUpdate: BookUpdate = {
            assetId: book.assetId,
            bids: book.bids,
            asks: book.asks,
            timestamp: book.timestamp,
          };
          this.handleBookUpdate(bookUpdate);
        },
        onError: (error: Error) => this.emit('error', error),
      }
    );

    this.emit('started', market);
    this.log('Monitoring for arbitrage opportunities...');
  }

  /**
   * Stop monitoring
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;

    this.isRunning = false;

    if (this.balanceUpdateInterval) {
      clearInterval(this.balanceUpdateInterval);
      this.balanceUpdateInterval = null;
    }

    if (this.rebalanceInterval) {
      clearInterval(this.rebalanceInterval);
      this.rebalanceInterval = null;
    }

    // Unsubscribe and disconnect
    if (this.marketSubscription) {
      this.marketSubscription.unsubscribe();
      this.marketSubscription = null;
    }
    this.realtimeService.disconnect();

    this.log('Stopped');
    this.log(`Total opportunities: ${this.stats.opportunitiesDetected}`);
    this.log(`Executions: ${this.stats.executionsSucceeded}/${this.stats.executionsAttempted}`);
    this.log(`Total profit: $${this.stats.totalProfit.toFixed(2)}`);

    this.emit('stopped');
  }

  /**
   * Get current orderbook state
   */
  getOrderbook(): OrderbookState {
    return { ...this.orderbook };
  }

  /**
   * Get current balance state
   */
  getBalance(): BalanceState {
    return { ...this.balance };
  }

  /**
   * Get statistics
   */
  getStats() {
    return {
      ...this.stats,
      runningTimeMs: this.isRunning ? Date.now() - this.stats.startTime : 0,
    };
  }

  /**
   * Check for arbitrage opportunity based on current orderbook
   */
  checkOpportunity(): ArbitrageOpportunity | null {
    if (!this.market) return null;

    const { yesBids, yesAsks, noBids, noAsks } = this.orderbook;
    if (yesBids.length === 0 || yesAsks.length === 0 || noBids.length === 0 || noAsks.length === 0) {
      return null;
    }

    const yesBestBid = yesBids[0]?.price || 0;
    const yesBestAsk = yesAsks[0]?.price || 1;
    const noBestBid = noBids[0]?.price || 0;
    const noBestAsk = noAsks[0]?.price || 1;

    // Calculate effective prices
    const effective = getEffectivePrices(yesBestAsk, yesBestBid, noBestAsk, noBestBid);

    // Check for arbitrage
    const longCost = effective.effectiveBuyYes + effective.effectiveBuyNo;
    const longProfit = 1 - longCost;
    const shortRevenue = effective.effectiveSellYes + effective.effectiveSellNo;
    const shortProfit = shortRevenue - 1;

    // Calculate sizes with safety factor to prevent partial fills
    // Use min of both sides * safety factor to ensure both orders can fill
    const safetyFactor = this.config.sizeSafetyFactor;
    const orderbookLongSize = Math.min(yesAsks[0]?.size || 0, noAsks[0]?.size || 0) * safetyFactor;
    const orderbookShortSize = Math.min(yesBids[0]?.size || 0, noBids[0]?.size || 0) * safetyFactor;
    const heldPairs = Math.min(this.balance.yesTokens, this.balance.noTokens);
    const balanceLongSize = longCost > 0 ? this.balance.usdc / longCost : 0;

    // Check long arb
    if (longProfit > this.config.profitThreshold) {
      const maxSize = Math.min(orderbookLongSize, balanceLongSize * safetyFactor, this.config.maxTradeSize);
      if (maxSize >= this.config.minTradeSize) {
        return {
          type: 'long',
          profitRate: longProfit,
          profitPercent: longProfit * 100,
          effectivePrices: {
            buyYes: effective.effectiveBuyYes,
            buyNo: effective.effectiveBuyNo,
            sellYes: effective.effectiveSellYes,
            sellNo: effective.effectiveSellNo,
          },
          maxOrderbookSize: orderbookLongSize,
          maxBalanceSize: balanceLongSize,
          recommendedSize: maxSize,
          estimatedProfit: longProfit * maxSize,
          description: `Buy YES @ ${effective.effectiveBuyYes.toFixed(4)} + NO @ ${effective.effectiveBuyNo.toFixed(4)}, Merge for $1`,
          timestamp: Date.now(),
        };
      }
    }

    // Check short arb
    if (shortProfit > this.config.profitThreshold) {
      const maxSize = Math.min(orderbookShortSize, heldPairs, this.config.maxTradeSize);
      if (maxSize >= this.config.minTradeSize && heldPairs >= this.config.minTokenReserve) {
        return {
          type: 'short',
          profitRate: shortProfit,
          profitPercent: shortProfit * 100,
          effectivePrices: {
            buyYes: effective.effectiveBuyYes,
            buyNo: effective.effectiveBuyNo,
            sellYes: effective.effectiveSellYes,
            sellNo: effective.effectiveSellNo,
          },
          maxOrderbookSize: orderbookShortSize,
          maxBalanceSize: heldPairs,
          recommendedSize: maxSize,
          estimatedProfit: shortProfit * maxSize,
          description: `Sell YES @ ${effective.effectiveSellYes.toFixed(4)} + NO @ ${effective.effectiveSellNo.toFixed(4)}`,
          timestamp: Date.now(),
        };
      }
    }

    return null;
  }

  /**
   * Manually execute an arbitrage opportunity
   */
  async execute(opportunity: ArbitrageOpportunity): Promise<ArbitrageExecutionResult> {
    if (!this.ctf || !this.tradingService || !this.market) {
      return {
        success: false,
        type: opportunity.type,
        size: 0,
        profit: 0,
        txHashes: [],
        error: 'Trading not configured (no private key)',
        executionTimeMs: 0,
      };
    }

    if (this.isExecuting) {
      return {
        success: false,
        type: opportunity.type,
        size: 0,
        profit: 0,
        txHashes: [],
        error: 'Another execution in progress',
        executionTimeMs: 0,
      };
    }

    this.isExecuting = true;
    this.stats.executionsAttempted++;
    const startTime = Date.now();

    try {
      const result = opportunity.type === 'long'
        ? await this.executeLongArb(opportunity)
        : await this.executeShortArb(opportunity);

      if (result.success) {
        this.stats.executionsSucceeded++;
        this.stats.totalProfit += result.profit;
        this.lastExecutionTime = Date.now();
      }

      this.emit('execution', result);
      return result;
    } finally {
      this.isExecuting = false;
      // Update balance after execution
      await this.updateBalance();
    }
  }

  // ===== Rebalancer Methods =====

  /**
   * Calculate recommended rebalance action based on current state
   */
  calculateRebalanceAction(): RebalanceAction {
    if (!this.market || this.totalCapital === 0) {
      return { type: 'none', amount: 0, reason: 'No market or capital', priority: 0 };
    }

    const { usdc, yesTokens, noTokens } = this.balance;
    const pairedTokens = Math.min(yesTokens, noTokens);
    const currentTotal = usdc + pairedTokens;
    const usdcRatio = usdc / currentTotal;
    const tokenImbalance = yesTokens - noTokens;

    // Priority 1: Fix YES/NO imbalance (highest priority - risk control)
    if (Math.abs(tokenImbalance) > this.config.imbalanceThreshold) {
      if (tokenImbalance > 0) {
        const sellAmount = Math.min(tokenImbalance, yesTokens * 0.5);
        if (sellAmount >= this.config.minTradeSize) {
          return {
            type: 'sell_yes',
            amount: Math.floor(sellAmount * 1e6) / 1e6,
            reason: `Risk: YES > NO by ${tokenImbalance.toFixed(2)}`,
            priority: 100,
          };
        }
      } else {
        const sellAmount = Math.min(-tokenImbalance, noTokens * 0.5);
        if (sellAmount >= this.config.minTradeSize) {
          return {
            type: 'sell_no',
            amount: Math.floor(sellAmount * 1e6) / 1e6,
            reason: `Risk: NO > YES by ${(-tokenImbalance).toFixed(2)}`,
            priority: 100,
          };
        }
      }
    }

    // Priority 2: USDC ratio too high (> maxUsdcRatio) → Split to create tokens
    if (usdcRatio > this.config.maxUsdcRatio) {
      const targetUsdc = this.totalCapital * this.config.targetUsdcRatio;
      const excessUsdc = usdc - targetUsdc;
      const splitAmount = Math.min(excessUsdc * 0.5, usdc * 0.3);
      if (splitAmount >= this.config.minTradeSize) {
        return {
          type: 'split',
          amount: Math.floor(splitAmount * 100) / 100,
          reason: `USDC ${(usdcRatio * 100).toFixed(0)}% > ${(this.config.maxUsdcRatio * 100).toFixed(0)}% max`,
          priority: 50,
        };
      }
    }

    // Priority 3: USDC ratio too low (< minUsdcRatio) → Merge tokens to recover USDC
    if (usdcRatio < this.config.minUsdcRatio && pairedTokens >= this.config.minTradeSize) {
      const targetUsdc = this.totalCapital * this.config.targetUsdcRatio;
      const neededUsdc = targetUsdc - usdc;
      const mergeAmount = Math.min(neededUsdc * 0.5, pairedTokens * 0.5);
      if (mergeAmount >= this.config.minTradeSize) {
        return {
          type: 'merge',
          amount: Math.floor(mergeAmount * 100) / 100,
          reason: `USDC ${(usdcRatio * 100).toFixed(0)}% < ${(this.config.minUsdcRatio * 100).toFixed(0)}% min`,
          priority: 50,
        };
      }
    }

    return { type: 'none', amount: 0, reason: 'Balanced', priority: 0 };
  }

  /**
   * Execute a rebalance action
   */
  async rebalance(action?: RebalanceAction): Promise<RebalanceResult> {
    if (!this.ctf || !this.tradingService || !this.market) {
      return {
        success: false,
        action: action || { type: 'none', amount: 0, reason: 'No trading config', priority: 0 },
        error: 'Trading not configured',
      };
    }

    const rebalanceAction = action || this.calculateRebalanceAction();
    if (rebalanceAction.type === 'none') {
      return { success: true, action: rebalanceAction };
    }

    this.log(`\n🔄 Rebalance: ${rebalanceAction.type.toUpperCase()} ${rebalanceAction.amount.toFixed(2)}`);
    this.log(`   Reason: ${rebalanceAction.reason}`);

    try {
      let txHash: string | undefined;

      switch (rebalanceAction.type) {
        case 'split': {
          const result = await this.ctf.split(this.market.conditionId, rebalanceAction.amount.toString());
          txHash = result.txHash;
          this.log(`   ✅ Split TX: ${txHash}`);
          break;
        }
        case 'merge': {
          const tokenIds: TokenIds = {
            yesTokenId: this.market.yesTokenId,
            noTokenId: this.market.noTokenId,
          };
          const result = await this.ctf.mergeByTokenIds(
            this.market.conditionId,
            tokenIds,
            rebalanceAction.amount.toString()
          );
          txHash = result.txHash;
          this.log(`   ✅ Merge TX: ${txHash}`);
          break;
        }
        case 'sell_yes': {
          const result = await this.tradingService.createMarketOrder({
            tokenId: this.market.yesTokenId,
            side: 'SELL',
            amount: rebalanceAction.amount,
            orderType: 'FOK',
          });
          if (!result.success) {
            throw new Error(result.errorMsg || 'Sell YES failed');
          }
          this.log(`   ✅ Sold ${rebalanceAction.amount.toFixed(2)} YES tokens`);
          break;
        }
        case 'sell_no': {
          const result = await this.tradingService.createMarketOrder({
            tokenId: this.market.noTokenId,
            side: 'SELL',
            amount: rebalanceAction.amount,
            orderType: 'FOK',
          });
          if (!result.success) {
            throw new Error(result.errorMsg || 'Sell NO failed');
          }
          this.log(`   ✅ Sold ${rebalanceAction.amount.toFixed(2)} NO tokens`);
          break;
        }
      }

      await this.updateBalance();
      const rebalanceResult: RebalanceResult = { success: true, action: rebalanceAction, txHash };
      this.emit('rebalance', rebalanceResult);
      return rebalanceResult;
    } catch (error: any) {
      this.log(`   ❌ Failed: ${error.message}`);
      const rebalanceResult: RebalanceResult = {
        success: false,
        action: rebalanceAction,
        error: error.message,
      };
      this.emit('rebalance', rebalanceResult);
      return rebalanceResult;
    }
  }

  // ===== Settle Position Methods =====

  /**
   * Settle a market position - merge paired tokens to recover USDC
   * @param market Market to settle (defaults to current market)
   * @param execute If true, execute the merge. If false, just return info.
   */
  async settlePosition(market?: ArbitrageMarketConfig, execute = false): Promise<SettleResult> {
    const targetMarket = market || this.market;
    if (!targetMarket) {
      throw new Error('No market specified');
    }

    if (!this.ctf) {
      return {
        market: targetMarket,
        yesBalance: 0,
        noBalance: 0,
        pairedTokens: 0,
        unpairedYes: 0,
        unpairedNo: 0,
        merged: false,
        error: 'CTF client not configured',
      };
    }

    const tokenIds: TokenIds = {
      yesTokenId: targetMarket.yesTokenId,
      noTokenId: targetMarket.noTokenId,
    };

    // Get token balances
    const positions = await this.ctf.getPositionBalanceByTokenIds(targetMarket.conditionId, tokenIds);
    const yesBalance = parseFloat(positions.yesBalance);
    const noBalance = parseFloat(positions.noBalance);

    const pairedTokens = Math.min(yesBalance, noBalance);
    const unpairedYes = yesBalance - pairedTokens;
    const unpairedNo = noBalance - pairedTokens;

    this.log(`\n📊 Position: ${targetMarket.name}`);
    this.log(`   YES: ${yesBalance.toFixed(6)}`);
    this.log(`   NO: ${noBalance.toFixed(6)}`);
    this.log(`   Paired: ${pairedTokens.toFixed(6)} (can merge → $${pairedTokens.toFixed(2)} USDC)`);

    if (unpairedYes > 0.001) {
      this.log(`   ⚠️ Unpaired YES: ${unpairedYes.toFixed(6)}`);
    }
    if (unpairedNo > 0.001) {
      this.log(`   ⚠️ Unpaired NO: ${unpairedNo.toFixed(6)}`);
    }

    const result: SettleResult = {
      market: targetMarket,
      yesBalance,
      noBalance,
      pairedTokens,
      unpairedYes,
      unpairedNo,
      merged: false,
    };

    // Execute merge if requested and we have enough pairs
    if (execute && pairedTokens >= 1) {
      const mergeAmount = Math.floor(pairedTokens * 1e6) / 1e6;
      this.log(`\n🔄 Merging ${mergeAmount.toFixed(6)} token pairs...`);

      try {
        const mergeResult = await this.ctf.mergeByTokenIds(
          targetMarket.conditionId,
          tokenIds,
          mergeAmount.toString()
        );
        result.merged = true;
        result.mergeAmount = mergeAmount;
        result.mergeTxHash = mergeResult.txHash;
        result.usdcRecovered = mergeAmount;
        this.log(`   ✅ Merge TX: ${mergeResult.txHash}`);
        this.log(`   ✅ Recovered: $${mergeAmount.toFixed(2)} USDC`);
      } catch (error: any) {
        result.error = error.message;
        this.log(`   ❌ Merge failed: ${error.message}`);
      }
    } else if (pairedTokens >= 1) {
      this.log(`   💡 Run settlePosition(market, true) to recover $${pairedTokens.toFixed(2)} USDC`);
    }

    this.emit('settle', result);
    return result;
  }

  /**
   * Settle multiple markets at once
   */
  async settleMultiple(markets: ArbitrageMarketConfig[], execute = false): Promise<SettleResult[]> {
    const results: SettleResult[] = [];
    let totalMerged = 0;
    let totalUnpairedYes = 0;
    let totalUnpairedNo = 0;

    for (const market of markets) {
      const result = await this.settlePosition(market, execute);
      results.push(result);
      if (result.usdcRecovered) totalMerged += result.usdcRecovered;
      totalUnpairedYes += result.unpairedYes;
      totalUnpairedNo += result.unpairedNo;
    }

    this.log(`\n═══════════════════════════════════════`);
    this.log(`SUMMARY: ${markets.length} markets`);
    if (execute) {
      this.log(`Total Merged: $${totalMerged.toFixed(2)} USDC`);
    }
    if (totalUnpairedYes > 0.001 || totalUnpairedNo > 0.001) {
      this.log(`Unpaired YES: ${totalUnpairedYes.toFixed(6)}`);
      this.log(`Unpaired NO: ${totalUnpairedNo.toFixed(6)}`);
    }

    return results;
  }

  /**
   * Clear all positions in a market using the best strategy
   *
   * Strategy:
   * - Active market: Merge paired tokens → Sell remaining unpaired tokens
   * - Resolved market: Redeem winning tokens
   *
   * @param market Market to clear positions from
   * @param execute If true, execute the clearing. If false, just return info.
   * @returns Result with all actions taken
   *
   * @example
   * ```typescript
   * const service = new ArbitrageService({ privateKey: '0x...' });
   *
   * // View clearing plan
   * const plan = await service.clearPositions(market, false);
   * console.log(`Will recover: $${plan.totalUsdcRecovered}`);
   *
   * // Execute clearing
   * const result = await service.clearPositions(market, true);
   * ```
   */
  async clearPositions(market: ArbitrageMarketConfig, execute = false): Promise<ClearPositionResult> {
    if (!this.ctf) {
      return {
        market,
        marketStatus: 'unknown',
        yesBalance: 0,
        noBalance: 0,
        actions: [],
        totalUsdcRecovered: 0,
        success: false,
        error: 'CTF client not configured',
      };
    }

    const tokenIds: TokenIds = {
      yesTokenId: market.yesTokenId,
      noTokenId: market.noTokenId,
    };

    // Get token balances
    const positions = await this.ctf.getPositionBalanceByTokenIds(market.conditionId, tokenIds);
    const yesBalance = parseFloat(positions.yesBalance);
    const noBalance = parseFloat(positions.noBalance);

    if (yesBalance < 0.001 && noBalance < 0.001) {
      this.log(`No positions to clear for ${market.name}`);
      return {
        market,
        marketStatus: 'unknown',
        yesBalance,
        noBalance,
        actions: [],
        totalUsdcRecovered: 0,
        success: true,
      };
    }

    this.log(`\n🧹 Clearing positions: ${market.name}`);
    this.log(`   YES: ${yesBalance.toFixed(6)}, NO: ${noBalance.toFixed(6)}`);

    // Check if market is resolved
    let marketStatus: 'active' | 'resolved' | 'unknown' = 'unknown';
    // winningOutcome can be any outcome name (YES/NO, Up/Down, Team1/Team2, etc.)
    let winningOutcome: string | undefined;

    try {
      const resolution = await this.ctf.getMarketResolution(market.conditionId);
      marketStatus = resolution.isResolved ? 'resolved' : 'active';
      winningOutcome = resolution.winningOutcome;
      this.log(`   Status: ${marketStatus}${resolution.isResolved ? ` (Winner: ${winningOutcome})` : ''}`);
    } catch {
      // If we can't determine resolution, try to get market status from MarketService
      try {
        const cache = createUnifiedCache();
        const tempMarketService = new MarketService(undefined, undefined, this.rateLimiter, cache);
        const clobMarket = await tempMarketService.getClobMarket(market.conditionId);
        if (clobMarket) {
          marketStatus = clobMarket.closed ? 'resolved' : 'active';
          this.log(`   Status: ${marketStatus} (from MarketService)`);
        } else {
          this.log(`   Status: unknown (market not found, assuming active)`);
          marketStatus = 'active';
        }
      } catch {
        this.log(`   Status: unknown (assuming active)`);
        marketStatus = 'active';
      }
    }

    const actions: ClearAction[] = [];
    let totalUsdcRecovered = 0;

    if (!execute) {
      // Dry run - calculate expected actions
      if (marketStatus === 'resolved' && winningOutcome) {
        // Resolved market: redeem winning tokens
        const winningBalance = winningOutcome === 'YES' ? yesBalance : noBalance;
        if (winningBalance >= 0.001) {
          actions.push({
            type: 'redeem',
            amount: winningBalance,
            usdcResult: winningBalance, // 1 USDC per winning token
            success: true,
          });
          totalUsdcRecovered = winningBalance;
        }
      } else {
        // Active market: merge + sell
        const pairedTokens = Math.min(yesBalance, noBalance);
        const unpairedYes = yesBalance - pairedTokens;
        const unpairedNo = noBalance - pairedTokens;

        if (pairedTokens >= 1) {
          actions.push({
            type: 'merge',
            amount: pairedTokens,
            usdcResult: pairedTokens,
            success: true,
          });
          totalUsdcRecovered += pairedTokens;
        }

        // For unpaired tokens, estimate sell price (assume ~0.5 if unknown)
        if (unpairedYes >= this.config.minTradeSize) {
          const estimatedPrice = 0.5; // Conservative estimate
          actions.push({
            type: 'sell_yes',
            amount: unpairedYes,
            usdcResult: unpairedYes * estimatedPrice,
            success: true,
          });
          totalUsdcRecovered += unpairedYes * estimatedPrice;
        }

        if (unpairedNo >= this.config.minTradeSize) {
          const estimatedPrice = 0.5;
          actions.push({
            type: 'sell_no',
            amount: unpairedNo,
            usdcResult: unpairedNo * estimatedPrice,
            success: true,
          });
          totalUsdcRecovered += unpairedNo * estimatedPrice;
        }
      }

      this.log(`   📋 Plan: ${actions.length} actions, ~$${totalUsdcRecovered.toFixed(2)} USDC`);
      for (const action of actions) {
        this.log(`      - ${action.type}: ${action.amount.toFixed(4)} → ~$${action.usdcResult.toFixed(2)}`);
      }

      return {
        market,
        marketStatus,
        yesBalance,
        noBalance,
        actions,
        totalUsdcRecovered,
        success: true,
      };
    }

    // Execute clearing
    this.log(`   🔄 Executing...`);

    if (marketStatus === 'resolved' && winningOutcome) {
      // Resolved market: redeem
      const winningBalance = winningOutcome === 'YES' ? yesBalance : noBalance;
      if (winningBalance >= 0.001) {
        try {
          const redeemResult = await this.ctf.redeem(market.conditionId);
          actions.push({
            type: 'redeem',
            amount: winningBalance,
            usdcResult: winningBalance,
            txHash: redeemResult.txHash,
            success: true,
          });
          totalUsdcRecovered = winningBalance;
          this.log(`   ✅ Redeemed: ${winningBalance.toFixed(4)} tokens → $${winningBalance.toFixed(2)} USDC`);
        } catch (error: any) {
          actions.push({
            type: 'redeem',
            amount: winningBalance,
            usdcResult: 0,
            success: false,
            error: error.message,
          });
          this.log(`   ❌ Redeem failed: ${error.message}`);
        }
      }
    } else {
      // Active market: merge + sell
      const pairedTokens = Math.min(yesBalance, noBalance);
      let unpairedYes = yesBalance - pairedTokens;
      let unpairedNo = noBalance - pairedTokens;

      // Step 1: Merge paired tokens
      if (pairedTokens >= 1) {
        const mergeAmount = Math.floor(pairedTokens * 1e6) / 1e6;
        try {
          const mergeResult = await this.ctf.mergeByTokenIds(
            market.conditionId,
            tokenIds,
            mergeAmount.toString()
          );
          actions.push({
            type: 'merge',
            amount: mergeAmount,
            usdcResult: mergeAmount,
            txHash: mergeResult.txHash,
            success: true,
          });
          totalUsdcRecovered += mergeAmount;
          this.log(`   ✅ Merged: ${mergeAmount.toFixed(4)} pairs → $${mergeAmount.toFixed(2)} USDC`);
        } catch (error: any) {
          actions.push({
            type: 'merge',
            amount: mergeAmount,
            usdcResult: 0,
            success: false,
            error: error.message,
          });
          this.log(`   ❌ Merge failed: ${error.message}`);
          // Update unpaired amounts since merge failed
          unpairedYes = yesBalance;
          unpairedNo = noBalance;
        }
      }

      // Step 2: Sell unpaired tokens
      if (this.tradingService && unpairedYes >= this.config.minTradeSize) {
        try {
          const sellAmount = Math.floor(unpairedYes * 1e6) / 1e6;
          const result = await this.tradingService.createMarketOrder({
            tokenId: market.yesTokenId,
            side: 'SELL',
            amount: sellAmount,
            orderType: 'FOK',
          });
          if (result.success) {
            // Estimate USDC received (conservative estimate since we don't have exact trade info)
            const usdcReceived = sellAmount * 0.5; // Assume ~0.5 average price
            actions.push({
              type: 'sell_yes',
              amount: sellAmount,
              usdcResult: usdcReceived,
              success: true,
            });
            totalUsdcRecovered += usdcReceived;
            this.log(`   ✅ Sold YES: ${sellAmount.toFixed(4)} → ~$${usdcReceived.toFixed(2)} USDC`);
          } else {
            throw new Error(result.errorMsg || 'Sell failed');
          }
        } catch (error: any) {
          actions.push({
            type: 'sell_yes',
            amount: unpairedYes,
            usdcResult: 0,
            success: false,
            error: error.message,
          });
          this.log(`   ❌ Sell YES failed: ${error.message}`);
        }
      }

      if (this.tradingService && unpairedNo >= this.config.minTradeSize) {
        try {
          const sellAmount = Math.floor(unpairedNo * 1e6) / 1e6;
          const result = await this.tradingService.createMarketOrder({
            tokenId: market.noTokenId,
            side: 'SELL',
            amount: sellAmount,
            orderType: 'FOK',
          });
          if (result.success) {
            // Estimate USDC received (conservative estimate since we don't have exact trade info)
            const usdcReceived = sellAmount * 0.5; // Assume ~0.5 average price
            actions.push({
              type: 'sell_no',
              amount: sellAmount,
              usdcResult: usdcReceived,
              success: true,
            });
            totalUsdcRecovered += usdcReceived;
            this.log(`   ✅ Sold NO: ${sellAmount.toFixed(4)} → ~$${usdcReceived.toFixed(2)} USDC`);
          } else {
            throw new Error(result.errorMsg || 'Sell failed');
          }
        } catch (error: any) {
          actions.push({
            type: 'sell_no',
            amount: unpairedNo,
            usdcResult: 0,
            success: false,
            error: error.message,
          });
          this.log(`   ❌ Sell NO failed: ${error.message}`);
        }
      }
    }

    const allSuccess = actions.every((a) => a.success);
    this.log(`   📊 Result: ${actions.filter((a) => a.success).length}/${actions.length} succeeded, $${totalUsdcRecovered.toFixed(2)} recovered`);

    const result: ClearPositionResult = {
      market,
      marketStatus,
      yesBalance,
      noBalance,
      actions,
      totalUsdcRecovered,
      success: allSuccess,
    };

    this.emit('settle', result);
    return result;
  }

  /**
   * Clear positions from multiple markets
   *
   * @param markets Markets to clear
   * @param execute If true, execute clearing
   * @returns Results for all markets
   */
  async clearAllPositions(markets: ArbitrageMarketConfig[], execute = false): Promise<ClearPositionResult[]> {
    const results: ClearPositionResult[] = [];
    let totalRecovered = 0;

    this.log(`\n🧹 Clearing positions from ${markets.length} markets...`);

    for (const market of markets) {
      const result = await this.clearPositions(market, execute);
      results.push(result);
      totalRecovered += result.totalUsdcRecovered;
    }

    this.log(`\n═══════════════════════════════════════`);
    this.log(`TOTAL: $${totalRecovered.toFixed(2)} USDC ${execute ? 'recovered' : 'expected'}`);

    return results;
  }

  // ===== Private Methods =====

  private handleBookUpdate(update: BookUpdate): void {
    if (!this.market) return;

    const { assetId, bids, asks } = update;

    type PriceLevel = { price: number; size: number };
    if (assetId === this.market.yesTokenId) {
      this.orderbook.yesBids = bids.sort((a: PriceLevel, b: PriceLevel) => b.price - a.price);
      this.orderbook.yesAsks = asks.sort((a: PriceLevel, b: PriceLevel) => a.price - b.price);
    } else if (assetId === this.market.noTokenId) {
      this.orderbook.noBids = bids.sort((a: PriceLevel, b: PriceLevel) => b.price - a.price);
      this.orderbook.noAsks = asks.sort((a: PriceLevel, b: PriceLevel) => a.price - b.price);
    }

    this.orderbook.lastUpdate = Date.now();
    this.emit('orderbookUpdate', this.orderbook);

    // Check for arbitrage opportunity
    this.checkAndHandleOpportunity();
  }

  private checkAndHandleOpportunity(): void {
    const opportunity = this.checkOpportunity();

    if (opportunity) {
      this.stats.opportunitiesDetected++;
      this.emit('opportunity', opportunity);

      this.log(`\n${'!'.repeat(60)}`);
      this.log(`${opportunity.type.toUpperCase()} ARB: ${opportunity.description}`);
      this.log(`Profit: ${opportunity.profitPercent.toFixed(2)}%, Size: ${opportunity.recommendedSize.toFixed(2)}, Est: $${opportunity.estimatedProfit.toFixed(2)}`);
      this.log('!'.repeat(60));

      // Auto-execute if enabled and cooldown has passed
      if (this.config.autoExecute && !this.isExecuting) {
        const timeSinceLastExecution = Date.now() - this.lastExecutionTime;
        if (timeSinceLastExecution >= this.config.executionCooldown) {
          this.execute(opportunity).catch((error) => {
            this.emit('error', error);
          });
        }
      }
    }
  }

  private async checkAndRebalance(): Promise<void> {
    if (!this.isRunning || this.isExecuting) return;

    // Check cooldown
    const timeSinceLastRebalance = Date.now() - this.lastRebalanceTime;
    if (timeSinceLastRebalance < this.config.rebalanceCooldown) {
      return;
    }

    await this.updateBalance();
    const action = this.calculateRebalanceAction();

    if (action.type !== 'none' && action.amount >= this.config.minTradeSize) {
      await this.rebalance(action);
      this.lastRebalanceTime = Date.now();
    }
  }

  /**
   * Fix YES/NO imbalance immediately after partial execution
   * This is critical when one side of a parallel order fails
   */
  private async fixImbalanceIfNeeded(): Promise<void> {
    if (!this.config.autoFixImbalance || !this.ctf || !this.tradingService || !this.market) return;

    await this.updateBalance();
    const imbalance = this.balance.yesTokens - this.balance.noTokens;

    if (Math.abs(imbalance) <= this.config.imbalanceThreshold) return;

    this.log(`\n⚠️ Imbalance detected after execution: ${imbalance > 0 ? 'YES' : 'NO'} excess = ${Math.abs(imbalance).toFixed(2)}`);

    // Sell the excess tokens to restore balance
    const sellAmount = Math.floor(Math.abs(imbalance) * 0.9 * 1e6) / 1e6; // Sell 90% to be safe
    if (sellAmount < this.config.minTradeSize) return;

    try {
      if (imbalance > 0) {
        // Sell excess YES
        const result = await this.tradingService.createMarketOrder({
          tokenId: this.market.yesTokenId,
          side: 'SELL',
          amount: sellAmount,
          orderType: 'FOK',
        });
        if (result.success) {
          this.log(`   ✅ Sold ${sellAmount.toFixed(2)} excess YES to restore balance`);
        }
      } else {
        // Sell excess NO
        const result = await this.tradingService.createMarketOrder({
          tokenId: this.market.noTokenId,
          side: 'SELL',
          amount: sellAmount,
          orderType: 'FOK',
        });
        if (result.success) {
          this.log(`   ✅ Sold ${sellAmount.toFixed(2)} excess NO to restore balance`);
        }
      }
    } catch (error: any) {
      this.log(`   ❌ Failed to fix imbalance: ${error.message}`);
    }
  }

  private async updateBalance(): Promise<void> {
    if (!this.ctf || !this.market) return;

    try {
      const tokenIds: TokenIds = {
        yesTokenId: this.market.yesTokenId,
        noTokenId: this.market.noTokenId,
      };

      const [usdcBalance, positions] = await Promise.all([
        this.ctf.getUsdcBalance(),
        this.ctf.getPositionBalanceByTokenIds(this.market.conditionId, tokenIds),
      ]);

      this.balance = {
        usdc: parseFloat(usdcBalance),
        yesTokens: parseFloat(positions.yesBalance),
        noTokens: parseFloat(positions.noBalance),
        lastUpdate: Date.now(),
      };

      this.emit('balanceUpdate', this.balance);
    } catch (error) {
      this.emit('error', error as Error);
    }
  }

  private async executeLongArb(opportunity: ArbitrageOpportunity): Promise<ArbitrageExecutionResult> {
    const startTime = Date.now();
    const txHashes: string[] = [];
    const size = opportunity.recommendedSize;

    this.log(`\nExecuting Long Arb (Buy → Merge)...`);

    try {
      const { buyYes, buyNo } = opportunity.effectivePrices;
      const requiredUsdc = (buyYes + buyNo) * size;

      if (this.balance.usdc < requiredUsdc) {
        return {
          success: false,
          type: 'long',
          size,
          profit: 0,
          txHashes,
          error: `Insufficient USDC.e: have ${this.balance.usdc.toFixed(2)}, need ${requiredUsdc.toFixed(2)}`,
          executionTimeMs: Date.now() - startTime,
        };
      }

      // Buy both tokens in parallel
      this.log(`  1. Buying tokens in parallel...`);
      const [buyYesResult, buyNoResult] = await Promise.all([
        this.tradingService!.createMarketOrder({
          tokenId: this.market!.yesTokenId,
          side: 'BUY',
          amount: size * buyYes,
          orderType: 'FOK',
        }),
        this.tradingService!.createMarketOrder({
          tokenId: this.market!.noTokenId,
          side: 'BUY',
          amount: size * buyNo,
          orderType: 'FOK',
        }),
      ]);

      const outcomes = this.market!.outcomes || ['YES', 'NO'];
      this.log(`     ${outcomes[0]}: ${buyYesResult.success ? '✓' : '✗'}, ${outcomes[1]}: ${buyNoResult.success ? '✓' : '✗'}`);

      // If one succeeded and the other failed, we have an imbalance - fix it
      if (!buyYesResult.success || !buyNoResult.success) {
        // Check if partial execution created imbalance
        if (buyYesResult.success !== buyNoResult.success) {
          this.log(`  ⚠️ Partial execution detected - attempting to fix imbalance...`);
          await this.fixImbalanceIfNeeded();
        }
        return {
          success: false,
          type: 'long',
          size,
          profit: 0,
          txHashes,
          error: `Order(s) failed: YES=${buyYesResult.errorMsg}, NO=${buyNoResult.errorMsg}`,
          executionTimeMs: Date.now() - startTime,
        };
      }

      // Merge tokens
      const tokenIds: TokenIds = {
        yesTokenId: this.market!.yesTokenId,
        noTokenId: this.market!.noTokenId,
      };

      // Update balance to get accurate token counts
      await this.updateBalance();
      const heldPairs = Math.min(this.balance.yesTokens, this.balance.noTokens);
      const mergeSize = Math.floor(Math.min(size, heldPairs) * 1e6) / 1e6;

      if (mergeSize >= this.config.minTradeSize) {
        this.log(`  2. Merging ${mergeSize.toFixed(2)} pairs...`);
        try {
          const mergeResult = await this.ctf!.mergeByTokenIds(
            this.market!.conditionId,
            tokenIds,
            mergeSize.toString()
          );
          txHashes.push(mergeResult.txHash);
          this.log(`     TX: ${mergeResult.txHash}`);

          const profit = opportunity.profitRate * mergeSize;
          this.log(`  ✅ Long Arb completed! Profit: ~$${profit.toFixed(2)}`);

          return {
            success: true,
            type: 'long',
            size: mergeSize,
            profit,
            txHashes,
            executionTimeMs: Date.now() - startTime,
          };
        } catch (mergeError: any) {
          this.log(`  ⚠️ Merge failed: ${mergeError.message}`);
          return {
            success: false,
            type: 'long',
            size,
            profit: 0,
            txHashes,
            error: `Merge failed: ${mergeError.message}`,
            executionTimeMs: Date.now() - startTime,
          };
        }
      }

      return {
        success: false,
        type: 'long',
        size,
        profit: 0,
        txHashes,
        error: `Insufficient pairs for merge: ${heldPairs.toFixed(2)}`,
        executionTimeMs: Date.now() - startTime,
      };
    } catch (error: any) {
      return {
        success: false,
        type: 'long',
        size,
        profit: 0,
        txHashes,
        error: error.message,
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  private async executeShortArb(opportunity: ArbitrageOpportunity): Promise<ArbitrageExecutionResult> {
    const startTime = Date.now();
    const txHashes: string[] = [];
    const size = opportunity.recommendedSize;

    this.log(`\nExecuting Short Arb (Sell Pre-held Tokens)...`);

    try {
      const heldPairs = Math.min(this.balance.yesTokens, this.balance.noTokens);

      if (heldPairs < size) {
        return {
          success: false,
          type: 'short',
          size,
          profit: 0,
          txHashes,
          error: `Insufficient held tokens: have ${heldPairs.toFixed(2)}, need ${size.toFixed(2)}`,
          executionTimeMs: Date.now() - startTime,
        };
      }

      // Sell both tokens in parallel
      this.log(`  1. Selling pre-held tokens in parallel...`);
      const [sellYesResult, sellNoResult] = await Promise.all([
        this.tradingService!.createMarketOrder({
          tokenId: this.market!.yesTokenId,
          side: 'SELL',
          amount: size,
          orderType: 'FOK',
        }),
        this.tradingService!.createMarketOrder({
          tokenId: this.market!.noTokenId,
          side: 'SELL',
          amount: size,
          orderType: 'FOK',
        }),
      ]);

      const outcomes = this.market!.outcomes || ['YES', 'NO'];
      this.log(`     ${outcomes[0]}: ${sellYesResult.success ? '✓' : '✗'}, ${outcomes[1]}: ${sellNoResult.success ? '✓' : '✗'}`);

      // If one succeeded and the other failed, we have an imbalance
      if (!sellYesResult.success || !sellNoResult.success) {
        // Check if partial execution created imbalance
        if (sellYesResult.success !== sellNoResult.success) {
          this.log(`  ⚠️ Partial execution detected - imbalance created`);
          // Note: For short arb, we just sold one side, creating imbalance
          // The rebalancer will fix this on next cycle
          await this.fixImbalanceIfNeeded();
        }
        return {
          success: false,
          type: 'short',
          size,
          profit: 0,
          txHashes,
          error: `Order(s) failed: YES=${sellYesResult.errorMsg}, NO=${sellNoResult.errorMsg}`,
          executionTimeMs: Date.now() - startTime,
        };
      }

      const profit = opportunity.profitRate * size;
      this.log(`  ✅ Short Arb completed! Profit: ~$${profit.toFixed(2)}`);

      return {
        success: true,
        type: 'short',
        size,
        profit,
        txHashes,
        executionTimeMs: Date.now() - startTime,
      };
    } catch (error: any) {
      return {
        success: false,
        type: 'short',
        size,
        profit: 0,
        txHashes,
        error: error.message,
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  private log(message: string): void {
    if (this.config.enableLogging) {
      console.log(`[ArbitrageService] ${message}`);
    }
  }

  // ===== Market Scanning Methods =====

  /**
   * Scan markets for arbitrage opportunities
   *
   * @param criteria Filter criteria for markets
   * @param minProfit Minimum profit threshold (default: 0.005 = 0.5%)
   * @returns Array of scan results sorted by profit
   *
   * @example
   * ```typescript
   * const service = new ArbitrageService({ privateKey: '0x...' });
   *
   * // Scan markets with at least $5000 volume
   * const results = await service.scanMarkets({ minVolume24h: 5000 }, 0.005);
   *
   * // Start arbitraging the best opportunity
   * if (results.length > 0 && results[0].arbType !== 'none') {
   *   await service.start(results[0].market);
   * }
   * ```
   */
  async scanMarkets(
    criteria: ScanCriteria = {},
    minProfit = 0.005
  ): Promise<ScanResult[]> {
    const {
      minVolume24h = 1000,
      maxVolume24h,
      keywords = [],
      limit = 100,
    } = criteria;

    this.log(`Scanning markets (minVolume: $${minVolume24h}, minProfit: ${(minProfit * 100).toFixed(2)}%)...`);

    // Create temporary API clients for scanning
    const cache = createUnifiedCache();
    const gammaApi = new GammaApiClient(this.rateLimiter, cache);
    const tempMarketService = new MarketService(gammaApi, undefined, this.rateLimiter, cache);

    // Fetch active markets from Gamma API
    const markets = await gammaApi.getMarkets({
      active: true,
      closed: false,
      limit,
    });

    this.log(`Found ${markets.length} active markets`);

    const results: ScanResult[] = [];

    for (const gammaMarket of markets) {
      try {
        // Filter by volume
        const volume24h = gammaMarket.volume24hr || 0;
        if (volume24h < minVolume24h) continue;
        if (maxVolume24h && volume24h > maxVolume24h) continue;

        // Filter by keywords
        if (keywords.length > 0) {
          const marketText = `${gammaMarket.question} ${gammaMarket.description || ''}`.toLowerCase();
          const hasKeyword = keywords.some((kw) => marketText.includes(kw.toLowerCase()));
          if (!hasKeyword) continue;
        }

        // Skip non-binary markets
        if (!gammaMarket.conditionId || gammaMarket.outcomes?.length !== 2) continue;

        // Get market data for token IDs
        let clobMarket;
        try {
          clobMarket = await tempMarketService.getClobMarket(gammaMarket.conditionId);
          if (!clobMarket) continue; // Skip if market not found
        } catch {
          continue; // Skip if market data not available
        }

        // Use index-based access instead of name-based (supports Yes/No, Up/Down, Team1/Team2, etc.)
        const yesToken = clobMarket.tokens[0];  // primary outcome
        const noToken = clobMarket.tokens[1];   // secondary outcome
        if (!yesToken || !noToken) continue;

        // Get orderbook data
        let orderbook;
        try {
          orderbook = await tempMarketService.getProcessedOrderbook(gammaMarket.conditionId);
        } catch {
          continue; // Skip if orderbook not available
        }

        const { effectivePrices, longArbProfit, shortArbProfit } = orderbook.summary;

        // Determine best arbitrage type
        let arbType: 'long' | 'short' | 'none' = 'none';
        let profitRate = 0;

        if (longArbProfit > minProfit && longArbProfit >= shortArbProfit) {
          arbType = 'long';
          profitRate = longArbProfit;
        } else if (shortArbProfit > minProfit) {
          arbType = 'short';
          profitRate = shortArbProfit;
        }

        // Calculate available size (min of both sides)
        const yesAskSize = orderbook.yes.askSize || 0;
        const noAskSize = orderbook.no.askSize || 0;
        const yesBidSize = orderbook.yes.bidSize || 0;
        const noBidSize = orderbook.no.bidSize || 0;

        const availableSize = arbType === 'long'
          ? Math.min(yesAskSize, noAskSize)
          : Math.min(yesBidSize, noBidSize);

        // Calculate score (profit * volume * available_size)
        const score = profitRate * 100 * Math.log10(volume24h + 1) * Math.min(availableSize, 100) / 100;

        // Create market config
        const marketConfig: ArbitrageMarketConfig = {
          name: gammaMarket.question.slice(0, 60) + (gammaMarket.question.length > 60 ? '...' : ''),
          conditionId: gammaMarket.conditionId,
          yesTokenId: yesToken.tokenId,
          noTokenId: noToken.tokenId,
          outcomes: gammaMarket.outcomes as [string, string],
        };

        const longCost = effectivePrices.effectiveBuyYes + effectivePrices.effectiveBuyNo;
        const shortRevenue = effectivePrices.effectiveSellYes + effectivePrices.effectiveSellNo;

        let description: string;
        if (arbType === 'long') {
          description = `Buy YES@${effectivePrices.effectiveBuyYes.toFixed(4)} + NO@${effectivePrices.effectiveBuyNo.toFixed(4)} = ${longCost.toFixed(4)} → Merge for $1`;
        } else if (arbType === 'short') {
          description = `Sell YES@${effectivePrices.effectiveSellYes.toFixed(4)} + NO@${effectivePrices.effectiveSellNo.toFixed(4)} = ${shortRevenue.toFixed(4)}`;
        } else {
          description = `No opportunity (Long cost: ${longCost.toFixed(4)}, Short rev: ${shortRevenue.toFixed(4)})`;
        }

        results.push({
          market: marketConfig,
          arbType,
          profitRate,
          profitPercent: profitRate * 100,
          effectivePrices: {
            buyYes: effectivePrices.effectiveBuyYes,
            buyNo: effectivePrices.effectiveBuyNo,
            sellYes: effectivePrices.effectiveSellYes,
            sellNo: effectivePrices.effectiveSellNo,
            longCost,
            shortRevenue,
          },
          volume24h,
          availableSize,
          score,
          description,
        });
      } catch (error) {
        // Skip markets with errors
        continue;
      }
    }

    // Sort by profit (descending), then by score
    results.sort((a, b) => {
      if (b.profitRate !== a.profitRate) return b.profitRate - a.profitRate;
      return b.score - a.score;
    });

    this.log(`Found ${results.filter((r) => r.arbType !== 'none').length} markets with arbitrage opportunities`);

    return results;
  }

  /**
   * Quick scan for best arbitrage opportunities
   *
   * @param minProfit Minimum profit threshold (default: 0.005 = 0.5%)
   * @param limit Maximum number of results to return (default: 10)
   * @returns Top arbitrage opportunities
   *
   * @example
   * ```typescript
   * const service = new ArbitrageService({ privateKey: '0x...' });
   *
   * // Find best arbitrage opportunities
   * const top = await service.quickScan(0.005, 5);
   *
   * // Print results
   * for (const r of top) {
   *   console.log(`${r.market.name}: ${r.arbType} +${r.profitPercent.toFixed(2)}%`);
   * }
   *
   * // Start the best one
   * if (top.length > 0) {
   *   await service.start(top[0].market);
   * }
   * ```
   */
  async quickScan(minProfit = 0.005, limit = 10): Promise<ScanResult[]> {
    const results = await this.scanMarkets(
      { minVolume24h: 5000, limit: 100 },
      minProfit
    );

    // Return only markets with opportunities, limited to requested count
    return results
      .filter((r) => r.arbType !== 'none')
      .slice(0, limit);
  }

  /**
   * Find and start arbitraging the best opportunity
   *
   * @param minProfit Minimum profit threshold (default: 0.005 = 0.5%)
   * @returns The scan result that was started, or null if none found
   *
   * @example
   * ```typescript
   * const service = new ArbitrageService({
   *   privateKey: '0x...',
   *   autoExecute: true,
   *   profitThreshold: 0.005,
   * });
   *
   * // Find and start the best opportunity
   * const started = await service.findAndStart(0.005);
   * if (started) {
   *   console.log(`Started: ${started.market.name} (+${started.profitPercent.toFixed(2)}%)`);
   * }
   * ```
   */
  async findAndStart(minProfit = 0.005): Promise<ScanResult | null> {
    const results = await this.quickScan(minProfit, 1);

    if (results.length === 0) {
      this.log('No arbitrage opportunities found');
      return null;
    }

    const best = results[0];
    this.log(`Best opportunity: ${best.market.name} (${best.arbType} +${best.profitPercent.toFixed(2)}%)`);

    await this.start(best.market);
    return best;
  }
}

================================================================================
// File: src/services/authorization-service.ts
================================================================================
/**
 * Authorization Service
 *
 * Manages ERC20 and ERC1155 approvals required for trading on Polymarket.
 *
 * Required approvals for trading:
 * - ERC20 (USDC): Approve USDC spending for CTF Exchange, Neg Risk Exchange, etc.
 * - ERC1155 (Conditional Tokens): Approve operators for conditional token transfers
 *
 * @see https://docs.polymarket.com/
 */

import { ethers } from 'ethers';
import {
  CTF_CONTRACT,
  NEG_RISK_CTF_EXCHANGE,
  NEG_RISK_ADAPTER,
  USDC_CONTRACT,
} from '../clients/ctf-client.js';

// Contract addresses
const CTF_EXCHANGE = '0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E';
const CONDITIONAL_TOKENS = CTF_CONTRACT;

// ABIs
const ERC20_ABI = [
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)',
];

const ERC1155_ABI = [
  'function setApprovalForAll(address operator, bool approved) external',
  'function isApprovedForAll(address account, address operator) view returns (bool)',
];

// Types
export interface AllowanceInfo {
  contract: string;
  address: string;
  approved: boolean;
  allowance?: string;
}

export interface AllowancesResult {
  wallet: string;
  usdcBalance: string;
  erc20Allowances: AllowanceInfo[];
  erc1155Approvals: AllowanceInfo[];
  tradingReady: boolean;
  issues: string[];
}

export interface ApprovalTxResult {
  contract: string;
  txHash?: string;
  success: boolean;
  error?: string;
}

export interface ApprovalsResult {
  wallet: string;
  erc20Approvals: ApprovalTxResult[];
  erc1155Approvals: ApprovalTxResult[];
  allApproved: boolean;
  summary: string;
}

export interface AuthorizationServiceConfig {
  provider?: ethers.providers.Provider;
}

// Contracts that need ERC20 approval
const ERC20_SPENDERS = [
  { name: 'CTF Exchange', address: CTF_EXCHANGE },
  { name: 'Neg Risk CTF Exchange', address: NEG_RISK_CTF_EXCHANGE },
  { name: 'Neg Risk Adapter', address: NEG_RISK_ADAPTER },
  { name: 'Conditional Tokens', address: CONDITIONAL_TOKENS },
];

// Operators that need ERC1155 approval
const ERC1155_OPERATORS = [
  { name: 'CTF Exchange', address: CTF_EXCHANGE },
  { name: 'Neg Risk CTF Exchange', address: NEG_RISK_CTF_EXCHANGE },
  { name: 'Neg Risk Adapter', address: NEG_RISK_ADAPTER },
];

/**
 * Service for managing trading authorizations on Polymarket
 *
 * @example
 * ```typescript
 * const authService = new AuthorizationService(signer);
 *
 * // Check all allowances
 * const status = await authService.checkAllowances();
 * console.log(`Trading ready: ${status.tradingReady}`);
 * if (!status.tradingReady) {
 *   console.log('Issues:', status.issues);
 * }
 *
 * // Set up all approvals
 * const result = await authService.approveAll();
 * console.log(result.summary);
 * ```
 */
export class AuthorizationService {
  private signer: ethers.Wallet;
  private provider: ethers.providers.Provider;

  constructor(signer: ethers.Wallet, config: AuthorizationServiceConfig = {}) {
    this.signer = signer;
    this.provider = config.provider || signer.provider || new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
  }

  /**
   * Get the wallet address
   */
  get walletAddress(): string {
    return this.signer.address;
  }

  /**
   * Check all ERC20 and ERC1155 allowances required for trading
   *
   * @returns Status of all allowances and whether trading is ready
   */
  async checkAllowances(): Promise<AllowancesResult> {
    const walletAddress = this.signer.address;

    const usdc = new ethers.Contract(USDC_CONTRACT, ERC20_ABI, this.provider);
    const conditionalTokens = new ethers.Contract(CONDITIONAL_TOKENS, ERC1155_ABI, this.provider);

    // Check USDC balance
    const balance = await usdc.balanceOf(walletAddress);
    const balanceFormatted = ethers.utils.formatUnits(balance, 6);

    // Check ERC20 allowances
    const erc20Allowances: AllowanceInfo[] = [];
    for (const spender of ERC20_SPENDERS) {
      const allowance = await usdc.allowance(walletAddress, spender.address);
      const allowanceNum = parseFloat(ethers.utils.formatUnits(allowance, 6));
      const isUnlimited = allowanceNum > 1e12;

      erc20Allowances.push({
        contract: spender.name,
        address: spender.address,
        approved: isUnlimited,
        allowance: isUnlimited ? 'unlimited' : allowanceNum.toFixed(2),
      });
    }

    // Check ERC1155 approvals
    const erc1155Approvals: AllowanceInfo[] = [];
    for (const operator of ERC1155_OPERATORS) {
      const isApproved = await conditionalTokens.isApprovedForAll(walletAddress, operator.address);

      erc1155Approvals.push({
        contract: operator.name,
        address: operator.address,
        approved: isApproved,
      });
    }

    // Determine issues
    const issues: string[] = [];
    for (const a of erc20Allowances) {
      if (!a.approved) {
        issues.push(`ERC20: ${a.contract} needs USDC approval`);
      }
    }
    for (const a of erc1155Approvals) {
      if (!a.approved) {
        issues.push(`ERC1155: ${a.contract} needs approval for Conditional Tokens`);
      }
    }

    const tradingReady = issues.length === 0;

    return {
      wallet: walletAddress,
      usdcBalance: balanceFormatted,
      erc20Allowances,
      erc1155Approvals,
      tradingReady,
      issues,
    };
  }

  /**
   * Set up all required approvals for trading
   *
   * @returns Results of all approval transactions
   */
  async approveAll(): Promise<ApprovalsResult> {
    const walletAddress = this.signer.address;

    const usdc = new ethers.Contract(USDC_CONTRACT, ERC20_ABI, this.signer);
    const conditionalTokens = new ethers.Contract(CONDITIONAL_TOKENS, ERC1155_ABI, this.signer);

    // Get gas price with buffer
    const gasPrice = await this.provider.getGasPrice();
    const adjustedGasPrice = gasPrice.mul(150).div(100); // 1.5x

    // Process ERC20 approvals
    const erc20Results: ApprovalTxResult[] = [];
    for (const spender of ERC20_SPENDERS) {
      // Check current allowance
      const allowance = await usdc.allowance(walletAddress, spender.address);
      const allowanceNum = parseFloat(ethers.utils.formatUnits(allowance, 6));

      if (allowanceNum > 1e12) {
        // Already approved
        erc20Results.push({
          contract: spender.name,
          success: true,
        });
        continue;
      }

      try {
        const tx = await usdc.approve(spender.address, ethers.constants.MaxUint256, {
          gasPrice: adjustedGasPrice,
        });
        await tx.wait();
        erc20Results.push({
          contract: spender.name,
          txHash: tx.hash,
          success: true,
        });
      } catch (err) {
        erc20Results.push({
          contract: spender.name,
          success: false,
          error: err instanceof Error ? err.message : 'Unknown error',
        });
      }
    }

    // Process ERC1155 approvals
    const erc1155Results: ApprovalTxResult[] = [];
    for (const operator of ERC1155_OPERATORS) {
      // Check current approval
      const isApproved = await conditionalTokens.isApprovedForAll(walletAddress, operator.address);

      if (isApproved) {
        // Already approved
        erc1155Results.push({
          contract: operator.name,
          success: true,
        });
        continue;
      }

      try {
        const tx = await conditionalTokens.setApprovalForAll(operator.address, true, {
          gasPrice: adjustedGasPrice,
          gasLimit: 100000,
        });
        await tx.wait();
        erc1155Results.push({
          contract: operator.name,
          txHash: tx.hash,
          success: true,
        });
      } catch (err) {
        erc1155Results.push({
          contract: operator.name,
          success: false,
          error: err instanceof Error ? err.message : 'Unknown error',
        });
      }
    }

    const allApproved =
      erc20Results.every((r) => r.success) && erc1155Results.every((r) => r.success);

    const newApprovals = [...erc20Results, ...erc1155Results].filter((r) => r.txHash).length;

    return {
      wallet: walletAddress,
      erc20Approvals: erc20Results,
      erc1155Approvals: erc1155Results,
      allApproved,
      summary: allApproved
        ? newApprovals > 0
          ? `All approvals set. ${newApprovals} new approval(s) submitted.`
          : 'All approvals already set. Ready to trade.'
        : 'Some approvals failed. Check the results for details.',
    };
  }

  /**
   * Approve USDC spending for a specific contract
   *
   * @param spenderAddress - The contract address to approve
   * @param amount - The amount to approve (default: unlimited)
   */
  async approveUsdc(
    spenderAddress: string,
    amount: ethers.BigNumber = ethers.constants.MaxUint256
  ): Promise<ApprovalTxResult> {
    const usdc = new ethers.Contract(USDC_CONTRACT, ERC20_ABI, this.signer);
    const gasPrice = await this.provider.getGasPrice();

    try {
      const tx = await usdc.approve(spenderAddress, amount, {
        gasPrice: gasPrice.mul(150).div(100),
      });
      await tx.wait();
      return {
        contract: spenderAddress,
        txHash: tx.hash,
        success: true,
      };
    } catch (err) {
      return {
        contract: spenderAddress,
        success: false,
        error: err instanceof Error ? err.message : 'Unknown error',
      };
    }
  }

  /**
   * Set approval for an ERC1155 operator
   *
   * @param operatorAddress - The operator address to approve
   * @param approved - Whether to approve or revoke
   */
  async setErc1155Approval(
    operatorAddress: string,
    approved: boolean = true
  ): Promise<ApprovalTxResult> {
    const conditionalTokens = new ethers.Contract(CONDITIONAL_TOKENS, ERC1155_ABI, this.signer);
    const gasPrice = await this.provider.getGasPrice();

    try {
      const tx = await conditionalTokens.setApprovalForAll(operatorAddress, approved, {
        gasPrice: gasPrice.mul(150).div(100),
        gasLimit: 100000,
      });
      await tx.wait();
      return {
        contract: operatorAddress,
        txHash: tx.hash,
        success: true,
      };
    } catch (err) {
      return {
        contract: operatorAddress,
        success: false,
        error: err instanceof Error ? err.message : 'Unknown error',
      };
    }
  }
}

================================================================================
// File: src/services/binance-service.ts
================================================================================
/**
 * Binance Service
 *
 * Provides BTC/ETH/SOL K-line data from Binance public API.
 * Used for:
 * - Token vs underlying price correlation analysis
 * - Price prediction for UP/DOWN markets
 * - Backtesting strategies
 *
 * API Reference: https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
 */

import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { CACHE_TTL } from '../core/cache.js';
import { PolymarketError, ErrorCode } from '../core/errors.js';

// ============================================================================
// Types
// ============================================================================

/**
 * Binance K-Line (OHLCV) data
 */
export interface BinanceKLine {
  /** Open time (Unix ms) */
  timestamp: number;
  /** Open price */
  open: number;
  /** High price */
  high: number;
  /** Low price */
  low: number;
  /** Close price */
  close: number;
  /** Base asset volume */
  volume: number;
  /** Close time (Unix ms) */
  closeTime: number;
  /** Quote asset volume */
  quoteVolume: number;
  /** Number of trades */
  trades: number;
}

/**
 * Supported Binance trading pairs
 */
export type BinanceSymbol = 'BTCUSDT' | 'ETHUSDT' | 'SOLUSDT';

/**
 * Supported K-line intervals
 */
export type BinanceInterval = '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '1d';

/**
 * Options for getKLines
 */
export interface BinanceKLineOptions {
  /** Start time (Unix ms) */
  startTime?: number;
  /** End time (Unix ms) */
  endTime?: number;
  /** Number of candles (default 500, max 1000) */
  limit?: number;
}

/**
 * Binance API error response
 */
interface BinanceApiError {
  code: number;
  msg: string;
}

// ============================================================================
// Constants
// ============================================================================

const BINANCE_BASE_URL = 'https://api.binance.com';
const BINANCE_KLINES_ENDPOINT = '/api/v3/klines';
const BINANCE_PRICE_ENDPOINT = '/api/v3/ticker/price';

const DEFAULT_LIMIT = 500;
const MAX_LIMIT = 1000;

// Valid symbols
const VALID_SYMBOLS: Set<BinanceSymbol> = new Set(['BTCUSDT', 'ETHUSDT', 'SOLUSDT']);

// Valid intervals
const VALID_INTERVALS: Set<BinanceInterval> = new Set([
  '1m', '5m', '15m', '30m', '1h', '4h', '1d',
]);

// ============================================================================
// BinanceService Implementation
// ============================================================================

export class BinanceService {
  constructor(
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache
  ) {}

  /**
   * Get K-lines (candlestick data) for a symbol
   *
   * @param symbol - Trading pair (BTCUSDT, ETHUSDT, SOLUSDT)
   * @param interval - K-line interval
   * @param options - Optional parameters
   * @returns Array of K-line candles
   *
   * @example
   * ```typescript
   * const klines = await binanceService.getKLines('BTCUSDT', '1h', { limit: 100 });
   * console.log(`Latest close: ${klines[klines.length - 1].close}`);
   * ```
   */
  async getKLines(
    symbol: BinanceSymbol,
    interval: BinanceInterval,
    options?: BinanceKLineOptions
  ): Promise<BinanceKLine[]> {
    // Validate inputs
    this.validateSymbol(symbol);
    this.validateInterval(interval);

    const limit = Math.min(options?.limit ?? DEFAULT_LIMIT, MAX_LIMIT);

    // Build cache key
    const cacheKey = this.buildKLineCacheKey(symbol, interval, options);

    return this.cache.getOrSet(cacheKey, CACHE_TTL.BINANCE_KLINE, async () => {
      return this.rateLimiter.execute(ApiType.BINANCE, async () => {
        const url = this.buildKLinesUrl(symbol, interval, {
          ...options,
          limit,
        });

        const response = await fetch(url);

        if (!response.ok) {
          await this.handleApiError(response);
        }

        const data = await response.json() as unknown[][];
        return this.parseKLines(data);
      });
    });
  }

  /**
   * Get current price for a symbol
   *
   * @param symbol - Trading pair (BTCUSDT, ETHUSDT, SOLUSDT)
   * @returns Current price
   *
   * @example
   * ```typescript
   * const price = await binanceService.getPrice('BTCUSDT');
   * console.log(`BTC price: $${price}`);
   * ```
   */
  async getPrice(symbol: BinanceSymbol): Promise<number> {
    this.validateSymbol(symbol);

    const cacheKey = `binance:price:${symbol}`;

    return this.cache.getOrSet(cacheKey, CACHE_TTL.BINANCE_PRICE, async () => {
      return this.rateLimiter.execute(ApiType.BINANCE, async () => {
        const url = `${BINANCE_BASE_URL}${BINANCE_PRICE_ENDPOINT}?symbol=${symbol}`;

        const response = await fetch(url);

        if (!response.ok) {
          await this.handleApiError(response);
        }

        const data = await response.json() as { symbol: string; price: string };
        return parseFloat(data.price);
      });
    });
  }

  /**
   * Get price at a specific timestamp (nearest candle close)
   *
   * Uses the 1-minute candle that contains the timestamp and returns
   * the close price of that candle.
   *
   * @param symbol - Trading pair (BTCUSDT, ETHUSDT, SOLUSDT)
   * @param timestamp - Unix timestamp in milliseconds
   * @returns Price at the given timestamp
   *
   * @example
   * ```typescript
   * // Get BTC price 1 hour ago
   * const oneHourAgo = Date.now() - 60 * 60 * 1000;
   * const price = await binanceService.getPriceAt('BTCUSDT', oneHourAgo);
   * ```
   */
  async getPriceAt(symbol: BinanceSymbol, timestamp: number): Promise<number> {
    this.validateSymbol(symbol);

    // Fetch a single 1-minute candle at the specified time
    const klines = await this.getKLines(symbol, '1m', {
      startTime: timestamp,
      limit: 1,
    });

    if (klines.length === 0) {
      throw new PolymarketError(
        ErrorCode.INVALID_RESPONSE,
        `No price data available for ${symbol} at timestamp ${timestamp}`
      );
    }

    return klines[0].close;
  }

  /**
   * Get multiple prices at once
   *
   * @param symbols - Array of trading pairs
   * @returns Map of symbol to price
   */
  async getPrices(symbols: BinanceSymbol[]): Promise<Map<BinanceSymbol, number>> {
    const prices = await Promise.all(
      symbols.map(async (symbol) => {
        const price = await this.getPrice(symbol);
        return [symbol, price] as const;
      })
    );

    return new Map(prices);
  }

  /**
   * Get price change over a time period
   *
   * @param symbol - Trading pair
   * @param startTime - Start time (Unix ms)
   * @param endTime - End time (Unix ms, defaults to now)
   * @returns Price change percentage
   */
  async getPriceChange(
    symbol: BinanceSymbol,
    startTime: number,
    endTime?: number
  ): Promise<{ startPrice: number; endPrice: number; changePercent: number }> {
    const [startKlines, endKlines] = await Promise.all([
      this.getKLines(symbol, '1m', { startTime, limit: 1 }),
      endTime
        ? this.getKLines(symbol, '1m', { startTime: endTime, limit: 1 })
        : Promise.resolve([]),
    ]);

    const startPrice = startKlines[0]?.close;
    if (!startPrice) {
      throw new PolymarketError(
        ErrorCode.INVALID_RESPONSE,
        `No price data for ${symbol} at ${startTime}`
      );
    }

    const endPrice = endKlines[0]?.close ?? (await this.getPrice(symbol));
    const changePercent = ((endPrice - startPrice) / startPrice) * 100;

    return { startPrice, endPrice, changePercent };
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  private validateSymbol(symbol: string): asserts symbol is BinanceSymbol {
    if (!VALID_SYMBOLS.has(symbol as BinanceSymbol)) {
      throw new PolymarketError(
        ErrorCode.INVALID_CONFIG,
        `Invalid symbol: ${symbol}. Supported: ${[...VALID_SYMBOLS].join(', ')}`
      );
    }
  }

  private validateInterval(interval: string): asserts interval is BinanceInterval {
    if (!VALID_INTERVALS.has(interval as BinanceInterval)) {
      throw new PolymarketError(
        ErrorCode.INVALID_CONFIG,
        `Invalid interval: ${interval}. Supported: ${[...VALID_INTERVALS].join(', ')}`
      );
    }
  }

  private buildKLineCacheKey(
    symbol: BinanceSymbol,
    interval: BinanceInterval,
    options?: BinanceKLineOptions
  ): string {
    const parts = ['binance', 'klines', symbol, interval];

    if (options?.startTime) {
      parts.push(`start:${options.startTime}`);
    }
    if (options?.endTime) {
      parts.push(`end:${options.endTime}`);
    }
    if (options?.limit) {
      parts.push(`limit:${options.limit}`);
    }

    return parts.join(':');
  }

  private buildKLinesUrl(
    symbol: BinanceSymbol,
    interval: BinanceInterval,
    options?: BinanceKLineOptions
  ): string {
    const params = new URLSearchParams({
      symbol,
      interval,
    });

    if (options?.startTime) {
      params.set('startTime', options.startTime.toString());
    }
    if (options?.endTime) {
      params.set('endTime', options.endTime.toString());
    }
    if (options?.limit) {
      params.set('limit', options.limit.toString());
    }

    return `${BINANCE_BASE_URL}${BINANCE_KLINES_ENDPOINT}?${params.toString()}`;
  }

  /**
   * Parse Binance K-line array response
   *
   * Binance returns K-lines as arrays:
   * [
   *   [
   *     1499040000000,      // Open time
   *     "0.01634000",       // Open
   *     "0.80000000",       // High
   *     "0.01575800",       // Low
   *     "0.01577100",       // Close
   *     "148976.11427815",  // Volume
   *     1499644799999,      // Close time
   *     "2434.19055334",    // Quote asset volume
   *     308,                // Number of trades
   *     "1756.87402397",    // Taker buy base asset volume
   *     "28.46694368",      // Taker buy quote asset volume
   *     "17928899.62484339" // Ignore
   *   ]
   * ]
   */
  private parseKLines(data: unknown[][]): BinanceKLine[] {
    return data.map((kline) => ({
      timestamp: kline[0] as number,
      open: parseFloat(kline[1] as string),
      high: parseFloat(kline[2] as string),
      low: parseFloat(kline[3] as string),
      close: parseFloat(kline[4] as string),
      volume: parseFloat(kline[5] as string),
      closeTime: kline[6] as number,
      quoteVolume: parseFloat(kline[7] as string),
      trades: kline[8] as number,
    }));
  }

  private async handleApiError(response: Response): Promise<never> {
    let errorBody: BinanceApiError | null = null;

    try {
      errorBody = await response.json() as BinanceApiError;
    } catch {
      // Failed to parse error body
    }

    const message = errorBody?.msg || `Binance API error: HTTP ${response.status}`;

    // Handle rate limiting
    if (response.status === 429 || errorBody?.code === -1015) {
      throw new PolymarketError(
        ErrorCode.RATE_LIMITED,
        message,
        true // retryable
      );
    }

    // Handle invalid symbol/parameters
    if (errorBody?.code === -1121 || errorBody?.code === -1100) {
      throw new PolymarketError(
        ErrorCode.INVALID_CONFIG,
        message,
        false
      );
    }

    // Generic API error
    throw new PolymarketError(
      ErrorCode.API_ERROR,
      message,
      response.status >= 500 // retryable for server errors
    );
  }
}

================================================================================
// File: src/services/dip-arb-service.ts
================================================================================
/**
 * DipArbService - Dip Arbitrage Service
 *
 * 暴跌套利服务 - 针对 Polymarket 15分钟/5分钟 UP/DOWN 市场
 *
 * 策略原理：
 * 1. 每个市场有一个 "price to beat"（开盘时的 Chainlink 价格）
 * 2. 结算规则：
 *    - UP 赢：结束时价格 >= price to beat
 *    - DOWN 赢：结束时价格 < price to beat
 *
 * 3. 套利流程：
 *    - Leg1：检测暴跌 → 买入暴跌侧
 *    - Leg2：等待对冲条件 → 买入另一侧
 *    - 利润：总成本 < $1 时获得无风险利润
 *
 * 使用示例：
 * ```typescript
 * const sdk = await PolymarketSDK.create({ privateKey: '...' });
 *
 * // 自动找到并启动
 * await sdk.dipArb.findAndStart({ coin: 'BTC' });
 *
 * // 监听信号
 * sdk.dipArb.on('signal', (signal) => {
 *   console.log(`Signal: ${signal.type} ${signal.side}`);
 * });
 * ```
 */

import { EventEmitter } from 'events';
import {
  RealtimeServiceV2,
  type MarketSubscription,
  type OrderbookSnapshot,
  type Subscription,
  type CryptoPrice,
} from './realtime-service-v2.js';
import { TradingService, type MarketOrderParams } from './trading-service.js';
import { MarketService } from './market-service.js';
import { CTFClient } from '../clients/ctf-client.js';
import type { Side } from '../core/types.js';
import {
  type DipArbServiceConfig,
  type DipArbConfigInternal,
  type DipArbMarketConfig,
  type DipArbRoundState,
  type DipArbStats,
  type DipArbSignal,
  type DipArbLeg1Signal,
  type DipArbLeg2Signal,
  type DipArbExecutionResult,
  type DipArbRoundResult,
  type DipArbNewRoundEvent,
  type DipArbPriceUpdateEvent,
  type DipArbScanOptions,
  type DipArbFindAndStartOptions,
  type DipArbSide,
  type DipArbAutoRotateConfig,
  type DipArbSettleResult,
  type DipArbRotateEvent,
  type DipArbUnderlying,
  type DipArbPendingRedemption,
  DEFAULT_DIP_ARB_CONFIG,
  DEFAULT_AUTO_ROTATE_CONFIG,
  createDipArbInitialStats,
  createDipArbRoundState,
  calculateDipArbProfitRate,
  estimateUpWinRate,
  detectMispricing,
  parseUnderlyingFromSlug,
  parseDurationFromSlug,
  isDipArbLeg1Signal,
} from './dip-arb-types.js';

// ===== DipArbService =====

export class DipArbService extends EventEmitter {
  // Dependencies
  private realtimeService: RealtimeServiceV2;
  private tradingService: TradingService | null = null;
  private marketService: MarketService;
  private ctf: CTFClient | null = null;

  // Configuration
  private config: DipArbConfigInternal;
  private autoRotateConfig: Required<DipArbAutoRotateConfig>;

  // State
  private market: DipArbMarketConfig | null = null;
  private currentRound: DipArbRoundState | null = null;
  private isRunning = false;
  private isExecuting = false;
  private lastExecutionTime = 0;
  private stats: DipArbStats;

  // Subscriptions
  private marketSubscription: MarketSubscription | null = null;
  private chainlinkSubscription: Subscription | null = null;

  // Auto-rotate state
  private rotateCheckInterval: ReturnType<typeof setInterval> | null = null;
  private nextMarket: DipArbMarketConfig | null = null;

  // Pending redemption state (for background redemption after market resolution)
  private pendingRedemptions: DipArbPendingRedemption[] = [];
  private redeemCheckInterval: ReturnType<typeof setInterval> | null = null;

  // Orderbook state
  private upAsks: Array<{ price: number; size: number }> = [];
  private downAsks: Array<{ price: number; size: number }> = [];

  // Price history for sliding window detection
  // Each entry: { timestamp: number, upAsk: number, downAsk: number }
  private priceHistory: Array<{ timestamp: number; upAsk: number; downAsk: number }> = [];
  private readonly MAX_HISTORY_LENGTH = 100;  // Keep last 100 price points

  // Price state
  private currentUnderlyingPrice = 0;

  // Signal state - prevent duplicate signals within same round
  private leg1SignalEmitted = false;

  // Smart logging state - reduce orderbook noise
  private lastOrderbookLogTime = 0;
  private readonly ORDERBOOK_LOG_INTERVAL_MS = 10000;  // Log orderbook every 10 seconds
  private orderbookBuffer: Array<{ timestamp: number; upAsk: number; downAsk: number; upDepth: number; downDepth: number }> = [];
  private readonly ORDERBOOK_BUFFER_SIZE = 50;  // Keep 5 seconds of data at ~10 updates/sec

  constructor(
    realtimeService: RealtimeServiceV2,
    tradingService: TradingService | null,
    marketService: MarketService,
    privateKey?: string,
    chainId: number = 137
  ) {
    super();

    this.realtimeService = realtimeService;
    this.tradingService = tradingService;
    this.marketService = marketService;

    // Initialize with default config
    this.config = { ...DEFAULT_DIP_ARB_CONFIG };
    this.autoRotateConfig = { ...DEFAULT_AUTO_ROTATE_CONFIG };
    this.stats = createDipArbInitialStats();

    // Initialize CTF if private key provided
    if (privateKey) {
      this.ctf = new CTFClient({
        privateKey,
        rpcUrl: 'https://polygon-rpc.com',
        chainId,
      });
    }
  }

  // ===== Public API: Configuration =====

  /**
   * Update configuration
   */
  updateConfig(config: Partial<DipArbServiceConfig>): void {
    this.config = {
      ...this.config,
      ...config,
    };
    this.log(`Config updated: ${JSON.stringify(config)}`);
  }

  /**
   * Get current configuration
   */
  getConfig(): DipArbConfigInternal {
    return { ...this.config };
  }

  // ===== Public API: Market Discovery =====

  /**
   * Scan for upcoming UP/DOWN markets
   *
   * Uses MarketService.scanCryptoShortTermMarkets()
   */
  async scanUpcomingMarkets(options: DipArbScanOptions = {}): Promise<DipArbMarketConfig[]> {
    const {
      coin = 'all',
      duration = 'all',
      minMinutesUntilEnd = 5,
      maxMinutesUntilEnd = 60,
      limit = 20,
    } = options;

    try {
      const gammaMarkets = await this.marketService.scanCryptoShortTermMarkets({
        coin: coin as 'BTC' | 'ETH' | 'SOL' | 'XRP' | 'all',
        duration: duration as '5m' | '15m' | 'all',
        minMinutesUntilEnd,
        maxMinutesUntilEnd,
        limit,
        sortBy: 'endDate',
      });

      // Get full market info with token IDs for each market
      const results: DipArbMarketConfig[] = [];

      for (const gm of gammaMarkets) {
        // Retry up to 3 times for network errors
        let retries = 3;
        while (retries > 0) {
          try {
            // Get full market info from CLOB API via MarketService
            const market = await this.marketService.getMarket(gm.conditionId);

            // Find UP and DOWN tokens
            const upToken = market.tokens.find(t =>
              t.outcome.toLowerCase() === 'up' || t.outcome.toLowerCase() === 'yes'
            );
            const downToken = market.tokens.find(t =>
              t.outcome.toLowerCase() === 'down' || t.outcome.toLowerCase() === 'no'
            );

            if (upToken?.tokenId && downToken?.tokenId) {
              results.push({
                name: gm.question,
                slug: gm.slug,
                conditionId: gm.conditionId,
                upTokenId: upToken.tokenId,
                downTokenId: downToken.tokenId,
                underlying: parseUnderlyingFromSlug(gm.slug),
                durationMinutes: parseDurationFromSlug(gm.slug),
                endTime: gm.endDate,
              });
            }
            break; // Success, exit retry loop
          } catch (error) {
            retries--;
            if (retries > 0) {
              // Wait 1 second before retry
              await new Promise(r => setTimeout(r, 1000));
            }
          }
        }
      }

      return results;
    } catch (error) {
      this.emit('error', error instanceof Error ? error : new Error(String(error)));
      return [];
    }
  }

  /**
   * Find the best market and start monitoring
   */
  async findAndStart(options: DipArbFindAndStartOptions = {}): Promise<DipArbMarketConfig | null> {
    const { coin, preferDuration = '15m' } = options;

    const scanOptions: DipArbScanOptions = {
      coin: coin || 'all',
      duration: preferDuration,
      minMinutesUntilEnd: 10,
      maxMinutesUntilEnd: 60,
      limit: 10,
    };

    const markets = await this.scanUpcomingMarkets(scanOptions);

    if (markets.length === 0) {
      this.log('No suitable markets found');
      return null;
    }

    // Find the best market (prefer specified coin, then by time)
    let bestMarket = markets[0];
    if (coin) {
      const coinMarket = markets.find(m => m.underlying === coin);
      if (coinMarket) {
        bestMarket = coinMarket;
      }
    }

    await this.start(bestMarket);
    return bestMarket;
  }

  // ===== Public API: Lifecycle =====

  /**
   * Start monitoring a market
   */
  async start(market: DipArbMarketConfig): Promise<void> {
    if (this.isRunning) {
      throw new Error('DipArbService is already running. Call stop() first.');
    }

    // Validate token IDs
    if (!market.upTokenId || !market.downTokenId) {
      throw new Error(`Invalid market config: missing token IDs. upTokenId=${market.upTokenId}, downTokenId=${market.downTokenId}`);
    }

    this.market = market;
    this.isRunning = true;
    this.stats = createDipArbInitialStats();
    this.priceHistory = [];  // Clear price history for new market

    this.log(`Starting Dip Arb monitor for: ${market.name}`);
    this.log(`Condition ID: ${market.conditionId.slice(0, 20)}...`);
    this.log(`Underlying: ${market.underlying}`);
    this.log(`Duration: ${market.durationMinutes}m`);
    this.log(`Auto Execute: ${this.config.autoExecute ? 'YES' : 'NO'}`);

    // Initialize trading service if available
    if (this.tradingService) {
      try {
        await this.tradingService.initialize();
        this.log(`Wallet: ${this.ctf?.getAddress()}`);
      } catch (error) {
        this.log(`Warning: Trading service init failed: ${error}`);
      }
    } else {
      this.log('No wallet configured - monitoring only');
    }

    // Connect realtime service and wait for connection
    this.realtimeService.connect();

    // Wait for WebSocket connection (with timeout)
    await new Promise<void>((resolve) => {
      const timeout = setTimeout(() => {
        this.log('Warning: WebSocket connection timeout, proceeding anyway');
        resolve();
      }, 10000);

      // Check if already connected
      if (this.realtimeService.isConnected?.()) {
        clearTimeout(timeout);
        resolve();
        return;
      }

      this.realtimeService.once('connected', () => {
        clearTimeout(timeout);
        this.log('WebSocket connected');
        resolve();
      });
    });

    // Subscribe to market orderbook
    this.log(`Subscribing to tokens: UP=${market.upTokenId.slice(0, 20)}..., DOWN=${market.downTokenId.slice(0, 20)}...`);
    this.marketSubscription = this.realtimeService.subscribeMarkets(
      [market.upTokenId, market.downTokenId],
      {
        onOrderbook: (book: OrderbookSnapshot) => {
          // Handle the orderbook update (always)
          this.handleOrderbookUpdate(book);

          // Smart logging: only log at intervals, not every update
          if (this.config.debug) {
            this.updateOrderbookBuffer(book);
            this.maybeLogOrderbookSummary();
          }
        },
        onError: (error: Error) => this.emit('error', error),
      }
    );

    // Subscribe to Chainlink prices for the underlying asset
    // Format: ETH -> ETH/USD
    const chainlinkSymbol = `${market.underlying}/USD`;
    console.log(`[DipArb] Subscribing to Chainlink prices: ${chainlinkSymbol}`);
    this.chainlinkSubscription = this.realtimeService.subscribeCryptoChainlinkPrices(
      [chainlinkSymbol],
      {
        onPrice: (price: CryptoPrice) => {
          console.log(`[DipArb] Chainlink price received: ${price.symbol} = $${price.price}`);
          this.handleChainlinkPriceUpdate(price);
        },
      }
    );

    // ✅ FIX: Check and merge existing pairs at startup
    if (this.ctf && this.config.autoMerge) {
      await this.scanAndMergeExistingPairs();
    }

    this.emit('started', market);
    this.log('Monitoring for dip arbitrage opportunities...');
  }

  /**
   * ✅ FIX: Scan and merge existing UP/DOWN pairs at startup
   *
   * When the service starts or rotates to a new market, check if there are
   * existing UP + DOWN token pairs from previous sessions and merge them.
   */
  private async scanAndMergeExistingPairs(): Promise<void> {
    if (!this.ctf || !this.market) return;

    try {
      const tokenIds = {
        yesTokenId: this.market.upTokenId,
        noTokenId: this.market.downTokenId,
      };

      const balances = await this.ctf.getPositionBalanceByTokenIds(
        this.market.conditionId,
        tokenIds
      );

      const upBalance = parseFloat(balances.yesBalance);
      const downBalance = parseFloat(balances.noBalance);

      // Calculate how many pairs can be merged
      const pairsToMerge = Math.min(upBalance, downBalance);

      if (pairsToMerge > 0.01) {  // Minimum 0.01 to avoid dust
        this.log(`🔍 Found existing pairs: UP=${upBalance.toFixed(2)}, DOWN=${downBalance.toFixed(2)}`);
        this.log(`🔄 Auto-merging ${pairsToMerge.toFixed(2)} pairs at startup...`);

        try {
          const result = await this.ctf.mergeByTokenIds(
            this.market.conditionId,
            tokenIds,
            pairsToMerge.toString()
          );

          if (result.success) {
            this.log(`✅ Startup merge successful: ${pairsToMerge.toFixed(2)} pairs → $${result.usdcReceived || pairsToMerge.toFixed(2)} USDC.e`);
            this.log(`   TxHash: ${result.txHash?.slice(0, 20)}...`);
          } else {
            this.log(`❌ Startup merge failed`);
          }
        } catch (mergeError) {
          this.log(`❌ Startup merge error: ${mergeError instanceof Error ? mergeError.message : String(mergeError)}`);
        }
      } else if (upBalance > 0 || downBalance > 0) {
        // Has tokens but not enough pairs to merge
        this.log(`📊 Existing positions: UP=${upBalance.toFixed(2)}, DOWN=${downBalance.toFixed(2)} (no pairs to merge)`);
      }
    } catch (error) {
      this.log(`Warning: Failed to scan existing pairs: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Stop monitoring
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;

    this.isRunning = false;

    // Stop rotate check
    this.stopRotateCheck();

    // Unsubscribe
    if (this.marketSubscription) {
      this.marketSubscription.unsubscribe();
      this.marketSubscription = null;
    }

    if (this.chainlinkSubscription) {
      this.chainlinkSubscription.unsubscribe();
      this.chainlinkSubscription = null;
    }

    // Update stats
    this.stats.runningTimeMs = Date.now() - this.stats.startTime;

    this.log('Stopped');
    this.log(`Rounds monitored: ${this.stats.roundsMonitored}`);
    this.log(`Rounds completed: ${this.stats.roundsSuccessful}`);
    this.log(`Total profit: $${this.stats.totalProfit.toFixed(2)}`);

    this.emit('stopped');
  }

  /**
   * Check if service is running
   */
  isActive(): boolean {
    return this.isRunning;
  }

  /**
   * Get current market
   */
  getMarket(): DipArbMarketConfig | null {
    return this.market;
  }

  // ===== Public API: State Access =====

  /**
   * Get statistics
   */
  getStats(): DipArbStats {
    return {
      ...this.stats,
      runningTimeMs: this.isRunning ? Date.now() - this.stats.startTime : this.stats.runningTimeMs,
      currentRound: this.currentRound ? {
        roundId: this.currentRound.roundId,
        phase: this.currentRound.phase,
        priceToBeat: this.currentRound.priceToBeat,
        leg1: this.currentRound.leg1 ? {
          side: this.currentRound.leg1.side,
          price: this.currentRound.leg1.price,
        } : undefined,
      } : undefined,
    };
  }

  /**
   * Get current round state
   */
  getCurrentRound(): DipArbRoundState | null {
    return this.currentRound ? { ...this.currentRound } : null;
  }

  /**
   * Get current price to beat
   */
  getPriceToBeat(): number | null {
    return this.currentRound?.priceToBeat ?? null;
  }

  // ===== Public API: Manual Execution =====

  /**
   * Execute Leg1 trade
   */
  async executeLeg1(signal: DipArbLeg1Signal): Promise<DipArbExecutionResult> {
    const startTime = Date.now();

    if (!this.tradingService || !this.market || !this.currentRound) {
      this.isExecuting = false;  // Reset in case handleSignal() set it
      return {
        success: false,
        leg: 'leg1',
        roundId: signal.roundId,
        error: 'Trading service not available or no active round',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      this.isExecuting = true;  // Also set here for manual mode (when not called from handleSignal)

      // 计算拆分订单参数
      const splitCount = Math.max(1, this.config.splitOrders);

      // 机制保证：确保满足 $1 最低限额
      const minSharesForMinAmount = Math.ceil(1 / signal.targetPrice);
      const adjustedShares = Math.max(signal.shares, minSharesForMinAmount);

      if (adjustedShares > signal.shares) {
        this.log(`📊 Shares adjusted: ${signal.shares} → ${adjustedShares} (to meet $1 minimum at price ${signal.targetPrice.toFixed(4)})`);
      }

      const sharesPerOrder = adjustedShares / splitCount;
      const amountPerOrder = sharesPerOrder * signal.targetPrice;

      let totalSharesFilled = 0;
      let totalAmountSpent = 0;
      let lastOrderId: string | undefined;
      let failedOrders = 0;

      // 执行多笔订单
      for (let i = 0; i < splitCount; i++) {
        const orderParams: MarketOrderParams = {
          tokenId: signal.tokenId,
          side: 'BUY' as Side,
          amount: amountPerOrder,
        };

        if (this.config.debug && splitCount > 1) {
          this.log(`Leg1 order ${i + 1}/${splitCount}: ${sharesPerOrder.toFixed(2)} shares @ ${signal.targetPrice.toFixed(4)}`);
        }

        const result = await this.tradingService.createMarketOrder(orderParams);

        if (result.success) {
          totalSharesFilled += sharesPerOrder;
          totalAmountSpent += amountPerOrder;
          lastOrderId = result.orderId;
        } else {
          failedOrders++;
          this.log(`Leg1 order ${i + 1}/${splitCount} failed: ${result.errorMsg}`);
        }

        // 订单间隔
        if (i < splitCount - 1 && this.config.orderIntervalMs > 0) {
          await new Promise(resolve => setTimeout(resolve, this.config.orderIntervalMs));
        }
      }

      // 至少有一笔成功
      if (totalSharesFilled > 0) {
        const avgPrice = totalAmountSpent / totalSharesFilled;

        // Record leg1 fill
        this.currentRound.leg1 = {
          side: signal.dipSide,
          price: avgPrice,
          shares: totalSharesFilled,
          timestamp: Date.now(),
          tokenId: signal.tokenId,
        };
        this.currentRound.phase = 'leg1_filled';
        this.stats.leg1Filled++;

        this.lastExecutionTime = Date.now();

        // Detailed execution logging
        const slippage = ((avgPrice - signal.currentPrice) / signal.currentPrice * 100);
        const execTimeMs = Date.now() - startTime;

        this.log(`✅ Leg1 FILLED: ${signal.dipSide} x${totalSharesFilled.toFixed(1)} @ ${avgPrice.toFixed(4)}`);
        this.log(`   Expected: ${signal.currentPrice.toFixed(4)} | Actual: ${avgPrice.toFixed(4)} | Slippage: ${slippage >= 0 ? '+' : ''}${slippage.toFixed(2)}%`);
        this.log(`   Execution time: ${execTimeMs}ms | Orders: ${splitCount - failedOrders}/${splitCount}`);

        // Log orderbook after execution
        if (this.config.debug) {
          this.logOrderbookContext('Post-Leg1');
        }

        return {
          success: true,
          leg: 'leg1',
          roundId: signal.roundId,
          side: signal.dipSide,
          price: avgPrice,
          shares: totalSharesFilled,
          orderId: lastOrderId,
          executionTimeMs: execTimeMs,
        };
      } else {
        return {
          success: false,
          leg: 'leg1',
          roundId: signal.roundId,
          error: 'All orders failed',
          executionTimeMs: Date.now() - startTime,
        };
      }
    } catch (error) {
      return {
        success: false,
        leg: 'leg1',
        roundId: signal.roundId,
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    } finally {
      this.isExecuting = false;
    }
  }

  /**
   * Execute Leg2 trade
   */
  async executeLeg2(signal: DipArbLeg2Signal): Promise<DipArbExecutionResult> {
    const startTime = Date.now();

    if (!this.tradingService || !this.market || !this.currentRound) {
      this.isExecuting = false;  // Reset in case handleSignal() set it
      return {
        success: false,
        leg: 'leg2',
        roundId: signal.roundId,
        error: 'Trading service not available or no active round',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      this.isExecuting = true;  // Also set here for manual mode (when not called from handleSignal)

      // 计算拆分订单参数
      const splitCount = Math.max(1, this.config.splitOrders);

      // 机制保证：确保满足 $1 最低限额
      const minSharesForMinAmount = Math.ceil(1 / signal.targetPrice);
      const adjustedShares = Math.max(signal.shares, minSharesForMinAmount);

      if (adjustedShares > signal.shares) {
        this.log(`📊 Leg2 Shares adjusted: ${signal.shares} → ${adjustedShares} (to meet $1 minimum at price ${signal.targetPrice.toFixed(4)})`);
      }

      const sharesPerOrder = adjustedShares / splitCount;
      const amountPerOrder = sharesPerOrder * signal.targetPrice;

      let totalSharesFilled = 0;
      let totalAmountSpent = 0;
      let lastOrderId: string | undefined;
      let failedOrders = 0;

      // 执行多笔订单
      for (let i = 0; i < splitCount; i++) {
        const orderParams: MarketOrderParams = {
          tokenId: signal.tokenId,
          side: 'BUY' as Side,
          amount: amountPerOrder,
        };

        if (this.config.debug && splitCount > 1) {
          this.log(`Leg2 order ${i + 1}/${splitCount}: ${sharesPerOrder.toFixed(2)} shares @ ${signal.targetPrice.toFixed(4)}`);
        }

        const result = await this.tradingService.createMarketOrder(orderParams);

        if (result.success) {
          totalSharesFilled += sharesPerOrder;
          totalAmountSpent += amountPerOrder;
          lastOrderId = result.orderId;
        } else {
          failedOrders++;
          this.log(`Leg2 order ${i + 1}/${splitCount} failed: ${result.errorMsg}`);
        }

        // 订单间隔
        if (i < splitCount - 1 && this.config.orderIntervalMs > 0) {
          await new Promise(resolve => setTimeout(resolve, this.config.orderIntervalMs));
        }
      }

      // 至少有一笔成功
      if (totalSharesFilled > 0) {
        const avgPrice = totalAmountSpent / totalSharesFilled;
        const leg1Price = this.currentRound.leg1?.price || 0;
        const actualTotalCost = leg1Price + avgPrice;

        // Record leg2 fill
        this.currentRound.leg2 = {
          side: signal.hedgeSide,
          price: avgPrice,
          shares: totalSharesFilled,
          timestamp: Date.now(),
          tokenId: signal.tokenId,
        };
        this.currentRound.phase = 'completed';
        this.currentRound.totalCost = actualTotalCost;
        this.currentRound.profit = 1 - actualTotalCost;

        this.stats.leg2Filled++;
        this.stats.roundsSuccessful++;
        this.stats.totalProfit += this.currentRound.profit * totalSharesFilled;
        this.stats.totalSpent += actualTotalCost * totalSharesFilled;

        this.lastExecutionTime = Date.now();

        // Detailed execution logging
        const slippage = ((avgPrice - signal.currentPrice) / signal.currentPrice * 100);
        const execTimeMs = Date.now() - startTime;
        const profitPerShare = this.currentRound.profit;
        const totalProfit = profitPerShare * totalSharesFilled;

        this.log(`✅ Leg2 FILLED: ${signal.hedgeSide} x${totalSharesFilled.toFixed(1)} @ ${avgPrice.toFixed(4)}`);
        this.log(`   Expected: ${signal.currentPrice.toFixed(4)} | Actual: ${avgPrice.toFixed(4)} | Slippage: ${slippage >= 0 ? '+' : ''}${slippage.toFixed(2)}%`);
        this.log(`   Leg1: ${leg1Price.toFixed(4)} + Leg2: ${avgPrice.toFixed(4)} = ${actualTotalCost.toFixed(4)}`);
        this.log(`   💰 Profit: $${totalProfit.toFixed(2)} (${(profitPerShare * 100).toFixed(2)}% per share)`);
        this.log(`   Execution time: ${execTimeMs}ms | Orders: ${splitCount - failedOrders}/${splitCount}`);

        // Log orderbook after execution
        if (this.config.debug) {
          this.logOrderbookContext('Post-Leg2');
        }

        const roundResult: DipArbRoundResult = {
          roundId: signal.roundId,
          status: 'completed',
          leg1: this.currentRound.leg1,
          leg2: this.currentRound.leg2,
          totalCost: this.currentRound.totalCost,
          profit: this.currentRound.profit,
          profitRate: calculateDipArbProfitRate(this.currentRound.totalCost),
          merged: false,
        };

        this.emit('roundComplete', roundResult);

        // Auto merge if enabled
        if (this.config.autoMerge) {
          const mergeResult = await this.merge();
          roundResult.merged = mergeResult.success;
          roundResult.mergeTxHash = mergeResult.txHash;
        }

        return {
          success: true,
          leg: 'leg2',
          roundId: signal.roundId,
          side: signal.hedgeSide,
          price: avgPrice,
          shares: totalSharesFilled,
          orderId: lastOrderId,
          executionTimeMs: Date.now() - startTime,
        };
      } else {
        return {
          success: false,
          leg: 'leg2',
          roundId: signal.roundId,
          error: 'All orders failed',
          executionTimeMs: Date.now() - startTime,
        };
      }
    } catch (error) {
      return {
        success: false,
        leg: 'leg2',
        roundId: signal.roundId,
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    } finally {
      this.isExecuting = false;
    }
  }

  /**
   * Merge UP + DOWN tokens to USDC.e
   *
   * Uses mergeByTokenIds with Polymarket token IDs for correct CLOB market handling.
   * This locks in profit immediately after Leg2 completes.
   */
  async merge(): Promise<DipArbExecutionResult> {
    const startTime = Date.now();
    const roundId = this.currentRound?.roundId || 'unknown';

    if (!this.ctf || !this.market || !this.currentRound) {
      return {
        success: false,
        leg: 'merge',
        roundId,
        error: 'CTF client not available or no completed round',
        executionTimeMs: Date.now() - startTime,
      };
    }

    // Merge the minimum of Leg1 and Leg2 shares (should be equal after our fix)
    const shares = Math.min(
      this.currentRound.leg1?.shares || 0,
      this.currentRound.leg2?.shares || 0
    );

    if (shares <= 0) {
      return {
        success: false,
        leg: 'merge',
        roundId,
        error: 'No shares to merge',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      // Use mergeByTokenIds with Polymarket token IDs
      const tokenIds = {
        yesTokenId: this.market.upTokenId,
        noTokenId: this.market.downTokenId,
      };

      this.log(`🔄 Merging ${shares.toFixed(1)} UP + DOWN → USDC.e...`);

      const result = await this.ctf.mergeByTokenIds(
        this.market.conditionId,
        tokenIds,
        shares.toString()
      );

      if (result.success) {
        this.log(`✅ Merge successful: ${shares.toFixed(1)} pairs → $${result.usdcReceived || shares.toFixed(2)} USDC.e`);
        this.log(`   TxHash: ${result.txHash?.slice(0, 20)}...`);
      }

      return {
        success: result.success,
        leg: 'merge',
        roundId,
        shares,
        txHash: result.txHash,
        executionTimeMs: Date.now() - startTime,
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.log(`❌ Merge failed: ${errorMsg}`);
      return {
        success: false,
        leg: 'merge',
        roundId,
        error: errorMsg,
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  // ===== Private: Event Handlers =====

  private handleOrderbookUpdate(book: OrderbookSnapshot): void {
    if (!this.market) return;

    // Determine which side this update is for
    const tokenId = book.tokenId;
    const isUpToken = tokenId === this.market.upTokenId;
    const isDownToken = tokenId === this.market.downTokenId;

    // OrderbookLevel has price and size as numbers
    if (isUpToken) {
      this.upAsks = book.asks.map(l => ({ price: l.price, size: l.size }));
    } else if (isDownToken) {
      this.downAsks = book.asks.map(l => ({ price: l.price, size: l.size }));
    }

    // Record price history for sliding window detection
    this.recordPriceHistory();

    // Check if we need to start a new round (async but fire-and-forget to not block orderbook updates)
    this.checkAndStartNewRound().catch(err => {
      this.emit('error', err instanceof Error ? err : new Error(String(err)));
    });

    // Skip signal detection entirely if already executing (prevents duplicate detection logs)
    if (this.isExecuting) {
      return;
    }

    // Detect signals
    const signal = this.detectSignal();
    if (signal) {
      this.handleSignal(signal);
    }
  }

  /**
   * Record current prices to history buffer for sliding window detection
   */
  private recordPriceHistory(): void {
    const upAsk = this.upAsks[0]?.price ?? 0;
    const downAsk = this.downAsks[0]?.price ?? 0;

    // Only record if we have valid prices
    if (upAsk <= 0 || downAsk <= 0) return;

    this.priceHistory.push({
      timestamp: Date.now(),
      upAsk,
      downAsk,
    });

    // Trim history to max length
    if (this.priceHistory.length > this.MAX_HISTORY_LENGTH) {
      this.priceHistory = this.priceHistory.slice(-this.MAX_HISTORY_LENGTH);
    }
  }

  /**
   * Get price from N milliseconds ago for sliding window detection
   *
   * @param side - 'UP' or 'DOWN'
   * @param msAgo - Milliseconds ago (e.g., 3000 for 3 seconds)
   * @returns Price from that time, or null if not available
   */
  private getPriceFromHistory(side: 'UP' | 'DOWN', msAgo: number): number | null {
    const targetTime = Date.now() - msAgo;

    // Find the closest price point at or before targetTime
    for (let i = this.priceHistory.length - 1; i >= 0; i--) {
      const entry = this.priceHistory[i];
      if (entry.timestamp <= targetTime) {
        return side === 'UP' ? entry.upAsk : entry.downAsk;
      }
    }

    return null;
  }

  private handleChainlinkPriceUpdate(price: CryptoPrice): void {
    if (!this.market) return;

    // Only handle updates for our underlying (symbol format: ETH/USD)
    const expectedSymbol = `${this.market.underlying}/USD`;
    if (price.symbol !== expectedSymbol) return;

    if (this.config.debug) {
      this.log(`Chainlink price update: ${price.symbol} = $${price.price.toFixed(2)}`);
    }

    this.currentUnderlyingPrice = price.price;

    // Emit price update event
    if (this.currentRound) {
      const event: DipArbPriceUpdateEvent = {
        underlying: this.market.underlying,
        value: price.price,
        priceToBeat: this.currentRound.priceToBeat,
        changePercent: this.currentRound.priceToBeat > 0
          ? ((price.price - this.currentRound.priceToBeat) / this.currentRound.priceToBeat) * 100
          : 0,
      };
      this.emit('priceUpdate', event);
    }
  }

  // ===== Private: Round Management =====

  private async checkAndStartNewRound(): Promise<void> {
    if (!this.market) return;

    // If no current round or current round is completed/expired, start new round
    if (!this.currentRound || this.currentRound.phase === 'completed' || this.currentRound.phase === 'expired') {
      // Check if market is still active
      if (new Date() >= this.market.endTime) {
        // Always log market end (not just in debug mode)
        if (!this.currentRound) {
          console.log('[DipArb] Market has ended before round could start');
        }
        return;
      }

      // Get current prices
      const upPrice = this.upAsks[0]?.price ?? 0.5;
      const downPrice = this.downAsks[0]?.price ?? 0.5;

      // Use current underlying price as price to beat (or fallback to 0)
      const priceToBeat = this.currentUnderlyingPrice || 0;

      // Create new round
      const roundId = `${this.market.slug}-${Date.now()}`;
      this.currentRound = createDipArbRoundState(
        roundId,
        priceToBeat,
        upPrice,
        downPrice,
        this.market.durationMinutes
      );

      // Clear price history for new round - we only want to detect instant drops within this round
      this.priceHistory = [];

      // Reset signal state for new round
      this.leg1SignalEmitted = false;

      this.stats.roundsMonitored++;

      const event: DipArbNewRoundEvent = {
        roundId,
        priceToBeat,
        upOpen: upPrice,
        downOpen: downPrice,
        startTime: this.currentRound.startTime,
        endTime: this.currentRound.endTime,
      };

      this.emit('newRound', event);
      this.log(`New round: ${roundId}, Price to Beat: ${priceToBeat.toFixed(2)}`);
    }

    // Check for round expiration - exit Leg1 if Leg2 times out
    if (this.currentRound && this.currentRound.phase === 'leg1_filled') {
      const elapsed = (Date.now() - (this.currentRound.leg1?.timestamp || this.currentRound.startTime)) / 1000;
      if (elapsed > this.config.leg2TimeoutSeconds) {
        // ✅ FIX: Exit Leg1 position to avoid unhedged exposure
        this.log(`⚠️ Leg2 timeout (${elapsed.toFixed(0)}s > ${this.config.leg2TimeoutSeconds}s), exiting Leg1 position...`);

        // Try to sell Leg1 position
        const exitResult = await this.emergencyExitLeg1();

        this.currentRound.phase = 'expired';
        this.stats.roundsExpired++;
        this.stats.roundsCompleted++;

        const result: DipArbRoundResult = {
          roundId: this.currentRound.roundId,
          status: 'expired',
          leg1: this.currentRound.leg1,
          merged: false,
          exitResult,  // Include exit result for tracking
        };

        this.emit('roundComplete', result);
        this.log(`Round expired: ${this.currentRound.roundId} | Exit: ${exitResult?.success ? 'SUCCESS' : 'FAILED'}`);
      }
    }
  }

  /**
   * Emergency exit Leg1 position when Leg2 times out
   * Sells the Leg1 tokens at market price to avoid unhedged exposure
   */
  private async emergencyExitLeg1(): Promise<DipArbExecutionResult | null> {
    if (!this.tradingService || !this.market || !this.currentRound?.leg1) {
      this.log('Cannot exit Leg1: no trading service or position');
      return null;
    }

    const leg1 = this.currentRound.leg1;
    const startTime = Date.now();

    try {
      this.log(`Selling ${leg1.shares} ${leg1.side} tokens...`);

      // Get current price for the token
      const currentPrice = leg1.side === 'UP'
        ? (this.upAsks[0]?.price ?? 0.5)
        : (this.downAsks[0]?.price ?? 0.5);

      const exitAmount = leg1.shares * currentPrice;

      // 检查退出金额是否满足最低限额
      if (exitAmount < 1) {
        this.log(`⚠️ Exit amount ($${exitAmount.toFixed(2)}) below $1 minimum - position will be held to expiry`);
        return {
          success: false,
          leg: 'exit',
          roundId: this.currentRound.roundId,
          error: `Exit amount ($${exitAmount.toFixed(2)}) below Polymarket minimum ($1) - holding to expiry`,
          executionTimeMs: Date.now() - startTime,
        };
      }

      // Market sell the position
      const result = await this.tradingService.createMarketOrder({
        tokenId: leg1.tokenId,
        side: 'SELL' as Side,
        amount: exitAmount,
      });

      if (result.success) {
        const soldPrice = currentPrice;  // Approximate
        const loss = (leg1.price - soldPrice) * leg1.shares;

        this.log(`✅ Leg1 exit successful: sold ${leg1.shares}x ${leg1.side} @ ~${soldPrice.toFixed(4)} | Loss: $${loss.toFixed(2)}`);

        // Update stats with the loss
        this.stats.totalProfit -= Math.abs(loss);

        return {
          success: true,
          leg: 'exit',
          roundId: this.currentRound.roundId,
          side: leg1.side,
          price: soldPrice,
          shares: leg1.shares,
          orderId: result.orderId,
          executionTimeMs: Date.now() - startTime,
        };
      } else {
        this.log(`❌ Leg1 exit failed: ${result.errorMsg}`);
        return {
          success: false,
          leg: 'exit',
          roundId: this.currentRound.roundId,
          error: result.errorMsg,
          executionTimeMs: Date.now() - startTime,
        };
      }
    } catch (error) {
      this.log(`❌ Leg1 exit error: ${error instanceof Error ? error.message : String(error)}`);
      return {
        success: false,
        leg: 'exit',
        roundId: this.currentRound.roundId,
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  // ===== Private: Signal Detection =====

  private detectSignal(): DipArbSignal | null {
    if (!this.currentRound || !this.market) return null;

    // Check based on current phase
    if (this.currentRound.phase === 'waiting') {
      return this.detectLeg1Signal();
    } else if (this.currentRound.phase === 'leg1_filled') {
      return this.detectLeg2Signal();
    }

    return null;
  }

  private detectLeg1Signal(): DipArbLeg1Signal | null {
    if (!this.currentRound || !this.market) return null;

    // Check if within trading window (轮次开始后的交易窗口)
    const elapsed = (Date.now() - this.currentRound.startTime) / 60000;
    if (elapsed > this.config.windowMinutes) {
      return null;
    }

    const upPrice = this.upAsks[0]?.price ?? 1;
    const downPrice = this.downAsks[0]?.price ?? 1;
    const { openPrices } = this.currentRound;

    // Skip if no valid prices
    if (upPrice >= 1 || downPrice >= 1 || openPrices.up <= 0 || openPrices.down <= 0) {
      return null;
    }

    // ========================================
    // Pattern 1: Instant Dip Detection (核心策略)
    // ========================================
    // 检测 slidingWindowMs (默认 3 秒) 内的瞬时暴跌
    // 这是策略的核心！我们捕捉的是"情绪性暴跌"，不是趋势

    const upPriceAgo = this.getPriceFromHistory('UP', this.config.slidingWindowMs);
    const downPriceAgo = this.getPriceFromHistory('DOWN', this.config.slidingWindowMs);

    // UP instant dip: 3秒内暴跌 >= dipThreshold
    if (upPriceAgo !== null && upPriceAgo > 0) {
      const upInstantDrop = (upPriceAgo - upPrice) / upPriceAgo;
      if (upInstantDrop >= this.config.dipThreshold) {
        if (this.config.debug) {
          this.log(`⚡ Instant DIP detected! UP: ${upPriceAgo.toFixed(4)} → ${upPrice.toFixed(4)} = -${(upInstantDrop * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
        }
        const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'dip', upInstantDrop, upPriceAgo);
        if (signal && this.validateSignalProfitability(signal)) {
          return signal;
        }
      }
    }

    // DOWN instant dip: 3秒内暴跌 >= dipThreshold
    if (downPriceAgo !== null && downPriceAgo > 0) {
      const downInstantDrop = (downPriceAgo - downPrice) / downPriceAgo;
      if (downInstantDrop >= this.config.dipThreshold) {
        if (this.config.debug) {
          this.log(`⚡ Instant DIP detected! DOWN: ${downPriceAgo.toFixed(4)} → ${downPrice.toFixed(4)} = -${(downInstantDrop * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
        }
        const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'dip', downInstantDrop, downPriceAgo);
        if (signal && this.validateSignalProfitability(signal)) {
          return signal;
        }
      }
    }

    // ========================================
    // Pattern 2: Surge Detection (if enabled)
    // ========================================
    // 暴涨检测：当 token 价格暴涨时，买入对手 token
    if (this.config.enableSurge && upPriceAgo !== null && downPriceAgo !== null) {
      // UP surged in sliding window, buy DOWN
      if (upPriceAgo > 0) {
        const upSurge = (upPrice - upPriceAgo) / upPriceAgo;
        if (upSurge >= this.config.surgeThreshold) {
          if (this.config.debug) {
            this.log(`⚡ Instant SURGE detected! UP: ${upPriceAgo.toFixed(4)} → ${upPrice.toFixed(4)} = +${(upSurge * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
          }
          // 买入 DOWN，参考价格是 DOWN 的历史价格
          const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'surge', upSurge, downPriceAgo);
          if (signal && this.validateSignalProfitability(signal)) {
            return signal;
          }
        }
      }

      // DOWN surged in sliding window, buy UP
      if (downPriceAgo > 0) {
        const downSurge = (downPrice - downPriceAgo) / downPriceAgo;
        if (downSurge >= this.config.surgeThreshold) {
          if (this.config.debug) {
            this.log(`⚡ Instant SURGE detected! DOWN: ${downPriceAgo.toFixed(4)} → ${downPrice.toFixed(4)} = +${(downSurge * 100).toFixed(1)}% in ${this.config.slidingWindowMs}ms`);
          }
          // 买入 UP，参考价格是 UP 的历史价格
          const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'surge', downSurge, upPriceAgo);
          if (signal && this.validateSignalProfitability(signal)) {
            return signal;
          }
        }
      }
    }

    // ========================================
    // Pattern 3: Mispricing Detection
    // ========================================
    // 定价偏差：基于底层资产价格估计胜率，检测错误定价
    if (this.currentRound.priceToBeat > 0 && this.currentUnderlyingPrice > 0) {
      const estimatedWinRate = estimateUpWinRate(this.currentUnderlyingPrice, this.currentRound.priceToBeat);
      const upMispricing = detectMispricing(upPrice, estimatedWinRate);
      const downMispricing = detectMispricing(downPrice, 1 - estimatedWinRate);

      // UP is underpriced
      if (upMispricing >= this.config.dipThreshold) {
        const signal = this.createLeg1Signal('UP', upPrice, downPrice, 'mispricing', upMispricing);
        if (signal && this.validateSignalProfitability(signal)) {
          return signal;
        }
      }

      // DOWN is underpriced
      if (downMispricing >= this.config.dipThreshold) {
        const signal = this.createLeg1Signal('DOWN', downPrice, upPrice, 'mispricing', downMispricing);
        if (signal && this.validateSignalProfitability(signal)) {
          return signal;
        }
      }
    }

    return null;
  }

  private createLeg1Signal(
    side: DipArbSide,
    price: number,
    oppositeAsk: number,
    source: 'dip' | 'surge' | 'mispricing',
    dropPercent: number,
    referencePrice?: number  // 用于 dip/surge: 滑动窗口前的价格
  ): DipArbLeg1Signal | null {
    if (!this.currentRound || !this.market) return null;

    const targetPrice = price * (1 + this.config.maxSlippage);
    const estimatedTotalCost = targetPrice + oppositeAsk;
    const estimatedProfitRate = calculateDipArbProfitRate(estimatedTotalCost);

    // openPrice: 对于 dip/surge 信号，使用滑动窗口参考价格；否则使用轮次开盘价
    const openPrice = referencePrice ??
      (side === 'UP' ? this.currentRound.openPrices.up : this.currentRound.openPrices.down);

    const signal: DipArbLeg1Signal = {
      type: 'leg1',
      roundId: this.currentRound.roundId,
      dipSide: side,
      currentPrice: price,
      openPrice,  // 参考价格（3秒前的价格或轮次开盘价）
      dropPercent,
      targetPrice,
      shares: this.config.shares,
      tokenId: side === 'UP' ? this.market.upTokenId : this.market.downTokenId,
      oppositeAsk,
      estimatedTotalCost,
      estimatedProfitRate,
      source,
    };

    // Add BTC info if available
    if (this.currentRound.priceToBeat > 0 && this.currentUnderlyingPrice > 0) {
      const btcChangePercent = ((this.currentUnderlyingPrice - this.currentRound.priceToBeat) / this.currentRound.priceToBeat) * 100;
      signal.btcInfo = {
        btcPrice: this.currentUnderlyingPrice,
        priceToBeat: this.currentRound.priceToBeat,
        btcChangePercent,
        estimatedWinRate: estimateUpWinRate(this.currentUnderlyingPrice, this.currentRound.priceToBeat),
      };
    }

    return signal;
  }

  private detectLeg2Signal(): DipArbLeg2Signal | null {
    if (!this.currentRound || !this.market || !this.currentRound.leg1) return null;

    const leg1 = this.currentRound.leg1;
    const hedgeSide: DipArbSide = leg1.side === 'UP' ? 'DOWN' : 'UP';
    const currentPrice = hedgeSide === 'UP' ? (this.upAsks[0]?.price ?? 1) : (this.downAsks[0]?.price ?? 1);

    if (currentPrice >= 1) return null;

    const targetPrice = currentPrice * (1 + this.config.maxSlippage);
    const totalCost = leg1.price + targetPrice;

    // Check if profitable - 只用 sumTarget 控制
    if (totalCost > this.config.sumTarget) {
      // 每 5 秒输出一次等待日志，避免刷屏
      if (this.config.debug && Date.now() % 5000 < 100) {
        const profitRate = calculateDipArbProfitRate(totalCost);
        this.log(`⏳ Waiting Leg2: ${hedgeSide} @ ${currentPrice.toFixed(4)}, cost ${totalCost.toFixed(4)} > ${this.config.sumTarget}, profit ${(profitRate * 100).toFixed(1)}%`);
      }
      return null;
    }

    const expectedProfitRate = calculateDipArbProfitRate(totalCost);

    if (this.config.debug) {
      this.log(`✅ Leg2 signal found! ${hedgeSide} @ ${currentPrice.toFixed(4)}, totalCost ${totalCost.toFixed(4)}, profit ${(expectedProfitRate * 100).toFixed(2)}%`);
    }

    // ✅ FIX: Use leg1.shares instead of config.shares to ensure balanced hedge
    // This is critical - Leg2 must buy exactly the same shares as Leg1 to create a perfect hedge
    return {
      type: 'leg2',
      roundId: this.currentRound.roundId,
      hedgeSide,
      leg1,
      currentPrice,
      targetPrice,
      totalCost,
      expectedProfitRate,
      shares: leg1.shares,  // Must match Leg1 to ensure balanced hedge
      tokenId: hedgeSide === 'UP' ? this.market.upTokenId : this.market.downTokenId,
    };
  }

  private validateSignalProfitability(signal: DipArbLeg1Signal): boolean {
    // Leg1 验证：只检查跌幅是否足够大
    // 不在 Leg1 阶段检查 sumTarget，因为：
    // 1. Leg1 的目的是抄底，买入暴跌的一侧
    // 2. Leg2 会等待对侧价格下降后再买入
    // 3. sumTarget 应该在 Leg2 阶段检查

    // 只做基本验证：确保价格合理
    if (signal.currentPrice <= 0 || signal.currentPrice >= 1) {
      if (this.config.debug) {
        this.log(`❌ Signal rejected: invalid price ${signal.currentPrice.toFixed(4)}`);
      }
      return false;
    }

    // 确保跌幅达到阈值（这个已经在 detectLeg1Signal 中检查过，这里再确认一下）
    if (signal.dropPercent < this.config.dipThreshold) {
      if (this.config.debug) {
        this.log(`❌ Signal rejected: drop ${(signal.dropPercent * 100).toFixed(1)}% < threshold ${(this.config.dipThreshold * 100).toFixed(1)}%`);
      }
      return false;
    }

    if (this.config.debug) {
      this.log(`✅ Leg1 signal validated: ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)}, drop ${(signal.dropPercent * 100).toFixed(1)}%`);
      this.log(`   (Leg2 will check sumTarget when opposite price drops)`);
    }

    return true;
  }

  // ===== Private: Signal Handling =====

  private async handleSignal(signal: DipArbSignal): Promise<void> {
    // Check if we can execute before emitting signal
    // This prevents logging signals that won't be executed
    if (!this.config.autoExecute) {
      // Manual mode: always emit signal for user to decide
      this.stats.signalsDetected++;
      this.emit('signal', signal);

      if (this.config.debug) {
        if (isDipArbLeg1Signal(signal)) {
          this.log(`Signal: Leg1 ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)} (${signal.source})`);
        } else {
          this.log(`Signal: Leg2 ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
        }
      }
      return;
    }

    // Auto-execute mode: only emit and log if we will actually execute
    // Note: isExecuting is already checked in processOrderbook(), this is a safety guard
    if (this.isExecuting) {
      return;
    }

    const now = Date.now();
    if (now - this.lastExecutionTime < this.config.executionCooldown) {
      // Skip - within cooldown period
      if (this.config.debug) {
        const remaining = this.config.executionCooldown - (now - this.lastExecutionTime);
        this.log(`Signal skipped (cooldown ${remaining}ms): ${isDipArbLeg1Signal(signal) ? 'Leg1' : 'Leg2'}`);
      }
      return;
    }

    // CRITICAL: Set isExecuting immediately to prevent duplicate signals from being processed
    // This must happen before any async operations or emit() calls
    this.isExecuting = true;

    // Will execute - now emit signal and log
    this.stats.signalsDetected++;
    this.emit('signal', signal);

    if (this.config.debug) {
      const signalType = isDipArbLeg1Signal(signal) ? 'Leg1' : 'Leg2';

      // Log orderbook context before execution (last 5 seconds of data)
      this.logOrderbookContext(`${signalType} Signal`);

      if (isDipArbLeg1Signal(signal)) {
        this.log(`🎯 Signal: Leg1 ${signal.dipSide} @ ${signal.currentPrice.toFixed(4)} (${signal.source})`);
        this.log(`   Target: ${signal.targetPrice.toFixed(4)} | Opposite: ${signal.oppositeAsk.toFixed(4)} | Est.Cost: ${signal.estimatedTotalCost.toFixed(4)}`);
      } else {
        this.log(`🎯 Signal: Leg2 ${signal.hedgeSide} @ ${signal.currentPrice.toFixed(4)}`);
        this.log(`   Target: ${signal.targetPrice.toFixed(4)} | TotalCost: ${signal.totalCost.toFixed(4)} | Profit: ${(signal.expectedProfitRate * 100).toFixed(2)}%`);
      }
    }

    // Execute
    let result: DipArbExecutionResult;

    if (isDipArbLeg1Signal(signal)) {
      result = await this.executeLeg1(signal);
    } else {
      result = await this.executeLeg2(signal);
    }

    this.emit('execution', result);
  }

  // ===== Public API: Auto-Rotate =====

  /**
   * Configure and enable auto-rotate
   *
   * Auto-rotate 会自动：
   * 1. 监控当前市场到期时间
   * 2. 在市场结束前预加载下一个市场
   * 3. 市场结束时自动结算（redeem 或 sell）
   * 4. 无缝切换到下一个 15m 市场
   *
   * @example
   * ```typescript
   * sdk.dipArb.enableAutoRotate({
   *   underlyings: ['BTC', 'ETH'],
   *   duration: '15m',
   *   autoSettle: true,
   *   settleStrategy: 'redeem',
   * });
   * ```
   */
  enableAutoRotate(config: Partial<DipArbAutoRotateConfig> = {}): void {
    this.autoRotateConfig = {
      ...this.autoRotateConfig,
      ...config,
      enabled: true,
    };

    this.log(`Auto-rotate enabled: ${JSON.stringify(this.autoRotateConfig)}`);
    this.startRotateCheck();

    // Start background redemption check if using redeem strategy
    if (this.autoRotateConfig.settleStrategy === 'redeem') {
      this.startRedeemCheck();

      // ✅ FIX: Scan for existing redeemable positions at startup
      this.scanAndQueueRedeemablePositions().catch(err => {
        this.log(`Warning: Failed to scan redeemable positions: ${err instanceof Error ? err.message : String(err)}`);
      });
    }
  }

  /**
   * ✅ FIX: Scan for existing redeemable positions and add them to the queue
   *
   * This is called when auto-rotate is enabled to recover any positions
   * from previous sessions that can be redeemed.
   */
  private async scanAndQueueRedeemablePositions(): Promise<void> {
    if (!this.ctf) {
      this.log('Cannot scan redeemable positions: CTF client not available');
      return;
    }

    try {
      // Scan for recently ended markets of the configured underlyings
      const now = Date.now();
      const markets = await this.scanUpcomingMarkets({
        coin: this.autoRotateConfig.underlyings.length === 1
          ? this.autoRotateConfig.underlyings[0]
          : 'all',
        duration: this.autoRotateConfig.duration,
        minMinutesUntilEnd: -60,  // Include markets that ended up to 60 minutes ago
        maxMinutesUntilEnd: 0,    // Only ended markets
        limit: 20,
      });

      this.log(`🔍 Scanning ${markets.length} recently ended markets for redeemable positions...`);

      let foundCount = 0;
      for (const market of markets) {
        // Skip current market
        if (market.conditionId === this.market?.conditionId) continue;

        // Check if we have any position in this market
        try {
          const tokenIds = {
            yesTokenId: market.upTokenId,
            noTokenId: market.downTokenId,
          };

          const balances = await this.ctf.getPositionBalanceByTokenIds(
            market.conditionId,
            tokenIds
          );

          const upBalance = parseFloat(balances.yesBalance);
          const downBalance = parseFloat(balances.noBalance);

          // If we have any tokens, check if market is resolved
          if (upBalance > 0.01 || downBalance > 0.01) {
            const resolution = await this.ctf.getMarketResolution(market.conditionId);

            if (resolution.isResolved) {
              // Check if we have winning tokens
              const winningBalance = resolution.winningOutcome === 'YES' ? upBalance : downBalance;

              if (winningBalance > 0.01) {
                // Add to pending redemption queue
                const pending: DipArbPendingRedemption = {
                  market,
                  round: {
                    roundId: `recovery-${market.slug}`,
                    priceToBeat: 0,
                    openPrices: { up: 0, down: 0 },
                    startTime: 0,
                    endTime: market.endTime.getTime(),
                    phase: 'completed',
                  },
                  marketEndTime: market.endTime.getTime(),
                  addedAt: now,
                  retryCount: 0,
                };

                this.pendingRedemptions.push(pending);
                foundCount++;
                this.log(`📌 Found redeemable: ${market.slug} | ${resolution.winningOutcome} won | Balance: ${winningBalance.toFixed(2)}`);
              }
            } else if (upBalance > 0.01 && downBalance > 0.01) {
              // Market not resolved but we have pairs - can merge
              const pairsToMerge = Math.min(upBalance, downBalance);
              this.log(`📌 Found mergeable pairs in ${market.slug}: ${pairsToMerge.toFixed(2)}`);

              // Try to merge immediately
              try {
                const result = await this.ctf.mergeByTokenIds(
                  market.conditionId,
                  tokenIds,
                  pairsToMerge.toString()
                );
                if (result.success) {
                  this.log(`✅ Merged ${pairsToMerge.toFixed(2)} pairs from ${market.slug}`);
                }
              } catch (mergeErr) {
                this.log(`⚠️ Failed to merge ${market.slug}: ${mergeErr instanceof Error ? mergeErr.message : String(mergeErr)}`);
              }
            }
          }
        } catch (err) {
          // Skip this market on error
        }
      }

      if (foundCount > 0) {
        this.log(`✅ Found ${foundCount} redeemable positions, added to queue`);
      } else {
        this.log('No redeemable positions found');
      }
    } catch (error) {
      this.log(`Error scanning redeemable positions: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Disable auto-rotate
   */
  disableAutoRotate(): void {
    this.autoRotateConfig.enabled = false;
    this.stopRotateCheck();
    this.stopRedeemCheck();
    this.log('Auto-rotate disabled');

    // Warn if there are pending redemptions
    if (this.pendingRedemptions.length > 0) {
      this.log(`Warning: ${this.pendingRedemptions.length} pending redemptions will not be processed`);
    }
  }

  /**
   * Get auto-rotate configuration
   */
  getAutoRotateConfig(): Required<DipArbAutoRotateConfig> {
    return { ...this.autoRotateConfig };
  }

  /**
   * Manually settle current position
   *
   * 结算策略：
   * - 'redeem': 等待市场结算后 redeem（需要等待结算完成）
   * - 'sell': 直接卖出 token（更快但可能有滑点）
   */
  async settle(strategy: 'redeem' | 'sell' = 'redeem'): Promise<DipArbSettleResult> {
    const startTime = Date.now();

    if (!this.market || !this.currentRound) {
      return {
        success: false,
        strategy,
        error: 'No active market or round',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      if (strategy === 'redeem') {
        return await this.settleByRedeem();
      } else {
        return await this.settleBySell();
      }
    } catch (error) {
      return {
        success: false,
        strategy,
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  /**
   * Manually rotate to next market
   */
  async rotateToNextMarket(): Promise<DipArbMarketConfig | null> {
    if (!this.autoRotateConfig.enabled) {
      this.log('Auto-rotate not enabled');
      return null;
    }

    // Find next market
    const nextMarket = await this.findNextMarket();
    if (!nextMarket) {
      this.log('No suitable next market found');
      return null;
    }

    // Stop current monitoring
    await this.stop();

    // Start new market
    await this.start(nextMarket);

    const event: DipArbRotateEvent = {
      previousMarket: this.market?.conditionId,
      newMarket: nextMarket.conditionId,
      reason: 'manual',
      timestamp: Date.now(),
    };
    this.emit('rotate', event);

    return nextMarket;
  }

  // ===== Private: Auto-Rotate Implementation =====

  private startRotateCheck(): void {
    if (this.rotateCheckInterval) {
      clearInterval(this.rotateCheckInterval);
    }

    // Check every 30 seconds
    this.rotateCheckInterval = setInterval(() => {
      this.checkRotation();
    }, 30000);

    // Also check immediately
    this.checkRotation();
  }

  private stopRotateCheck(): void {
    if (this.rotateCheckInterval) {
      clearInterval(this.rotateCheckInterval);
      this.rotateCheckInterval = null;
    }
  }

  // ===== Private: Pending Redemption Processing =====

  private startRedeemCheck(): void {
    if (this.redeemCheckInterval) {
      clearInterval(this.redeemCheckInterval);
    }

    const intervalMs = (this.autoRotateConfig.redeemRetryIntervalSeconds || 30) * 1000;

    // Check every 30 seconds (configurable)
    this.redeemCheckInterval = setInterval(() => {
      this.processPendingRedemptions();
    }, intervalMs);

    this.log(`Redeem check started (interval: ${intervalMs / 1000}s)`);
  }

  private stopRedeemCheck(): void {
    if (this.redeemCheckInterval) {
      clearInterval(this.redeemCheckInterval);
      this.redeemCheckInterval = null;
    }
  }

  /**
   * Add a position to pending redemption queue
   */
  private addPendingRedemption(market: DipArbMarketConfig, round: DipArbRoundState): void {
    const pending: DipArbPendingRedemption = {
      market,
      round,
      marketEndTime: market.endTime.getTime(),
      addedAt: Date.now(),
      retryCount: 0,
    };
    this.pendingRedemptions.push(pending);
    this.log(`Added pending redemption: ${market.slug} (queue size: ${this.pendingRedemptions.length})`);
  }

  /**
   * Process all pending redemptions
   * Called periodically by redeemCheckInterval
   */
  private async processPendingRedemptions(): Promise<void> {
    if (this.pendingRedemptions.length === 0) {
      return;
    }

    const now = Date.now();
    const waitMs = (this.autoRotateConfig.redeemWaitMinutes || 5) * 60 * 1000;

    for (let i = this.pendingRedemptions.length - 1; i >= 0; i--) {
      const pending = this.pendingRedemptions[i];
      const timeSinceEnd = now - pending.marketEndTime;

      // Skip if not enough time has passed since market end
      if (timeSinceEnd < waitMs) {
        const waitLeft = Math.round((waitMs - timeSinceEnd) / 1000);
        if (this.config.debug) {
          this.log(`Pending redemption ${pending.market.slug}: waiting ${waitLeft}s more for resolution`);
        }
        continue;
      }

      // Try to redeem
      pending.retryCount++;
      pending.lastRetryAt = now;

      try {
        if (!this.ctf) {
          this.log(`Cannot redeem ${pending.market.slug}: CTF client not available`);
          continue;
        }

        // Check if market is resolved
        const resolution = await this.ctf.getMarketResolution(pending.market.conditionId);

        if (!resolution.isResolved) {
          this.log(`Pending redemption ${pending.market.slug}: market not yet resolved (retry ${pending.retryCount})`);

          // Give up after too many retries (10 minutes of trying)
          if (pending.retryCount > 20) {
            this.log(`Giving up on redemption ${pending.market.slug}: too many retries`);
            this.pendingRedemptions.splice(i, 1);
            this.emit('settled', {
              success: false,
              strategy: 'redeem',
              market: pending.market,
              error: 'Market not resolved after max retries',
              executionTimeMs: 0,
            } as DipArbSettleResult);
          }
          continue;
        }

        // Market is resolved, try to redeem using Polymarket token IDs
        this.log(`Redeeming ${pending.market.slug}...`);
        const tokenIds = {
          yesTokenId: pending.market.upTokenId,
          noTokenId: pending.market.downTokenId,
        };
        const result = await this.ctf.redeemByTokenIds(pending.market.conditionId, tokenIds);

        // Remove from queue
        this.pendingRedemptions.splice(i, 1);

        const settleResult: DipArbSettleResult = {
          success: result.success,
          strategy: 'redeem',
          market: pending.market,
          txHash: result.txHash,
          amountReceived: result.usdcReceived ? parseFloat(result.usdcReceived) : undefined,
          executionTimeMs: 0,
        };

        this.emit('settled', settleResult);
        this.log(`Redemption successful: ${pending.market.slug} | Amount: $${settleResult.amountReceived?.toFixed(2) || 'N/A'}`);

        // Update stats
        if (settleResult.amountReceived) {
          this.stats.totalProfit += settleResult.amountReceived;
        }
      } catch (error) {
        this.log(`Redemption error for ${pending.market.slug}: ${error instanceof Error ? error.message : String(error)}`);

        // Give up after too many retries
        if (pending.retryCount > 20) {
          this.log(`Giving up on redemption ${pending.market.slug}: error after max retries`);
          this.pendingRedemptions.splice(i, 1);
          this.emit('settled', {
            success: false,
            strategy: 'redeem',
            market: pending.market,
            error: error instanceof Error ? error.message : String(error),
            executionTimeMs: 0,
          } as DipArbSettleResult);
        }
      }
    }
  }

  /**
   * Get pending redemptions (for debugging/monitoring)
   */
  getPendingRedemptions(): DipArbPendingRedemption[] {
    return [...this.pendingRedemptions];
  }

  private async checkRotation(): Promise<void> {
    if (!this.autoRotateConfig.enabled || !this.market) {
      if (this.config.debug) {
        this.log(`checkRotation: skipped (enabled=${this.autoRotateConfig.enabled}, market=${!!this.market})`);
      }
      return;
    }

    const now = Date.now();
    const endTime = this.market.endTime.getTime();
    const timeUntilEnd = endTime - now;
    const preloadMs = (this.autoRotateConfig.preloadMinutes || 2) * 60 * 1000;

    if (this.config.debug) {
      const timeLeftSec = Math.round(timeUntilEnd / 1000);
      this.log(`checkRotation: timeUntilEnd=${timeLeftSec}s, preloadMs=${preloadMs / 1000}s, nextMarket=${this.nextMarket?.slug || 'none'}`);
    }

    // Preload next market when close to end
    if (timeUntilEnd <= preloadMs && !this.nextMarket) {
      this.log('Preloading next market...');
      this.nextMarket = await this.findNextMarket();
      if (this.nextMarket) {
        this.log(`Next market ready: ${this.nextMarket.slug}`);
      } else {
        this.log('No next market found during preload');
      }
    }

    // Market ended - settle and rotate
    if (timeUntilEnd <= 0) {
      this.log(`Market ended ${Math.round(-timeUntilEnd / 1000)}s ago, initiating rotation...`);

      // Settle if configured and has position
      if (this.autoRotateConfig.autoSettle && this.currentRound?.leg1) {
        const strategy = this.autoRotateConfig.settleStrategy || 'redeem';

        if (strategy === 'redeem') {
          // For redeem strategy, add to pending queue (will be processed after 5 min wait)
          this.addPendingRedemption(this.market, this.currentRound);
          this.log(`Position added to pending redemption queue (will redeem after ${this.autoRotateConfig.redeemWaitMinutes || 5}min)`);
        } else {
          // For sell strategy, execute immediately
          const settleResult = await this.settle('sell');
          this.emit('settled', settleResult);
        }
      }

      // Rotate to next market
      if (this.nextMarket) {
        const previousMarket = this.market;
        const newMarket = this.nextMarket;
        this.nextMarket = null;

        // Stop current market (this clears the rotate check interval)
        await this.stop();

        // Start new market
        await this.start(newMarket);

        // Restart the rotate check interval for the new market
        this.startRotateCheck();

        const event: DipArbRotateEvent = {
          previousMarket: previousMarket.conditionId,
          newMarket: newMarket.conditionId,
          reason: 'marketEnded',
          timestamp: Date.now(),
        };
        this.emit('rotate', event);
      } else {
        // Try to find a market
        this.log('No preloaded market, searching...');
        const newMarket = await this.findNextMarket();
        if (newMarket) {
          const previousMarket = this.market;

          // Stop current market (this clears the rotate check interval)
          await this.stop();

          // Start new market
          await this.start(newMarket);

          // Restart the rotate check interval for the new market
          this.startRotateCheck();

          const event: DipArbRotateEvent = {
            previousMarket: previousMarket.conditionId,
            newMarket: newMarket.conditionId,
            reason: 'marketEnded',
            timestamp: Date.now(),
          };
          this.emit('rotate', event);
        } else {
          this.log('No next market available, stopping...');
          await this.stop();
        }
      }
    }
  }

  private async findNextMarket(): Promise<DipArbMarketConfig | null> {
    const markets = await this.scanUpcomingMarkets({
      coin: this.autoRotateConfig.underlyings.length === 1
        ? this.autoRotateConfig.underlyings[0]
        : 'all',
      duration: this.autoRotateConfig.duration,
      minMinutesUntilEnd: 5,
      maxMinutesUntilEnd: 30,
      limit: 10,
    });

    // Filter to configured underlyings
    const filtered = markets.filter(m =>
      this.autoRotateConfig.underlyings.includes(m.underlying as DipArbUnderlying)
    );

    // Exclude current market
    const available = filtered.filter(m =>
      m.conditionId !== this.market?.conditionId
    );

    // Return the soonest one
    return available.length > 0 ? available[0] : null;
  }

  private async settleByRedeem(): Promise<DipArbSettleResult> {
    const startTime = Date.now();

    if (!this.ctf || !this.market) {
      return {
        success: false,
        strategy: 'redeem',
        error: 'CTF client or market not available',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      // Check market resolution first
      const resolution = await this.ctf.getMarketResolution(this.market.conditionId);

      if (!resolution.isResolved) {
        return {
          success: false,
          strategy: 'redeem',
          error: 'Market not yet resolved',
          executionTimeMs: Date.now() - startTime,
        };
      }

      // Redeem winning tokens using Polymarket token IDs
      const tokenIds = {
        yesTokenId: this.market.upTokenId,
        noTokenId: this.market.downTokenId,
      };

      const result = await this.ctf.redeemByTokenIds(this.market.conditionId, tokenIds);

      return {
        success: result.success,
        strategy: 'redeem',
        txHash: result.txHash,
        amountReceived: result.usdcReceived ? parseFloat(result.usdcReceived) : undefined,
        executionTimeMs: Date.now() - startTime,
      };
    } catch (error) {
      return {
        success: false,
        strategy: 'redeem',
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  private async settleBySell(): Promise<DipArbSettleResult> {
    const startTime = Date.now();

    if (!this.tradingService || !this.market || !this.currentRound) {
      return {
        success: false,
        strategy: 'sell',
        error: 'Trading service or market not available',
        executionTimeMs: Date.now() - startTime,
      };
    }

    try {
      let totalReceived = 0;

      // Sell leg1 position if exists
      if (this.currentRound.leg1) {
        const leg1Shares = this.currentRound.leg1.shares;
        const result = await this.tradingService.createMarketOrder({
          tokenId: this.currentRound.leg1.tokenId,
          side: 'SELL' as Side,
          amount: leg1Shares,
        });

        if (result.success) {
          totalReceived += leg1Shares * (this.currentRound.leg1.side === 'UP'
            ? (this.upAsks[0]?.price ?? 0.5)
            : (this.downAsks[0]?.price ?? 0.5));
        }
      }

      // Sell leg2 position if exists
      if (this.currentRound.leg2) {
        const leg2Shares = this.currentRound.leg2.shares;
        const result = await this.tradingService.createMarketOrder({
          tokenId: this.currentRound.leg2.tokenId,
          side: 'SELL' as Side,
          amount: leg2Shares,
        });

        if (result.success) {
          totalReceived += leg2Shares * (this.currentRound.leg2.side === 'UP'
            ? (this.upAsks[0]?.price ?? 0.5)
            : (this.downAsks[0]?.price ?? 0.5));
        }
      }

      return {
        success: true,
        strategy: 'sell',
        amountReceived: totalReceived,
        executionTimeMs: Date.now() - startTime,
      };
    } catch (error) {
      return {
        success: false,
        strategy: 'sell',
        error: error instanceof Error ? error.message : String(error),
        executionTimeMs: Date.now() - startTime,
      };
    }
  }

  // ===== Private: Helpers =====

  /**
   * Update orderbook buffer for smart logging
   * Keeps last 5 seconds of orderbook data
   */
  private updateOrderbookBuffer(_book: OrderbookSnapshot): void {
    if (!this.market) return;

    const upAsk = this.upAsks[0]?.price ?? 0;
    const downAsk = this.downAsks[0]?.price ?? 0;

    this.orderbookBuffer.push({
      timestamp: Date.now(),
      upAsk,
      downAsk,
      upDepth: this.upAsks.length,
      downDepth: this.downAsks.length,
    });

    // Keep only last ORDERBOOK_BUFFER_SIZE entries
    if (this.orderbookBuffer.length > this.ORDERBOOK_BUFFER_SIZE) {
      this.orderbookBuffer = this.orderbookBuffer.slice(-this.ORDERBOOK_BUFFER_SIZE);
    }
  }

  /**
   * Log orderbook summary at intervals (every 10 seconds)
   * Reduces log noise from ~10 logs/sec to 1 log/10sec
   */
  private maybeLogOrderbookSummary(): void {
    const now = Date.now();

    // Only log every ORDERBOOK_LOG_INTERVAL_MS
    if (now - this.lastOrderbookLogTime < this.ORDERBOOK_LOG_INTERVAL_MS) {
      return;
    }

    this.lastOrderbookLogTime = now;

    const upAsk = this.upAsks[0]?.price ?? 0;
    const downAsk = this.downAsks[0]?.price ?? 0;
    const sum = upAsk + downAsk;

    this.log(`📊 Orderbook: UP=${upAsk.toFixed(3)} | DOWN=${downAsk.toFixed(3)} | Sum=${sum.toFixed(3)}`);
  }

  /**
   * Log orderbook buffer around a signal/trade
   * Called when signal is detected to capture market context
   */
  private logOrderbookContext(eventType: string): void {
    if (this.orderbookBuffer.length === 0) return;

    this.log(`📈 ${eventType} - Orderbook context (last ${this.orderbookBuffer.length} ticks):`);

    // Log first, middle, and last entries for context
    const first = this.orderbookBuffer[0];
    const mid = this.orderbookBuffer[Math.floor(this.orderbookBuffer.length / 2)];
    const last = this.orderbookBuffer[this.orderbookBuffer.length - 1];

    const formatTime = (ts: number) => new Date(ts).toISOString().slice(11, 23);

    this.log(`   ${formatTime(first.timestamp)}: UP=${first.upAsk.toFixed(4)} DOWN=${first.downAsk.toFixed(4)}`);
    if (this.orderbookBuffer.length > 2) {
      this.log(`   ${formatTime(mid.timestamp)}: UP=${mid.upAsk.toFixed(4)} DOWN=${mid.downAsk.toFixed(4)}`);
    }
    this.log(`   ${formatTime(last.timestamp)}: UP=${last.upAsk.toFixed(4)} DOWN=${last.downAsk.toFixed(4)}`);

    // Calculate price changes
    const upChange = ((last.upAsk - first.upAsk) / first.upAsk * 100).toFixed(2);
    const downChange = ((last.downAsk - first.downAsk) / first.downAsk * 100).toFixed(2);
    this.log(`   Change: UP ${upChange}% | DOWN ${downChange}%`);
  }

  private log(message: string): void {
    const shouldLog = this.config.debug || message.startsWith('Starting') || message.startsWith('Stopped');
    if (!shouldLog) return;

    const formatted = `[DipArb] ${message}`;

    // Use custom log handler if provided
    if (this.config.logHandler) {
      this.config.logHandler(formatted);
    } else {
      console.log(formatted);
    }
  }
}

// Re-export types
export * from './dip-arb-types.js';

================================================================================
// File: src/services/dip-arb-types.ts
================================================================================
/**
 * Dip Arbitrage Service Types
 *
 * 暴跌套利服务类型定义
 *
 * 策略原理：
 * 在 Polymarket 的 BTC/ETH/SOL/XRP UP/DOWN 短期市场中：
 *
 * 1. 每个市场有一个 "price to beat"（开盘时的 Chainlink 价格）
 * 2. 结算规则：
 *    - UP 赢：结束时价格 >= price to beat
 *    - DOWN 赢：结束时价格 < price to beat
 *
 * 3. 套利流程：
 *    - Leg1：检测暴跌 → 买入暴跌侧
 *    - Leg2：等待对冲条件 → 买入另一侧
 *    - 利润：总成本 < $1 时获得无风险利润
 */

// ============= Configuration =============

/**
 * DipArbService 配置
 */
export interface DipArbServiceConfig {
  /**
   * 每次交易的份额数量
   * @default 20
   */
  shares?: number;

  /**
   * 对冲价格阈值 (sumTarget)
   * 只有当 leg1Price + leg2Price <= sumTarget 时才执行对冲
   * @default 0.95
   */
  sumTarget?: number;

  /**
   * 暴跌触发阈值
   * 价格相对开盘价下跌超过此比例时触发 Leg1
   * 0.15 = 15%
   * @default 0.15
   */
  dipThreshold?: number;

  /**
   * 交易窗口（分钟）
   * 每轮开始后，只在此时间窗口内触发 Leg1
   * @default 2
   */
  windowMinutes?: number;

  /**
   * 滑动窗口时长（毫秒）
   * 用于检测瞬时暴跌：比较当前价格与 N 毫秒前的价格
   *
   * 重要：这是策略的核心参数！
   * - 3000ms (3秒) 跌 15% = 异常事件 ✅ 触发
   * - 5分钟跌 15% = 趋势下行 ❌ 不触发
   *
   * @default 3000
   */
  slidingWindowMs?: number;

  /**
   * 最大滑点
   * 下单价格 = 市场价 * (1 + maxSlippage)
   * @default 0.02
   */
  maxSlippage?: number;

  /**
   * 最小利润率
   * 只有预期利润率 > minProfitRate 时才生成信号
   * @default 0.03
   */
  minProfitRate?: number;

  /**
   * Leg1 成交后等待 Leg2 的最大时间（秒）
   * 超时后放弃当前轮次
   * @default 300
   */
  leg2TimeoutSeconds?: number;

  /**
   * 启用暴涨检测
   * 当 token 价格暴涨时，买入对手 token（预期均值回归）
   * @default true
   */
  enableSurge?: boolean;

  /**
   * 暴涨触发阈值
   * 价格相对开盘价上涨超过此比例时触发
   * @default 0.15
   */
  surgeThreshold?: number;

  /**
   * 完成双腿后自动合并回 USDC
   * YES + NO tokens → USDC
   * @default true
   */
  autoMerge?: boolean;

  /**
   * 自动执行交易
   * 检测到信号后自动下单
   * @default false
   */
  autoExecute?: boolean;

  /**
   * 执行冷却时间（毫秒）
   * 两次交易之间的最小间隔
   * @default 3000
   */
  executionCooldown?: number;

  /**
   * 拆分订单数量
   * 将 shares 拆分成多笔订单执行
   * 例如: shares=30, splitOrders=3 → 每笔 10 shares
   * @default 1 (不拆分)
   */
  splitOrders?: number;

  /**
   * 拆分订单间隔（毫秒）
   * 多笔订单之间的间隔时间
   * @default 500
   */
  orderIntervalMs?: number;

  /**
   * 启用调试日志
   * @default false
   */
  debug?: boolean;

  /**
   * 自定义日志处理函数
   * 如果设置，所有日志将通过此函数输出
   * @example
   * logHandler: (msg) => {
   *   console.log(`[${Date.now()}] ${msg}`);
   *   logs.push(msg);
   * }
   */
  logHandler?: (message: string) => void;
}

/**
 * 内部配置类型（不包含 logHandler，因为它是纯可选的回调函数）
 */
export type DipArbConfigInternal = Required<Omit<DipArbServiceConfig, 'logHandler'>> & {
  logHandler?: (message: string) => void;
};

/**
 * 默认配置
 */
export const DEFAULT_DIP_ARB_CONFIG: DipArbConfigInternal = {
  shares: 20,
  sumTarget: 0.92,        // ✅ 放宽到 0.92 提高 Leg2 成交率 (8%+ 利润)
  dipThreshold: 0.15,
  windowMinutes: 2,
  slidingWindowMs: 3000,  // 3秒滑动窗口 - 核心参数！
  maxSlippage: 0.02,
  minProfitRate: 0.03,
  leg2TimeoutSeconds: 180,  // ✅ 缩短到 3 分钟，更快退出未对冲仓位
  enableSurge: true,
  surgeThreshold: 0.15,
  autoMerge: true,
  autoExecute: false,
  executionCooldown: 3000,
  splitOrders: 1,         // ✅ 默认不拆分，避免份额误差
  orderIntervalMs: 500,   // 拆分订单间隔 500ms
  debug: false,
};

// ============= Market Configuration =============

/** 支持的底层资产 */
export type DipArbUnderlying = 'BTC' | 'ETH' | 'SOL' | 'XRP';

/** 市场时长 */
export type DipArbDuration = 5 | 15;

/**
 * 市场配置
 */
export interface DipArbMarketConfig {
  /** 市场名称（用于日志） */
  name: string;
  /** 市场 slug (e.g., 'btc-updown-15m-1767165300') */
  slug: string;
  /** Condition ID */
  conditionId: string;
  /** UP token ID */
  upTokenId: string;
  /** DOWN token ID */
  downTokenId: string;
  /** 底层资产 */
  underlying: DipArbUnderlying;
  /** 市场时长（分钟） */
  durationMinutes: DipArbDuration;
  /** 市场结束时间 */
  endTime: Date;
}

// ============= Round State =============

/** 轮次阶段 */
export type DipArbPhase = 'waiting' | 'leg1_filled' | 'completed' | 'expired';

/** 交易侧 */
export type DipArbSide = 'UP' | 'DOWN';

/**
 * Leg 信息
 */
export interface DipArbLegInfo {
  /** 买入侧 */
  side: DipArbSide;
  /** 成交价格 */
  price: number;
  /** 份额数量 */
  shares: number;
  /** 成交时间 */
  timestamp: number;
  /** Token ID */
  tokenId: string;
}

/**
 * 轮次状态
 */
export interface DipArbRoundState {
  /** 轮次 ID */
  roundId: string;
  /** 轮次开始时间 (Unix ms) */
  startTime: number;
  /** 轮次结束时间 (Unix ms) */
  endTime: number;
  /** Price to Beat - 开盘时的底层资产价格（Chainlink） */
  priceToBeat: number;
  /** 开盘时的 token 价格 */
  openPrices: {
    up: number;
    down: number;
  };
  /** 当前阶段 */
  phase: DipArbPhase;
  /** Leg1 信息（如果已成交） */
  leg1?: DipArbLegInfo;
  /** Leg2 信息（如果已成交） */
  leg2?: DipArbLegInfo;
  /** 总成本 */
  totalCost?: number;
  /** 实际利润 */
  profit?: number;
}

// ============= Signals =============

/**
 * Leg1 信号
 */
export interface DipArbLeg1Signal {
  type: 'leg1';
  /** 轮次 ID */
  roundId: string;
  /** 买入侧 */
  dipSide: DipArbSide;
  /** 当前价格 */
  currentPrice: number;
  /** 开盘价格 */
  openPrice: number;
  /** 下跌/上涨幅度 */
  dropPercent: number;
  /** 目标价格（包含滑点） */
  targetPrice: number;
  /** 份额数量 */
  shares: number;
  /** Token ID */
  tokenId: string;
  /** 对手侧当前 ask 价格 */
  oppositeAsk: number;
  /** 预估总成本 */
  estimatedTotalCost: number;
  /** 预估利润率 */
  estimatedProfitRate: number;
  /** 信号来源 */
  source: 'dip' | 'surge' | 'mispricing';
  /** BTC 信息（用于定价偏差检测） */
  btcInfo?: {
    btcPrice: number;
    priceToBeat: number;
    btcChangePercent: number;
    estimatedWinRate: number;
  };
}

/**
 * Leg2 信号
 */
export interface DipArbLeg2Signal {
  type: 'leg2';
  /** 轮次 ID */
  roundId: string;
  /** 对冲侧 */
  hedgeSide: DipArbSide;
  /** Leg1 信息 */
  leg1: DipArbLegInfo;
  /** 当前价格 */
  currentPrice: number;
  /** 目标价格（包含滑点） */
  targetPrice: number;
  /** 总成本 (leg1 + leg2) */
  totalCost: number;
  /** 预期利润率 */
  expectedProfitRate: number;
  /** 份额数量 */
  shares: number;
  /** Token ID */
  tokenId: string;
}

/** 信号类型 */
export type DipArbSignal = DipArbLeg1Signal | DipArbLeg2Signal;

// ============= Execution Results =============

/**
 * 执行结果
 */
export interface DipArbExecutionResult {
  /** 是否成功 */
  success: boolean;
  /** 执行的 leg */
  leg: 'leg1' | 'leg2' | 'merge' | 'exit';
  /** 轮次 ID */
  roundId: string;
  /** 交易侧 */
  side?: DipArbSide;
  /** 成交价格 */
  price?: number;
  /** 成交份额 */
  shares?: number;
  /** 订单 ID */
  orderId?: string;
  /** 交易哈希（merge 操作） */
  txHash?: string;
  /** 错误信息 */
  error?: string;
  /** 执行时间（毫秒） */
  executionTimeMs: number;
}

/**
 * 轮次完成结果
 */
export interface DipArbRoundResult {
  /** 轮次 ID */
  roundId: string;
  /** 状态 */
  status: 'completed' | 'expired' | 'partial';
  /** Leg1 信息 */
  leg1?: DipArbLegInfo;
  /** Leg2 信息 */
  leg2?: DipArbLegInfo;
  /** 总成本 */
  totalCost?: number;
  /** 实际利润 */
  profit?: number;
  /** 利润率 */
  profitRate?: number;
  /** 是否已合并 */
  merged: boolean;
  /** 合并交易哈希 */
  mergeTxHash?: string;
  /** Leg1 退出结果（Leg2 超时时） */
  exitResult?: DipArbExecutionResult | null;
}

// ============= Statistics =============

/**
 * 服务统计
 */
export interface DipArbStats {
  /** 开始时间 */
  startTime: number;
  /** 运行时长（毫秒） */
  runningTimeMs: number;
  /** 监控的轮次数 */
  roundsMonitored: number;
  /** 完成的轮次数 */
  roundsCompleted: number;
  /** 成功的轮次数（双腿完成） */
  roundsSuccessful: number;
  /** 过期的轮次数 */
  roundsExpired: number;
  /** 检测到的信号数 */
  signalsDetected: number;
  /** Leg1 成交次数 */
  leg1Filled: number;
  /** Leg2 成交次数 */
  leg2Filled: number;
  /** 总花费 (USDC) */
  totalSpent: number;
  /** 总收益 (USDC) */
  totalProfit: number;
  /** 平均利润率 */
  avgProfitRate: number;
  /** 当前轮次信息 */
  currentRound?: {
    roundId: string;
    phase: DipArbPhase;
    priceToBeat: number;
    leg1?: { side: DipArbSide; price: number };
  };
}

// ============= Events =============

/**
 * 新轮次事件数据
 */
export interface DipArbNewRoundEvent {
  roundId: string;
  priceToBeat: number;
  upOpen: number;
  downOpen: number;
  startTime: number;
  endTime: number;
}

/**
 * 价格更新事件数据
 */
export interface DipArbPriceUpdateEvent {
  underlying: DipArbUnderlying;
  value: number;
  priceToBeat: number;
  changePercent: number;
}

/**
 * 服务事件
 */
export interface DipArbServiceEvents {
  started: (market: DipArbMarketConfig) => void;
  stopped: () => void;
  newRound: (event: DipArbNewRoundEvent) => void;
  signal: (signal: DipArbSignal) => void;
  execution: (result: DipArbExecutionResult) => void;
  roundComplete: (result: DipArbRoundResult) => void;
  priceUpdate: (event: DipArbPriceUpdateEvent) => void;
  error: (error: Error) => void;
}

// ============= Scan Options =============

/**
 * 市场扫描选项
 */
export interface DipArbScanOptions {
  /** 筛选底层资产 */
  coin?: DipArbUnderlying | 'all';
  /** 筛选时长 */
  duration?: '5m' | '15m' | 'all';
  /** 距离结束的最小分钟数 */
  minMinutesUntilEnd?: number;
  /** 距离结束的最大分钟数 */
  maxMinutesUntilEnd?: number;
  /** 返回数量限制 */
  limit?: number;
}

/**
 * 自动启动选项
 */
export interface DipArbFindAndStartOptions {
  /** 偏好的底层资产 */
  coin?: DipArbUnderlying;
  /** 偏好的时长 */
  preferDuration?: '5m' | '15m';
}

/**
 * 自动轮换配置
 */
export interface DipArbAutoRotateConfig {
  /** 是否启用自动轮换 */
  enabled: boolean;
  /** 监控的底层资产列表 */
  underlyings: DipArbUnderlying[];
  /** 偏好的时长 */
  duration: '5m' | '15m';
  /** 市场结束前多少分钟开始寻找下一个市场 */
  preloadMinutes?: number;
  /** 市场结束后自动结算 */
  autoSettle?: boolean;
  /** 结算策略: 'redeem' 赎回 (等结算) 或 'sell' 立即卖出 */
  settleStrategy?: 'redeem' | 'sell';
  /** Redeem 等待时间（分钟）- 市场结束后等待 Oracle 结算的时间，默认 5 分钟 */
  redeemWaitMinutes?: number;
  /** Redeem 重试间隔（秒）- 每次检查 resolution 的间隔，默认 30 秒 */
  redeemRetryIntervalSeconds?: number;
}

/**
 * 默认自动轮换配置
 */
export const DEFAULT_AUTO_ROTATE_CONFIG: Required<DipArbAutoRotateConfig> = {
  enabled: false,
  underlyings: ['BTC'],
  duration: '15m',
  preloadMinutes: 2,
  autoSettle: true,
  settleStrategy: 'redeem',
  redeemWaitMinutes: 5,
  redeemRetryIntervalSeconds: 30,
};

/**
 * 结算结果
 */
export interface DipArbSettleResult {
  /** 是否成功 */
  success: boolean;
  /** 结算策略 */
  strategy: 'redeem' | 'sell';
  /** 市场信息 */
  market?: DipArbMarketConfig;
  /** UP token 数量 */
  upBalance?: number;
  /** DOWN token 数量 */
  downBalance?: number;
  /** 收到的金额 (USDC) */
  amountReceived?: number;
  /** 交易哈希 */
  txHash?: string;
  /** 错误信息 */
  error?: string;
  /** 执行时间（毫秒） */
  executionTimeMs: number;
}

/**
 * 待赎回的仓位
 * 用于跟踪市场结束后需要赎回的仓位
 */
export interface DipArbPendingRedemption {
  /** 市场配置 */
  market: DipArbMarketConfig;
  /** 轮次状态（包含持仓信息） */
  round: DipArbRoundState;
  /** 市场结束时间 */
  marketEndTime: number;
  /** 添加到队列的时间 */
  addedAt: number;
  /** 重试次数 */
  retryCount: number;
  /** 最后一次尝试时间 */
  lastRetryAt?: number;
}

/**
 * 市场轮换事件
 */
export interface DipArbRotateEvent {
  /** 旧市场 condition ID */
  previousMarket?: string;
  /** 新市场 condition ID */
  newMarket: string;
  /** 轮换原因 */
  reason: 'marketEnded' | 'manual' | 'error';
  /** 时间戳 */
  timestamp: number;
  /** 结算结果（如果有） */
  settleResult?: DipArbSettleResult;
}

// ============= Helper Functions =============

/**
 * 创建初始统计
 */
export function createDipArbInitialStats(): DipArbStats {
  return {
    startTime: Date.now(),
    runningTimeMs: 0,
    roundsMonitored: 0,
    roundsCompleted: 0,
    roundsSuccessful: 0,
    roundsExpired: 0,
    signalsDetected: 0,
    leg1Filled: 0,
    leg2Filled: 0,
    totalSpent: 0,
    totalProfit: 0,
    avgProfitRate: 0,
  };
}

/**
 * 创建新轮次状态
 */
export function createDipArbRoundState(
  roundId: string,
  priceToBeat: number,
  upPrice: number,
  downPrice: number,
  durationMinutes: number = 15
): DipArbRoundState {
  const now = Date.now();
  return {
    roundId,
    startTime: now,
    endTime: now + durationMinutes * 60 * 1000,
    priceToBeat,
    openPrices: {
      up: upPrice,
      down: downPrice,
    },
    phase: 'waiting',
  };
}

/**
 * 计算利润率
 */
export function calculateDipArbProfitRate(totalCost: number): number {
  if (totalCost >= 1 || totalCost <= 0) return 0;
  return (1 - totalCost) / totalCost;
}

/**
 * 计算基于底层资产价格变化的"真实"胜率
 *
 * @param currentPrice - 当前价格
 * @param priceToBeat - 开盘价格
 * @returns UP 的真实胜率估计 (0-1)
 */
export function estimateUpWinRate(currentPrice: number, priceToBeat: number): number {
  if (priceToBeat <= 0) return 0.5;

  const priceChange = (currentPrice - priceToBeat) / priceToBeat;

  // 简单模型：价格变化 1% 对应胜率变化约 10%
  const sensitivity = 10;
  const winRateShift = priceChange * sensitivity;

  // 限制在 [0.05, 0.95] 范围内
  return Math.max(0.05, Math.min(0.95, 0.5 + winRateShift));
}

/**
 * 检测定价偏差
 *
 * @param tokenPrice - token 当前价格（隐含胜率）
 * @param estimatedWinRate - 基于价格估计的真实胜率
 * @returns 偏差程度（正数 = 被低估，负数 = 被高估）
 */
export function detectMispricing(tokenPrice: number, estimatedWinRate: number): number {
  return estimatedWinRate - tokenPrice;
}

/**
 * 从 slug 解析底层资产
 * e.g., 'btc-updown-15m-1767165300' → 'BTC'
 */
export function parseUnderlyingFromSlug(slug: string): DipArbUnderlying {
  const lower = slug.toLowerCase();
  if (lower.startsWith('btc')) return 'BTC';
  if (lower.startsWith('eth')) return 'ETH';
  if (lower.startsWith('sol')) return 'SOL';
  if (lower.startsWith('xrp')) return 'XRP';
  return 'BTC'; // default
}

/**
 * 从 slug 解析时长
 * e.g., 'btc-updown-15m-1767165300' → 15
 */
export function parseDurationFromSlug(slug: string): DipArbDuration {
  if (slug.includes('-5m-')) return 5;
  if (slug.includes('-15m-')) return 15;
  return 15; // default
}

/**
 * 类型守卫：检查是否为 Leg1 信号
 */
export function isDipArbLeg1Signal(signal: DipArbSignal): signal is DipArbLeg1Signal {
  return signal.type === 'leg1';
}

/**
 * 类型守卫：检查是否为 Leg2 信号
 */
export function isDipArbLeg2Signal(signal: DipArbSignal): signal is DipArbLeg2Signal {
  return signal.type === 'leg2';
}

================================================================================
// File: src/services/market-service.ts
================================================================================
/**
 * Market Service
 *
 * Provides market data and analysis:
 * - Market info and discovery
 * - Orderbook data and analysis
 * - K-Line aggregation from trade data
 * - Spread analysis
 * - Arbitrage detection
 */

import {
  ClobClient,
  Side as ClobSide,
  Chain,
  PriceHistoryInterval,
  type OrderBookSummary,
} from '@polymarket/clob-client';
import { Wallet } from 'ethers';
import { DataApiClient, Trade } from '../clients/data-api.js';
import { GammaApiClient, GammaMarket } from '../clients/gamma-api.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { CACHE_TTL } from '../core/unified-cache.js';
import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import { PolymarketError, ErrorCode } from '../core/errors.js';
import type {
  UnifiedMarket,
  MarketToken as UnifiedMarketToken,
  ProcessedOrderbook,
  EffectivePrices,
  ArbitrageOpportunity,
  KLineInterval,
  KLineCandle,
  DualKLineData,
  SpreadDataPoint,
  RealtimeSpreadAnalysis,
  Side,
  Orderbook,
  UnderlyingAsset,
  TokenUnderlyingCorrelation,
  TokenUnderlyingDataPoint,
} from '../core/types.js';
import type { BinanceService, BinanceInterval } from './binance-service.js';

// CLOB Host
const CLOB_HOST = 'https://clob.polymarket.com';

// Chain IDs
export const POLYGON_MAINNET = 137;

/**
 * Normalize timestamp to milliseconds.
 * Polymarket API sometimes returns timestamps in seconds.
 * Timestamps < 1e12 (year ~2001 in ms) are assumed to be in seconds.
 */
function normalizeTimestamp(ts: number): number {
  return ts < 1e12 ? ts * 1000 : ts;
}

// Mapping from underlying asset to Binance symbol
const UNDERLYING_TO_SYMBOL = {
  BTC: 'BTCUSDT',
  ETH: 'ETHUSDT',
  SOL: 'SOLUSDT',
} as const;

// Map from KLineInterval to BinanceInterval (Binance doesn't support 30s or 12h)
const KLINE_TO_BINANCE_INTERVAL: Partial<Record<KLineInterval, BinanceInterval>> = {
  '1m': '1m',
  '5m': '5m',
  '15m': '15m',
  '30m': '30m',
  '1h': '1h',
  '4h': '4h',
  '1d': '1d',
};

// ============================================================================
// Types
// ============================================================================

// Side and Orderbook are imported from core/types.ts
// Re-export for backward compatibility
export type { Side, Orderbook } from '../core/types.js';

export type PriceHistoryIntervalString = '1h' | '6h' | '1d' | '1w' | 'max';

export interface PriceHistoryParams {
  tokenId: string;
  interval?: PriceHistoryIntervalString;
  startTs?: number;
  endTs?: number;
  fidelity?: number;
}

export interface PricePoint {
  timestamp: number;
  price: number;
}

export interface MarketServiceConfig {
  /** Private key for CLOB client auth (optional, for authenticated endpoints) */
  privateKey?: string;
  /** Chain ID (default: Polygon mainnet 137) */
  chainId?: number;
}

// Internal type for CLOB market data
interface ClobMarket {
  condition_id: string;
  question_id?: string;
  market_slug: string;
  question: string;
  description?: string;
  tokens: Array<{
    token_id: string;
    outcome: string;
    price: number;
    winner?: boolean;
  }>;
  active: boolean;
  closed: boolean;
  accepting_orders: boolean;
  end_date_iso?: string | null;
  neg_risk?: boolean;
  minimum_order_size?: number;
  minimum_tick_size?: number;
}

/**
 * CLOB Market type (from CLOB API)
 *
 * This represents the raw market data from the CLOB API.
 * For merged market data with volume/liquidity, use UnifiedMarket from core/types.ts.
 */
export interface Market {
  conditionId: string;
  questionId?: string;
  marketSlug: string;
  question: string;
  description?: string;
  tokens: MarketToken[];
  active: boolean;
  closed: boolean;
  acceptingOrders: boolean;
  endDateIso?: string | null;
  negRisk?: boolean;
  minimumOrderSize?: number;
  minimumTickSize?: number;
}

/**
 * Token in a CLOB market
 * Same structure as MarketToken in core/types.ts
 */
export interface MarketToken {
  tokenId: string;
  outcome: string;
  price: number;
  winner?: boolean;
}

/**
 * Resolved market tokens with outcome names
 *
 * Uses `primary`/`secondary` naming to be market-agnostic:
 * - Yes/No markets: primary=Yes, secondary=No
 * - Up/Down markets: primary=Up, secondary=Down
 * - Team markets: primary=Team1, secondary=Team2
 *
 * This follows the BinaryTokens pattern in core/types.ts
 */
export interface ResolvedMarketTokens {
  /** Primary outcome token ID (index 0: Yes/Up/Team1) */
  primaryTokenId: string;
  /** Secondary outcome token ID (index 1: No/Down/Team2) */
  secondaryTokenId: string;
  /** Outcome names for display [primary, secondary] */
  outcomes: [string, string];
  /** Primary outcome name (e.g., "Yes", "Up") */
  primaryOutcome: string;
  /** Secondary outcome name (e.g., "No", "Down") */
  secondaryOutcome: string;
}

// ============================================================================
// MarketService Implementation
// ============================================================================

export class MarketService {
  private clobClient: ClobClient | null = null;
  private initialized = false;

  constructor(
    private gammaApi: GammaApiClient | undefined,
    private dataApi: DataApiClient | undefined,
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache,
    private config?: MarketServiceConfig,
    private binanceService?: BinanceService
  ) {}

  // ============================================================================
  // Initialization
  // ============================================================================

  private async ensureInitialized(): Promise<ClobClient> {
    if (!this.initialized || !this.clobClient) {
      const chainId = (this.config?.chainId || POLYGON_MAINNET) as Chain;

      if (this.config?.privateKey) {
        // Authenticated client
        const wallet = new Wallet(this.config.privateKey);
        this.clobClient = new ClobClient(CLOB_HOST, chainId, wallet);
      } else {
        // Read-only client (no auth needed for market data)
        this.clobClient = new ClobClient(CLOB_HOST, chainId);
      }
      this.initialized = true;
    }
    return this.clobClient!;
  }

  // ============================================================================
  // CLOB Market Data Methods
  // ============================================================================

  /**
   * Get market from CLOB by condition ID
   */
  async getClobMarket(conditionId: string): Promise<Market | null> {
    const cacheKey = `clob:market:${conditionId}`;
    return this.cache.getOrSet(cacheKey, CACHE_TTL.MARKET_INFO, async () => {
      const client = await this.ensureInitialized();
      return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
        try {
          const market = await client.getMarket(conditionId);
          if (!market || !market.tokens) {
            return null;
          }
          return this.normalizeClobMarket(market as ClobMarket);
        } catch (error) {
          // Handle 404 "market not found" gracefully
          if (error && typeof error === 'object' && 'status' in error && (error as { status: number }).status === 404) {
            return null;
          }
          throw error;
        }
      });
    });
  }

  /**
   * Resolve market tokens from CLOB API
   *
   * This method fetches the actual token IDs from the CLOB API,
   * which are different from the calculated positionIds in standard CTF.
   *
   * ## Why This Method Exists
   *
   * Polymarket CLOB markets use custom ERC-1155 token IDs that are different
   * from the standard CTF calculated positionIds:
   *
   * ```
   * Standard CTF:  positionId = keccak256(USDC + keccak256(0x0 + conditionId + indexSet))
   * Polymarket:    tokenId = custom value from CLOB API (e.g., "25064375110792...")
   * ```
   *
   * This method provides the actual tokenIds needed for CTF operations
   * (split, merge, redeem) on Polymarket markets.
   *
   * ## Usage with CTFClient
   *
   * Since CTFClient uses legacy `yesTokenId`/`noTokenId` naming,
   * you need to convert when calling CTF methods:
   *
   * ```typescript
   * const resolved = await sdk.markets.resolveMarketTokens(conditionId);
   * if (resolved) {
   *   const tokenIds = {
   *     yesTokenId: resolved.primaryTokenId,
   *     noTokenId: resolved.secondaryTokenId,
   *   };
   *   await ctfClient.redeemByTokenIds(conditionId, tokenIds);
   * }
   * ```
   *
   * @param conditionId - Market condition ID (0x...)
   * @returns Resolved token IDs with outcome names, or null if not found
   */
  async resolveMarketTokens(conditionId: string): Promise<ResolvedMarketTokens | null> {
    try {
      const market = await this.getClobMarket(conditionId);
      if (!market?.tokens?.length || market.tokens.length < 2) {
        return null;
      }

      const primary = market.tokens[0];
      const secondary = market.tokens[1];

      return {
        primaryTokenId: primary.tokenId,
        secondaryTokenId: secondary.tokenId,
        outcomes: [primary.outcome, secondary.outcome],
        primaryOutcome: primary.outcome,
        secondaryOutcome: secondary.outcome,
      };
    } catch {
      return null;
    }
  }

  /**
   * Get multiple markets from CLOB
   */
  async getClobMarkets(nextCursor?: string): Promise<{ markets: Market[]; nextCursor: string }> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const result = await client.getMarkets(nextCursor);
      return {
        markets: (result.data as ClobMarket[]).map(m => this.normalizeClobMarket(m)),
        nextCursor: result.next_cursor,
      };
    });
  }

  /**
   * Get orderbook for a single token
   */
  async getTokenOrderbook(tokenId: string): Promise<Orderbook> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const book = await client.getOrderBook(tokenId) as OrderBookSummary;

      const bids = (book.bids || [])
        .map((l: { price: string; size: string }) => ({
          price: parseFloat(l.price),
          size: parseFloat(l.size),
        }))
        .sort((a, b) => b.price - a.price);

      const asks = (book.asks || [])
        .map((l: { price: string; size: string }) => ({
          price: parseFloat(l.price),
          size: parseFloat(l.size),
        }))
        .sort((a, b) => a.price - b.price);

      return {
        tokenId: book.asset_id,
        assetId: book.asset_id, // Backward compatibility
        bids,
        asks,
        timestamp: parseInt(book.timestamp || '0', 10) || Date.now(),
        market: book.market,
        hash: book.hash,
      };
    });
  }

  /**
   * Get orderbooks for multiple tokens
   */
  async getTokenOrderbooks(
    params: Array<{ tokenId: string; side: Side }>
  ): Promise<Map<string, Orderbook>> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const bookParams = params.map(p => ({
        token_id: p.tokenId,
        side: p.side === 'BUY' ? ClobSide.BUY : ClobSide.SELL,
      }));
      const books = await client.getOrderBooks(bookParams);
      const result = new Map<string, Orderbook>();

      for (const book of books) {
        const bids = (book.bids || [])
          .map((l: { price: string; size: string }) => ({
            price: parseFloat(l.price),
            size: parseFloat(l.size),
          }))
          .sort((a, b) => b.price - a.price);

        const asks = (book.asks || [])
          .map((l: { price: string; size: string }) => ({
            price: parseFloat(l.price),
            size: parseFloat(l.size),
          }))
          .sort((a, b) => a.price - b.price);

        result.set(book.asset_id, {
          tokenId: book.asset_id,
          assetId: book.asset_id, // Backward compatibility
          bids,
          asks,
          timestamp: parseInt(book.timestamp || '0', 10) || Date.now(),
          market: book.market,
          hash: book.hash,
        });
      }

      return result;
    });
  }

  /**
   * Get processed orderbook with arbitrage analysis for a market
   */
  async getProcessedOrderbook(conditionId: string): Promise<ProcessedOrderbook> {
    const market = await this.getClobMarket(conditionId);
    if (!market) {
      throw new PolymarketError(ErrorCode.MARKET_NOT_FOUND, `Market not found: ${conditionId}`);
    }
    // Use index-based access instead of name-based (supports Yes/No, Up/Down, Team1/Team2, etc.)
    const yesToken = market.tokens[0];  // primary outcome
    const noToken = market.tokens[1];   // secondary outcome

    if (!yesToken || !noToken) {
      throw new PolymarketError(ErrorCode.INVALID_RESPONSE, 'Missing tokens in market');
    }

    const [yesBook, noBook] = await Promise.all([
      this.getTokenOrderbook(yesToken.tokenId),
      this.getTokenOrderbook(noToken.tokenId),
    ]);

    return this.processOrderbooks(yesBook, noBook, yesToken.tokenId, noToken.tokenId);
  }

  /**
   * Get price history for a token
   */
  async getPricesHistory(params: PriceHistoryParams): Promise<PricePoint[]> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const intervalMap: Record<PriceHistoryIntervalString, PriceHistoryInterval> = {
        '1h': PriceHistoryInterval.ONE_HOUR,
        '6h': PriceHistoryInterval.SIX_HOURS,
        '1d': PriceHistoryInterval.ONE_DAY,
        '1w': PriceHistoryInterval.ONE_WEEK,
        'max': PriceHistoryInterval.MAX,
      };

      const history = await client.getPricesHistory({
        market: params.tokenId,
        interval: params.interval ? intervalMap[params.interval] : undefined,
        startTs: params.startTs,
        endTs: params.endTs,
        fidelity: params.fidelity,
      });

      const historyArray = Array.isArray(history)
        ? history
        : (history as { history?: Array<{ t: number; p: number }> })?.history || [];

      return historyArray.map((pt: { t: number; p: number }) => ({
        timestamp: pt.t,
        price: pt.p,
      }));
    });
  }

  /**
   * Get midpoint price for a token
   */
  async getMidpoint(tokenId: string): Promise<number> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const midpoint = await client.getMidpoint(tokenId);
      return Number(midpoint);
    });
  }

  /**
   * Get spread for a token
   */
  async getSpread(tokenId: string): Promise<number> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const spread = await client.getSpread(tokenId);
      return Number(spread);
    });
  }

  /**
   * Get last trade price for a token
   */
  async getLastTradePrice(tokenId: string): Promise<number> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const price = await client.getLastTradePrice(tokenId);
      return Number(price);
    });
  }

  // ============================================================================
  // Unified Market Access
  // ============================================================================

  /**
   * Get market by slug or condition ID
   */
  async getMarket(identifier: string): Promise<UnifiedMarket> {
    const isConditionId = identifier.startsWith('0x') || /^\d+$/.test(identifier);

    if (isConditionId) {
      return this.getMarketByConditionId(identifier);
    } else {
      return this.getMarketBySlug(identifier);
    }
  }

  private async getMarketBySlug(slug: string): Promise<UnifiedMarket> {
    if (!this.gammaApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'GammaApiClient is required for slug-based lookups');
    }
    const gammaMarket = await this.gammaApi.getMarketBySlug(slug);
    if (!gammaMarket) {
      throw new PolymarketError(ErrorCode.MARKET_NOT_FOUND, `Market not found: ${slug}`);
    }

    try {
      const clobMarket = await this.getClobMarket(gammaMarket.conditionId);
      if (clobMarket) {
        return this.mergeMarkets(gammaMarket, clobMarket);
      }
      return this.fromGammaMarket(gammaMarket);
    } catch {
      return this.fromGammaMarket(gammaMarket);
    }
  }

  private async getMarketByConditionId(conditionId: string): Promise<UnifiedMarket> {
    // Try to get data from both sources for best accuracy
    let clobMarket: Market | null = null;
    let gammaMarket: GammaMarket | null = null;

    // Try CLOB first (authoritative for trading data)
    try {
      clobMarket = await this.getClobMarket(conditionId);
    } catch {
      // CLOB failed, continue to try Gamma
    }

    // Always try Gamma for accurate slug and metadata (if available)
    if (this.gammaApi) {
      try {
        gammaMarket = await this.gammaApi.getMarketByConditionId(conditionId);
      } catch {
        // Gamma failed
      }
    }

    // Merge if both available (preferred)
    if (gammaMarket && clobMarket) {
      return this.mergeMarkets(gammaMarket, clobMarket);
    }

    // Gamma only - still useful for metadata
    if (gammaMarket) {
      return this.fromGammaMarket(gammaMarket);
    }

    // CLOB only - slug might be stale, add warning
    if (clobMarket) {
      const market = this.fromClobMarket(clobMarket);
      // Check if slug looks stale (doesn't match question keywords)
      const questionWords = clobMarket.question.toLowerCase().split(/\s+/).slice(0, 3);
      const slugWords = clobMarket.marketSlug.toLowerCase().split('-');
      const hasMatchingWord = questionWords.some(qw =>
        slugWords.some(sw => sw.includes(qw) || qw.includes(sw))
      );
      if (!hasMatchingWord && clobMarket.marketSlug.length > 0) {
        // Slug appears stale, use conditionId as fallback identifier
        market.slug = `market-${conditionId.slice(0, 10)}`;
      }
      return market;
    }

    throw new PolymarketError(ErrorCode.MARKET_NOT_FOUND, `Market not found: ${conditionId}`);
  }

  // ===== K-Line Aggregation =====

  /**
   * Get K-Line candles for a market (single token)
   *
   * @param conditionId - Market condition ID
   * @param interval - K-line interval (1s, 5s, 15s, 30s, 1m, 5m, 15m, 30m, 1h, 4h, 12h, 1d)
   * @param options - Query options
   * @param options.limit - Maximum number of trades to fetch for aggregation (default: 1000)
   * @param options.tokenId - Filter by specific token ID
   * @param options.outcomeIndex - Filter by outcome index (0 = primary, 1 = secondary)
   * @param options.startTimestamp - Start timestamp (Unix ms) - filter trades after this time
   * @param options.endTimestamp - End timestamp (Unix ms) - filter trades before this time
   *
   * @example
   * ```typescript
   * // Get 5s candles for the last 15 minutes
   * const now = Date.now();
   * const candles = await sdk.markets.getKLines(conditionId, '5s', {
   *   startTimestamp: now - 15 * 60 * 1000,
   *   endTimestamp: now,
   * });
   * ```
   */
  async getKLines(
    conditionId: string,
    interval: KLineInterval,
    options?: {
      limit?: number;
      tokenId?: string;
      outcomeIndex?: number;
      startTimestamp?: number;
      endTimestamp?: number;
    }
  ): Promise<KLineCandle[]> {
    if (!this.dataApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'DataApiClient is required for K-Line data');
    }
    const trades = await this.dataApi.getTrades({
      market: conditionId,
      limit: options?.limit || 1000,
      startTimestamp: options?.startTimestamp,
      endTimestamp: options?.endTimestamp,
    });

    // Filter by token/outcome if specified
    let filteredTrades = trades;
    if (options?.tokenId) {
      filteredTrades = trades.filter((t) => t.asset === options.tokenId);
    } else if (options?.outcomeIndex !== undefined) {
      filteredTrades = trades.filter((t) => t.outcomeIndex === options.outcomeIndex);
    }

    return this.aggregateToKLines(filteredTrades, interval);
  }

  /**
   * Get dual K-Lines (YES + NO tokens)
   *
   * @param conditionId - Market condition ID
   * @param interval - K-line interval (1s, 5s, 15s, 30s, 1m, 5m, 15m, 30m, 1h, 4h, 12h, 1d)
   * @param options - Query options
   * @param options.limit - Maximum number of trades to fetch for aggregation (default: 1000)
   * @param options.startTimestamp - Start timestamp (Unix ms) - filter trades after this time
   * @param options.endTimestamp - End timestamp (Unix ms) - filter trades before this time
   *
   * @example
   * ```typescript
   * // Get 15s dual K-lines for a 15-minute market
   * const now = Date.now();
   * const data = await sdk.markets.getDualKLines(conditionId, '15s', {
   *   startTimestamp: now - 15 * 60 * 1000,
   *   endTimestamp: now,
   * });
   * console.log(`Up candles: ${data.yes.length}, Down candles: ${data.no.length}`);
   * ```
   */
  async getDualKLines(
    conditionId: string,
    interval: KLineInterval,
    options?: {
      limit?: number;
      startTimestamp?: number;
      endTimestamp?: number;
    }
  ): Promise<DualKLineData> {
    if (!this.dataApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'DataApiClient is required for K-Line data');
    }
    const market = await this.getMarket(conditionId);
    const trades = await this.dataApi.getTrades({
      market: conditionId,
      limit: options?.limit || 1000,
      startTimestamp: options?.startTimestamp,
      endTimestamp: options?.endTimestamp,
    });

    // Separate trades by outcome using index (more reliable than name matching)
    // outcomeIndex 0 = primary (Yes/Up/Team1), outcomeIndex 1 = secondary (No/Down/Team2)
    const yesTrades = trades.filter((t) => t.outcomeIndex === 0);
    const noTrades = trades.filter((t) => t.outcomeIndex === 1);

    const yesCandles = this.aggregateToKLines(yesTrades, interval);
    const noCandles = this.aggregateToKLines(noTrades, interval);

    // Get current orderbook for real-time spread analysis
    let currentOrderbook: ProcessedOrderbook | undefined;
    let realtimeSpread: RealtimeSpreadAnalysis | undefined;
    try {
      currentOrderbook = await this.getProcessedOrderbook(conditionId);
      realtimeSpread = this.calculateRealtimeSpread(currentOrderbook);
    } catch {
      // Orderbook not available
    }

    // Calculate historical spread from trade close prices (for backtesting)
    const spreadAnalysis = this.analyzeHistoricalSpread(yesCandles, noCandles);

    return {
      conditionId,
      interval,
      market,
      yes: yesCandles,
      no: noCandles,
      spreadAnalysis,      // Historical (trade-based)
      realtimeSpread,      // Real-time (orderbook-based)
      currentOrderbook,
    };
  }

  // ===== Token vs Underlying Correlation =====

  /**
   * Get aligned K-line data for token and underlying asset
   *
   * This method fetches K-line data from both Polymarket (token prices)
   * and Binance (underlying asset prices), aligns them by timestamp,
   * and optionally calculates Pearson correlation coefficients.
   *
   * @param conditionId - Market condition ID
   * @param underlying - Underlying asset (BTC, ETH, SOL)
   * @param interval - K-line interval (must be supported by both Poly and Binance)
   * @param options - Optional parameters
   * @returns Aligned data with optional correlation coefficients
   *
   * @example
   * ```typescript
   * const data = await marketService.getTokenUnderlyingData(
   *   '0x123...',
   *   'BTC',
   *   '1h',
   *   { limit: 100, calculateCorrelation: true }
   * );
   *
   * // Access aligned data
   * for (const point of data.data) {
   *   console.log(`${point.timestamp}: Up=${point.upPrice}, BTC=${point.underlyingPrice}`);
   * }
   *
   * // Check correlation
   * if (data.correlation) {
   *   console.log(`Correlation: ${data.correlation.upVsUnderlying}`);
   * }
   * ```
   */
  async getTokenUnderlyingData(
    conditionId: string,
    underlying: UnderlyingAsset,
    interval: KLineInterval,
    options?: {
      limit?: number;
      calculateCorrelation?: boolean;
    }
  ): Promise<TokenUnderlyingCorrelation> {
    // Validate BinanceService is available
    if (!this.binanceService) {
      throw new PolymarketError(
        ErrorCode.INVALID_CONFIG,
        'BinanceService is required for token-underlying correlation analysis'
      );
    }

    // Validate interval is supported by Binance
    const binanceInterval = KLINE_TO_BINANCE_INTERVAL[interval];
    if (!binanceInterval) {
      throw new PolymarketError(
        ErrorCode.INVALID_CONFIG,
        `Interval ${interval} is not supported for correlation analysis. ` +
        `Supported intervals: ${Object.keys(KLINE_TO_BINANCE_INTERVAL).join(', ')}`
      );
    }

    const limit = options?.limit || 500;

    // Fetch data in parallel
    const [dualKLines, binanceKLines] = await Promise.all([
      this.getDualKLines(conditionId, interval, { limit }),
      this.binanceService.getKLines(
        UNDERLYING_TO_SYMBOL[underlying],
        binanceInterval,
        { limit }
      ),
    ]);

    // Create maps for quick lookup
    const upMap = new Map(dualKLines.yes.map(c => [c.timestamp, c.close]));
    const downMap = new Map(dualKLines.no.map(c => [c.timestamp, c.close]));
    const binanceMap = new Map(binanceKLines.map(c => [c.timestamp, c.close]));

    // Get all unique timestamps and sort them
    const allTimestamps = new Set([
      ...upMap.keys(),
      ...downMap.keys(),
      ...binanceMap.keys(),
    ]);
    const sortedTimestamps = [...allTimestamps].sort((a, b) => a - b);

    // Find the first Binance price for calculating percentage change
    const firstBinancePrice = binanceKLines.length > 0 ? binanceKLines[0].close : 0;

    // Align data points
    const alignedData: TokenUnderlyingDataPoint[] = [];
    let lastUpPrice: number | undefined;
    let lastDownPrice: number | undefined;
    let lastBinancePrice: number | undefined;

    for (const timestamp of sortedTimestamps) {
      // Get prices, falling back to previous values if not available
      const upPrice = upMap.get(timestamp) ?? this.findNearestPrice(timestamp, upMap, sortedTimestamps);
      const downPrice = downMap.get(timestamp) ?? this.findNearestPrice(timestamp, downMap, sortedTimestamps);
      const binancePrice = binanceMap.get(timestamp) ?? this.findNearestPrice(timestamp, binanceMap, sortedTimestamps);

      // Update last known prices
      if (upPrice !== undefined) lastUpPrice = upPrice;
      if (downPrice !== undefined) lastDownPrice = downPrice;
      if (binancePrice !== undefined) lastBinancePrice = binancePrice;

      // Skip if we don't have underlying price
      if (lastBinancePrice === undefined) continue;

      const priceSum = (lastUpPrice !== undefined && lastDownPrice !== undefined)
        ? lastUpPrice + lastDownPrice
        : undefined;

      const underlyingChange = firstBinancePrice > 0
        ? ((lastBinancePrice - firstBinancePrice) / firstBinancePrice) * 100
        : 0;

      alignedData.push({
        timestamp,
        upPrice: lastUpPrice,
        downPrice: lastDownPrice,
        priceSum,
        underlyingPrice: lastBinancePrice,
        underlyingChange,
      });
    }

    // Calculate correlation if requested
    let correlation: TokenUnderlyingCorrelation['correlation'];
    if (options?.calculateCorrelation && alignedData.length >= 2) {
      correlation = this.calculatePearsonCorrelation(alignedData);
    }

    return {
      conditionId,
      underlying,
      interval,
      data: alignedData,
      correlation,
    };
  }

  /**
   * Find the nearest available price for a timestamp
   */
  private findNearestPrice(
    targetTimestamp: number,
    priceMap: Map<number, number>,
    sortedTimestamps: number[]
  ): number | undefined {
    if (priceMap.size === 0) return undefined;

    // Find the nearest timestamp that has a price
    let nearestTimestamp: number | undefined;
    let minDiff = Infinity;

    for (const ts of sortedTimestamps) {
      if (priceMap.has(ts)) {
        const diff = Math.abs(ts - targetTimestamp);
        if (diff < minDiff) {
          minDiff = diff;
          nearestTimestamp = ts;
        }
      }
    }

    return nearestTimestamp !== undefined ? priceMap.get(nearestTimestamp) : undefined;
  }

  /**
   * Calculate Pearson correlation coefficients
   */
  private calculatePearsonCorrelation(
    data: TokenUnderlyingDataPoint[]
  ): TokenUnderlyingCorrelation['correlation'] {
    // Filter data points that have all required prices
    const upData = data.filter(d => d.upPrice !== undefined && d.underlyingPrice !== undefined);
    const downData = data.filter(d => d.downPrice !== undefined && d.underlyingPrice !== undefined);

    const upVsUnderlying = this.pearson(
      upData.map(d => d.upPrice!),
      upData.map(d => d.underlyingPrice)
    );

    const downVsUnderlying = this.pearson(
      downData.map(d => d.downPrice!),
      downData.map(d => d.underlyingPrice)
    );

    return {
      upVsUnderlying,
      downVsUnderlying,
    };
  }

  /**
   * Calculate Pearson correlation coefficient between two arrays
   * Returns a value between -1 and 1
   */
  private pearson(x: number[], y: number[]): number {
    const n = Math.min(x.length, y.length);
    if (n < 2) return 0;

    // Calculate means
    let sumX = 0, sumY = 0;
    for (let i = 0; i < n; i++) {
      sumX += x[i];
      sumY += y[i];
    }
    const meanX = sumX / n;
    const meanY = sumY / n;

    // Calculate correlation
    let numerator = 0;
    let sumSqX = 0;
    let sumSqY = 0;

    for (let i = 0; i < n; i++) {
      const dx = x[i] - meanX;
      const dy = y[i] - meanY;
      numerator += dx * dy;
      sumSqX += dx * dx;
      sumSqY += dy * dy;
    }

    const denominator = Math.sqrt(sumSqX * sumSqY);
    if (denominator === 0) return 0;

    return numerator / denominator;
  }

  /**
   * Aggregate trades into K-Line candles
   *
   * Note: Polymarket API may return timestamps in seconds or milliseconds.
   * This function normalizes all timestamps to milliseconds for consistent handling.
   */
  private aggregateToKLines(trades: Trade[], interval: KLineInterval): KLineCandle[] {
    const intervalMs = getIntervalMs(interval);
    const buckets = new Map<number, Trade[]>();

    // Group trades into time buckets
    // Normalize timestamp to milliseconds (API sometimes returns seconds)
    for (const trade of trades) {
      const tradeTs = normalizeTimestamp(trade.timestamp);
      const bucketTime = Math.floor(tradeTs / intervalMs) * intervalMs;
      const bucket = buckets.get(bucketTime) || [];
      bucket.push(trade);
      buckets.set(bucketTime, bucket);
    }

    // Convert buckets to candles
    const candles: KLineCandle[] = [];
    for (const [timestamp, bucketTrades] of buckets) {
      if (bucketTrades.length === 0) continue;

      // Sort by normalized timestamp for correct open/close
      bucketTrades.sort((a, b) => normalizeTimestamp(a.timestamp) - normalizeTimestamp(b.timestamp));

      const prices = bucketTrades.map((t) => t.price);
      const buyTrades = bucketTrades.filter((t) => t.side === 'BUY');
      const sellTrades = bucketTrades.filter((t) => t.side === 'SELL');

      candles.push({
        timestamp,
        open: bucketTrades[0].price,
        high: Math.max(...prices),
        low: Math.min(...prices),
        close: bucketTrades[bucketTrades.length - 1].price,
        volume: bucketTrades.reduce((sum, t) => sum + t.size * t.price, 0),
        tradeCount: bucketTrades.length,
        buyVolume: buyTrades.reduce((sum, t) => sum + t.size * t.price, 0),
        sellVolume: sellTrades.reduce((sum, t) => sum + t.size * t.price, 0),
      });
    }

    return candles.sort((a, b) => a.timestamp - b.timestamp);
  }

  /**
   * Analyze historical spread from trade close prices (for backtesting)
   *
   * This uses trade close prices, not orderbook bid/ask.
   * Useful for:
   * - Historical analysis / backtesting
   * - Understanding past price movements
   * - Identifying patterns when orderbook data unavailable
   */
  private analyzeHistoricalSpread(
    yesCandles: KLineCandle[],
    noCandles: KLineCandle[]
  ): SpreadDataPoint[] {
    const yesMap = new Map(yesCandles.map((c) => [c.timestamp, c]));
    const noMap = new Map(noCandles.map((c) => [c.timestamp, c]));

    const allTimestamps = [...new Set([...yesMap.keys(), ...noMap.keys()])].sort();

    let lastYes = 0.5;
    let lastNo = 0.5;
    const analysis: SpreadDataPoint[] = [];

    for (const ts of allTimestamps) {
      const yesCandle = yesMap.get(ts);
      const noCandle = noMap.get(ts);

      if (yesCandle) lastYes = yesCandle.close;
      if (noCandle) lastNo = noCandle.close;

      const priceSum = lastYes + lastNo;
      const priceSpread = priceSum - 1;

      // Determine arb opportunity based on price deviation
      // Note: This is indicative only - actual arb requires orderbook analysis
      let arbOpportunity: 'LONG' | 'SHORT' | '' = '';
      if (priceSpread < -0.005) arbOpportunity = 'LONG';   // Sum < 0.995
      else if (priceSpread > 0.005) arbOpportunity = 'SHORT'; // Sum > 1.005

      analysis.push({
        timestamp: ts,
        yesPrice: lastYes,
        noPrice: lastNo,
        priceSum,
        priceSpread,
        arbOpportunity,
      });
    }

    return analysis;
  }

  /**
   * Calculate real-time spread from orderbook (for live trading)
   *
   * This uses orderbook bid/ask prices for accurate arbitrage detection.
   * Useful for:
   * - Real-time arbitrage execution
   * - Live trading decisions
   * - Accurate profit calculations
   */
  private calculateRealtimeSpread(orderbook: ProcessedOrderbook): RealtimeSpreadAnalysis {
    const { yes, no, summary } = orderbook;

    // Determine arbitrage opportunity
    let arbOpportunity: 'LONG' | 'SHORT' | '' = '';
    let arbProfitPercent = 0;

    if (summary.longArbProfit > 0.001) {  // > 0.1% threshold
      arbOpportunity = 'LONG';
      arbProfitPercent = summary.longArbProfit * 100;
    } else if (summary.shortArbProfit > 0.001) {  // > 0.1% threshold
      arbOpportunity = 'SHORT';
      arbProfitPercent = summary.shortArbProfit * 100;
    }

    return {
      timestamp: Date.now(),
      // Orderbook prices
      yesBid: yes.bid,
      yesAsk: yes.ask,
      noBid: no.bid,
      noAsk: no.ask,
      // Spread metrics
      askSum: summary.askSum,
      bidSum: summary.bidSum,
      askSpread: summary.askSum - 1,
      bidSpread: summary.bidSum - 1,
      // Arbitrage
      longArbProfit: summary.longArbProfit,
      shortArbProfit: summary.shortArbProfit,
      arbOpportunity,
      arbProfitPercent,
    };
  }

  /**
   * Get real-time spread analysis only (without K-lines)
   * Use this for quick arbitrage checks
   */
  async getRealtimeSpread(conditionId: string): Promise<RealtimeSpreadAnalysis> {
    const orderbook = await this.getProcessedOrderbook(conditionId);
    return this.calculateRealtimeSpread(orderbook);
  }

  // ===== Orderbook Analysis =====

  /**
   * Get processed orderbook with analytics (alias for getProcessedOrderbook)
   */
  async getOrderbook(conditionId: string): Promise<ProcessedOrderbook> {
    return this.getProcessedOrderbook(conditionId);
  }

  /**
   * Detect arbitrage opportunity
   *
   * 使用有效价格（考虑镜像订单）计算套利机会
   * 详细原理见: docs/01-polymarket-orderbook-arbitrage.md
   */
  async detectArbitrage(conditionId: string, threshold = 0.005): Promise<ArbitrageOpportunity | null> {
    const orderbook = await this.getOrderbook(conditionId);
    const { effectivePrices } = orderbook.summary;

    if (orderbook.summary.longArbProfit > threshold) {
      return {
        type: 'long',
        profit: orderbook.summary.longArbProfit,
        // 使用有效价格描述实际操作
        action: `Buy YES @ ${effectivePrices.effectiveBuyYes.toFixed(4)} + NO @ ${effectivePrices.effectiveBuyNo.toFixed(4)}, Merge for $1`,
        expectedProfit: orderbook.summary.longArbProfit,
      };
    }

    if (orderbook.summary.shortArbProfit > threshold) {
      return {
        type: 'short',
        profit: orderbook.summary.shortArbProfit,
        // 使用有效价格描述实际操作
        action: `Split $1, Sell YES @ ${effectivePrices.effectiveSellYes.toFixed(4)} + NO @ ${effectivePrices.effectiveSellNo.toFixed(4)}`,
        expectedProfit: orderbook.summary.shortArbProfit,
      };
    }

    return null;
  }

  // ===== Market Discovery =====

  /**
   * Get trending markets
   */
  async getTrendingMarkets(limit = 20): Promise<GammaMarket[]> {
    if (!this.gammaApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'GammaApiClient is required for trending markets');
    }
    return this.gammaApi.getTrendingMarkets(limit);
  }

  /**
   * Search markets
   */
  async searchMarkets(params: {
    active?: boolean;
    closed?: boolean;
    limit?: number;
    offset?: number;
    order?: string;
  }): Promise<GammaMarket[]> {
    if (!this.gammaApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'GammaApiClient is required for market search');
    }
    return this.gammaApi.getMarkets(params);
  }

  /**
   * Scan for short-term crypto markets (Up/Down markets ending soon)
   *
   * ## Market Types
   * Polymarket has short-term crypto markets in two durations:
   * - **5-minute markets**: slug pattern `{coin}-updown-5m-{timestamp}`
   * - **15-minute markets**: slug pattern `{coin}-updown-15m-{timestamp}`
   *
   * ## Slug Pattern
   * The timestamp in the slug is the START time of the time window:
   * - 15-minute markets: `{coin}-updown-15m-{Math.floor(startTime / 900) * 900}`
   * - 5-minute markets: `{coin}-updown-5m-{Math.floor(startTime / 300) * 300}`
   *
   * Example: `btc-updown-15m-1767456000` starts at 1767456000 (16:00:00 UTC)
   * and ends 15 minutes later at 1767456900 (16:15:00 UTC)
   *
   * ## Supported Coins
   * - BTC (Bitcoin)
   * - ETH (Ethereum)
   * - SOL (Solana)
   * - XRP (Ripple)
   *
   * ## Market Lifecycle Rules
   * 1. Markets are created ahead of time (before they become tradeable)
   * 2. New markets may not have prices yet (show 0.5/0.5)
   * 3. When one market ends, the next one is already open for trading
   * 4. A market ending doesn't mean no price - it means resolution is pending
   *
   * ## Outcomes
   * All crypto short-term markets have:
   * - outcomes: ["Up", "Down"]
   * - Resolution based on price movement during the time window
   *
   * @param options - Scan options
   * @param options.minMinutesUntilEnd - Minimum minutes until market ends (default: 5)
   * @param options.maxMinutesUntilEnd - Maximum minutes until market ends (default: 60)
   * @param options.limit - Maximum number of markets to return (default: 20)
   * @param options.sortBy - Sort field: 'endDate' | 'volume' | 'liquidity' (default: 'endDate')
   * @param options.duration - Filter by duration: '5m' | '15m' | 'all' (default: 'all')
   * @param options.coin - Filter by coin: 'BTC' | 'ETH' | 'SOL' | 'XRP' | 'all' (default: 'all')
   * @returns Array of crypto short-term markets
   *
   * @example
   * ```typescript
   * // Find all 15-minute markets ending in 5-30 minutes
   * const markets = await sdk.markets.scanCryptoShortTermMarkets({
   *   minMinutesUntilEnd: 5,
   *   maxMinutesUntilEnd: 30,
   *   duration: '15m',
   * });
   *
   * // Find BTC 5-minute markets only
   * const btcMarkets = await sdk.markets.scanCryptoShortTermMarkets({
   *   coin: 'BTC',
   *   duration: '5m',
   * });
   * ```
   */
  async scanCryptoShortTermMarkets(options?: {
    minMinutesUntilEnd?: number;
    maxMinutesUntilEnd?: number;
    limit?: number;
    sortBy?: 'endDate' | 'volume' | 'liquidity';
    duration?: '5m' | '15m' | 'all';
    coin?: 'BTC' | 'ETH' | 'SOL' | 'XRP' | 'all';
  }): Promise<GammaMarket[]> {
    if (!this.gammaApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'GammaApiClient is required for market scanning');
    }

    const {
      minMinutesUntilEnd = 5,
      maxMinutesUntilEnd = 60,
      limit = 20,
      sortBy = 'endDate',
      duration = 'all',
      coin = 'all',
    } = options ?? {};

    // Duration to interval seconds mapping
    const durationIntervals: Record<string, number> = {
      '5m': 300,   // 5 minutes in seconds
      '15m': 900,  // 15 minutes in seconds
    };

    // Supported coins
    const allCoins = ['btc', 'eth', 'sol', 'xrp'] as const;
    const targetCoins = coin === 'all' ? allCoins : [coin.toLowerCase()];

    // Target durations
    const targetDurations = duration === 'all' ? ['5m', '15m'] : [duration];

    // Calculate time slots to fetch
    const nowSeconds = Math.floor(Date.now() / 1000);
    const minEndSeconds = nowSeconds + minMinutesUntilEnd * 60;
    const maxEndSeconds = nowSeconds + maxMinutesUntilEnd * 60;

    // Generate slugs for all combinations
    const slugsToFetch: string[] = [];

    for (const dur of targetDurations) {
      const intervalSeconds = durationIntervals[dur];
      const durationStr = dur.replace('m', 'm'); // 5m or 15m

      // Calculate the current slot and extend to cover the time range
      // The slug timestamp is the START time, endTime = startTime + interval
      // So if we want markets ending after minEndSeconds:
      //   startTime + interval >= minEndSeconds => startTime >= minEndSeconds - interval
      // And ending before maxEndSeconds:
      //   startTime + interval <= maxEndSeconds => startTime <= maxEndSeconds - interval

      const minSlotStart = Math.floor((minEndSeconds - intervalSeconds) / intervalSeconds) * intervalSeconds;
      const maxSlotStart = Math.ceil(maxEndSeconds / intervalSeconds) * intervalSeconds;

      // Generate slots from minSlotStart to maxSlotStart
      for (let slotStart = minSlotStart; slotStart <= maxSlotStart; slotStart += intervalSeconds) {
        for (const coinName of targetCoins) {
          slugsToFetch.push(`${coinName}-updown-${durationStr}-${slotStart}`);
        }
      }
    }

    // Fetch markets in parallel batches
    const BATCH_SIZE = 10;
    const allMarkets: GammaMarket[] = [];

    for (let i = 0; i < slugsToFetch.length; i += BATCH_SIZE) {
      const batch = slugsToFetch.slice(i, i + BATCH_SIZE);
      const results = await Promise.all(
        batch.map(async (slug) => {
          try {
            const markets = await this.gammaApi!.getMarkets({ slug, limit: 1 });
            return markets.length > 0 ? markets[0] : null;
          } catch {
            return null;
          }
        })
      );

      for (const market of results) {
        if (market && market.active && !market.closed) {
          allMarkets.push(market);
        }
      }
    }

    // Filter by end time range
    const nowMs = Date.now();
    const minEndTime = nowMs + minMinutesUntilEnd * 60 * 1000;
    const maxEndTime = nowMs + maxMinutesUntilEnd * 60 * 1000;

    const filteredMarkets = allMarkets.filter((market) => {
      const endTime = market.endDate ? new Date(market.endDate).getTime() : 0;
      return endTime >= minEndTime && endTime <= maxEndTime;
    });

    // Sort by preference
    if (sortBy === 'volume') {
      filteredMarkets.sort((a, b) => (b.volume24hr ?? 0) - (a.volume24hr ?? 0));
    } else if (sortBy === 'liquidity') {
      filteredMarkets.sort((a, b) => (b.liquidity ?? 0) - (a.liquidity ?? 0));
    } else {
      // Sort by endDate (soonest first)
      filteredMarkets.sort((a, b) => {
        const aEnd = a.endDate ? new Date(a.endDate).getTime() : Infinity;
        const bEnd = b.endDate ? new Date(b.endDate).getTime() : Infinity;
        return aEnd - bEnd;
      });
    }

    return filteredMarkets.slice(0, limit);
  }

  // ===== Market Signal Detection =====

  /**
   * Detect market signals (volume surge, depth imbalance, whale trades)
   */
  async detectMarketSignals(conditionId: string): Promise<
    Array<{
      type: 'volume_surge' | 'depth_imbalance' | 'whale_trade' | 'momentum';
      severity: 'low' | 'medium' | 'high';
      details: Record<string, unknown>;
    }>
  > {
    const signals: Array<{
      type: 'volume_surge' | 'depth_imbalance' | 'whale_trade' | 'momentum';
      severity: 'low' | 'medium' | 'high';
      details: Record<string, unknown>;
    }> = [];

    if (!this.dataApi) {
      throw new PolymarketError(ErrorCode.INVALID_CONFIG, 'DataApiClient is required for signal detection');
    }
    const market = await this.getMarket(conditionId);
    const orderbook = await this.getOrderbook(conditionId);
    const trades = await this.dataApi.getTradesByMarket(conditionId, 100);

    // Volume surge detection
    if (market.volume24hr && market.volume > 0) {
      const avgDaily = market.volume / 7; // Approximate
      const ratio = market.volume24hr / avgDaily;
      if (ratio > 2) {
        signals.push({
          type: 'volume_surge',
          severity: ratio > 5 ? 'high' : ratio > 3 ? 'medium' : 'low',
          details: { volume24hr: market.volume24hr, avgDaily, ratio },
        });
      }
    }

    // Depth imbalance detection
    if (orderbook.summary.imbalanceRatio > 1.5 || orderbook.summary.imbalanceRatio < 0.67) {
      const ratio = orderbook.summary.imbalanceRatio;
      signals.push({
        type: 'depth_imbalance',
        severity: ratio > 3 || ratio < 0.33 ? 'high' : 'medium',
        details: {
          imbalanceRatio: ratio,
          bidDepth: orderbook.summary.totalBidDepth,
          askDepth: orderbook.summary.totalAskDepth,
          direction: ratio > 1 ? 'BUY_PRESSURE' : 'SELL_PRESSURE',
        },
      });
    }

    // Whale trade detection
    const recentLargeTrades = trades.filter((t) => t.size * t.price > 1000);
    for (const trade of recentLargeTrades.slice(0, 3)) {
      const value = trade.size * trade.price;
      signals.push({
        type: 'whale_trade',
        severity: value > 10000 ? 'high' : value > 5000 ? 'medium' : 'low',
        details: {
          size: trade.size,
          price: trade.price,
          usdValue: value,
          side: trade.side,
          outcome: trade.outcome,
        },
      });
    }

    return signals;
  }

  // ===== Helper Methods =====

  private normalizeClobMarket(m: ClobMarket): Market {
    return {
      conditionId: m.condition_id,
      questionId: m.question_id,
      marketSlug: m.market_slug,
      question: m.question,
      description: m.description,
      tokens: m.tokens.map(t => ({
        tokenId: t.token_id,
        outcome: t.outcome,
        price: t.price,
        winner: t.winner,
      })),
      active: m.active,
      closed: m.closed,
      acceptingOrders: m.accepting_orders,
      endDateIso: m.end_date_iso,
      negRisk: m.neg_risk,
      minimumOrderSize: m.minimum_order_size,
      minimumTickSize: m.minimum_tick_size,
    };
  }

  private processOrderbooks(
    yesBook: Orderbook,
    noBook: Orderbook,
    yesTokenId?: string,
    noTokenId?: string
  ): ProcessedOrderbook {
    const yesBestBid = yesBook.bids[0]?.price || 0;
    const yesBestAsk = yesBook.asks[0]?.price || 1;
    const noBestBid = noBook.bids[0]?.price || 0;
    const noBestAsk = noBook.asks[0]?.price || 1;

    const yesBidDepth = yesBook.bids.reduce((sum, l) => sum + l.price * l.size, 0);
    const yesAskDepth = yesBook.asks.reduce((sum, l) => sum + l.price * l.size, 0);
    const noBidDepth = noBook.bids.reduce((sum, l) => sum + l.price * l.size, 0);
    const noAskDepth = noBook.asks.reduce((sum, l) => sum + l.price * l.size, 0);

    const askSum = yesBestAsk + noBestAsk;
    const bidSum = yesBestBid + noBestBid;

    // Effective prices (accounting for mirroring)
    const effectivePrices: EffectivePrices = {
      effectiveBuyYes: Math.min(yesBestAsk, 1 - noBestBid),
      effectiveBuyNo: Math.min(noBestAsk, 1 - yesBestBid),
      effectiveSellYes: Math.max(yesBestBid, 1 - noBestAsk),
      effectiveSellNo: Math.max(noBestBid, 1 - yesBestAsk),
    };

    const effectiveLongCost = effectivePrices.effectiveBuyYes + effectivePrices.effectiveBuyNo;
    const effectiveShortRevenue = effectivePrices.effectiveSellYes + effectivePrices.effectiveSellNo;

    const longArbProfit = 1 - effectiveLongCost;
    const shortArbProfit = effectiveShortRevenue - 1;

    const yesSpread = yesBestAsk - yesBestBid;

    return {
      yes: {
        bid: yesBestBid,
        ask: yesBestAsk,
        bidSize: yesBook.bids[0]?.size || 0,
        askSize: yesBook.asks[0]?.size || 0,
        bidDepth: yesBidDepth,
        askDepth: yesAskDepth,
        spread: yesSpread,
        tokenId: yesTokenId,
      },
      no: {
        bid: noBestBid,
        ask: noBestAsk,
        bidSize: noBook.bids[0]?.size || 0,
        askSize: noBook.asks[0]?.size || 0,
        bidDepth: noBidDepth,
        askDepth: noAskDepth,
        spread: noBestAsk - noBestBid,
        tokenId: noTokenId,
      },
      summary: {
        askSum,
        bidSum,
        effectivePrices,
        effectiveLongCost,
        effectiveShortRevenue,
        longArbProfit,
        shortArbProfit,
        totalBidDepth: yesBidDepth + noBidDepth,
        totalAskDepth: yesAskDepth + noAskDepth,
        imbalanceRatio: (yesBidDepth + noBidDepth) / (yesAskDepth + noAskDepth + 0.001),
        yesSpread,
      },
    };
  }

  private mergeMarkets(gamma: GammaMarket, clob: Market): UnifiedMarket {
    // Build tokens array from CLOB data, falling back to Gamma prices
    const tokens: UnifiedMarketToken[] = clob.tokens.map((t, index) => ({
      tokenId: t.tokenId,
      outcome: t.outcome,
      price: t.price || gamma.outcomePrices[index] || 0.5,
      winner: t.winner,
    }));

    return {
      conditionId: clob.conditionId,
      slug: gamma.slug,
      question: clob.question,
      description: clob.description || gamma.description,
      tokens,
      volume: gamma.volume,
      volume24hr: gamma.volume24hr,
      liquidity: gamma.liquidity,
      spread: gamma.spread,
      oneDayPriceChange: gamma.oneDayPriceChange,
      oneWeekPriceChange: gamma.oneWeekPriceChange,
      active: clob.active,
      closed: clob.closed,
      acceptingOrders: clob.acceptingOrders,
      endDate: clob.endDateIso ? new Date(clob.endDateIso) : new Date(),
      source: 'merged',
    };
  }

  private fromGammaMarket(gamma: GammaMarket): UnifiedMarket {
    // Create tokens from Gamma outcomes - use actual outcome names from gamma data
    // This supports Yes/No, Up/Down, Team1/Team2, Heads/Tails, etc.
    const outcomes = gamma.outcomes || ['Yes', 'No'];
    const tokens: UnifiedMarketToken[] = [
      { tokenId: '', outcome: outcomes[0], price: gamma.outcomePrices[0] || 0.5 },
      { tokenId: '', outcome: outcomes[1], price: gamma.outcomePrices[1] || 0.5 },
    ];

    return {
      conditionId: gamma.conditionId,
      slug: gamma.slug,
      question: gamma.question,
      description: gamma.description,
      tokens,
      volume: gamma.volume,
      volume24hr: gamma.volume24hr,
      liquidity: gamma.liquidity,
      spread: gamma.spread,
      oneDayPriceChange: gamma.oneDayPriceChange,
      oneWeekPriceChange: gamma.oneWeekPriceChange,
      active: gamma.active,
      closed: gamma.closed,
      acceptingOrders: !gamma.closed,
      endDate: gamma.endDate,
      source: 'gamma',
    };
  }

  private fromClobMarket(clob: Market): UnifiedMarket {
    // Convert CLOB tokens to UnifiedMarketToken format
    const tokens: UnifiedMarketToken[] = clob.tokens.map(t => ({
      tokenId: t.tokenId,
      outcome: t.outcome,
      price: t.price,
      winner: t.winner,
    }));

    return {
      conditionId: clob.conditionId,
      slug: clob.marketSlug,
      question: clob.question,
      description: clob.description,
      tokens,
      volume: 0,
      volume24hr: undefined,
      liquidity: 0,
      spread: undefined,
      active: clob.active,
      closed: clob.closed,
      acceptingOrders: clob.acceptingOrders,
      endDate: clob.endDateIso ? new Date(clob.endDateIso) : new Date(),
      source: 'clob',
    };
  }
}

// ===== Utility Functions =====

export function getIntervalMs(interval: KLineInterval): number {
  const map: Record<KLineInterval, number> = {
    // Second-level intervals (for 15-minute crypto markets)
    '1s': 1 * 1000,
    '5s': 5 * 1000,
    '15s': 15 * 1000,
    '30s': 30 * 1000,
    // Minute-level intervals
    '1m': 60 * 1000,
    '5m': 5 * 60 * 1000,
    '15m': 15 * 60 * 1000,
    '30m': 30 * 60 * 1000,
    // Hour-level intervals
    '1h': 60 * 60 * 1000,
    '4h': 4 * 60 * 60 * 1000,
    '12h': 12 * 60 * 60 * 1000,
    '1d': 24 * 60 * 60 * 1000,
  };
  return map[interval];
}

================================================================================
// File: src/services/onchain-service.ts
================================================================================
/**
 * OnchainService - Unified interface for all on-chain operations
 *
 * Consolidates:
 * - CTF operations (split, merge, redeem)
 * - Authorization (ERC20/ERC1155 approvals)
 * - Swaps (QuickSwap V3)
 *
 * This service provides a single entry point for all blockchain interactions
 * required for Polymarket trading. It shares wallet/provider configuration
 * across all underlying services.
 *
 * @example
 * ```typescript
 * const onchain = new OnchainService({
 *   privateKey: '0x...',
 *   rpcUrl: 'https://polygon-rpc.com', // optional
 * });
 *
 * // Check if ready for trading
 * const status = await onchain.checkReadyForCTF('100');
 * if (!status.ready) {
 *   // Set up approvals
 *   await onchain.approveAll();
 * }
 *
 * // Execute CTF operations
 * await onchain.split(conditionId, '100');
 * await onchain.merge(conditionId, '100');
 *
 * // Swap tokens
 * await onchain.swap('MATIC', 'USDC_E', '10');
 * ```
 */

import { ethers } from 'ethers';

// Import underlying services
import {
  CTFClient,
  type CTFConfig,
  type SplitResult,
  type MergeResult,
  type RedeemResult,
  type PositionBalance,
  type MarketResolution,
  type GasEstimate,
  type TransactionStatus,
  type TokenIds,
} from '../clients/ctf-client.js';

import {
  AuthorizationService,
  type AllowancesResult,
  type ApprovalsResult,
  type ApprovalTxResult,
} from './authorization-service.js';

import {
  SwapService,
  type SwapQuote,
  type SwapResult,
  type TokenBalance,
  type TransferResult,
  type QuoteResult,
  type PoolInfo,
} from './swap-service.js';

// ===== Types =====

export interface OnchainServiceConfig {
  /** Private key for signing transactions */
  privateKey: string;
  /** RPC URL (default: Polygon mainnet) */
  rpcUrl?: string;
  /** Chain ID (default: 137 for Polygon) */
  chainId?: number;
  /** Gas price multiplier for CTF operations (default: 1.2) */
  gasPriceMultiplier?: number;
  /** Transaction confirmation blocks (default: 1) */
  confirmations?: number;
  /** Transaction timeout in ms (default: 60000) */
  txTimeout?: number;
}

export interface ReadyStatus {
  ready: boolean;
  usdcEBalance: string;
  nativeUsdcBalance: string;
  maticBalance: string;
  tradingReady: boolean;
  issues: string[];
  suggestion?: string;
}

export interface TokenBalances {
  matic: string;
  usdc: string;
  usdcE: string;
  usdt: string;
  dai: string;
  weth: string;
  wmatic: string;
}

// Re-export types from underlying services
export type {
  SplitResult,
  MergeResult,
  RedeemResult,
  PositionBalance,
  MarketResolution,
  GasEstimate,
  TransactionStatus,
  TokenIds,
  AllowancesResult,
  ApprovalsResult,
  ApprovalTxResult,
  SwapQuote,
  SwapResult,
  TokenBalance,
  TransferResult,
  QuoteResult,
  PoolInfo,
};

// ===== OnchainService =====

/**
 * Unified service for all on-chain operations on Polymarket
 *
 * This service wraps:
 * - CTFClient: Conditional Token Framework operations (split, merge, redeem)
 * - AuthorizationService: ERC20 and ERC1155 approvals
 * - SwapService: DEX swaps on Polygon via QuickSwap V3
 *
 * All services share the same wallet and provider configuration.
 */
export class OnchainService {
  private wallet: ethers.Wallet;
  private provider: ethers.providers.JsonRpcProvider;
  private ctfClient: CTFClient;
  private authService: AuthorizationService;
  private swapService: SwapService;

  constructor(config: OnchainServiceConfig) {
    const rpcUrl = config.rpcUrl || 'https://polygon-rpc.com';

    // Create shared provider and wallet
    this.provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    this.wallet = new ethers.Wallet(config.privateKey, this.provider);

    // Initialize CTFClient with config
    const ctfConfig: CTFConfig = {
      privateKey: config.privateKey,
      rpcUrl,
      chainId: config.chainId,
      gasPriceMultiplier: config.gasPriceMultiplier,
      confirmations: config.confirmations,
      txTimeout: config.txTimeout,
    };
    this.ctfClient = new CTFClient(ctfConfig);

    // Initialize AuthorizationService with shared wallet
    this.authService = new AuthorizationService(this.wallet, {
      provider: this.provider,
    });

    // Initialize SwapService with shared wallet
    this.swapService = new SwapService(this.wallet);
  }

  // ===== Utilities =====

  /**
   * Get the wallet address
   */
  getAddress(): string {
    return this.wallet.address;
  }

  /**
   * Get native MATIC balance
   */
  async getMaticBalance(): Promise<string> {
    const balance = await this.provider.getBalance(this.wallet.address);
    return ethers.utils.formatEther(balance);
  }

  /**
   * Get all token balances
   */
  async getTokenBalances(): Promise<TokenBalances> {
    const balances = await this.swapService.getBalances();

    const findBalance = (token: string): string => {
      const entry = balances.find(b => b.token === token);
      return entry?.balance || '0';
    };

    return {
      matic: findBalance('MATIC'),
      usdc: findBalance('USDC'),
      usdcE: findBalance('USDC_E'),
      usdt: findBalance('USDT'),
      dai: findBalance('DAI'),
      weth: findBalance('WETH'),
      wmatic: findBalance('WMATIC'),
    };
  }

  // ===== Authorization =====

  /**
   * Check all ERC20 and ERC1155 allowances required for trading
   *
   * @returns Status of all allowances and whether trading is ready
   */
  async checkAllowances(): Promise<AllowancesResult> {
    return this.authService.checkAllowances();
  }

  /**
   * Set up all required approvals for trading
   *
   * @returns Results of all approval transactions
   */
  async approveAll(): Promise<ApprovalsResult> {
    return this.authService.approveAll();
  }

  /**
   * Approve USDC spending for a specific contract
   */
  async approveUsdc(
    spenderAddress: string,
    amount: ethers.BigNumber = ethers.constants.MaxUint256
  ): Promise<ApprovalTxResult> {
    return this.authService.approveUsdc(spenderAddress, amount);
  }

  /**
   * Set approval for an ERC1155 operator
   */
  async setErc1155Approval(
    operatorAddress: string,
    approved: boolean = true
  ): Promise<ApprovalTxResult> {
    return this.authService.setErc1155Approval(operatorAddress, approved);
  }

  // ===== CTF Operations =====

  /**
   * Split USDC into YES + NO tokens
   *
   * @param conditionId - Market condition ID
   * @param amount - USDC amount (e.g., "100" for 100 USDC)
   * @returns SplitResult with transaction details
   */
  async split(conditionId: string, amount: string): Promise<SplitResult> {
    return this.ctfClient.split(conditionId, amount);
  }

  /**
   * Merge YES + NO tokens back to USDC
   *
   * @param conditionId - Market condition ID
   * @param amount - Number of token pairs to merge
   * @returns MergeResult with transaction details
   */
  async merge(conditionId: string, amount: string): Promise<MergeResult> {
    return this.ctfClient.merge(conditionId, amount);
  }

  /**
   * Merge YES and NO tokens using explicit token IDs
   *
   * Use this for Polymarket CLOB markets where token IDs
   * don't match the calculated position IDs.
   */
  async mergeByTokenIds(
    conditionId: string,
    tokenIds: TokenIds,
    amount: string
  ): Promise<MergeResult> {
    return this.ctfClient.mergeByTokenIds(conditionId, tokenIds, amount);
  }

  /**
   * Redeem winning tokens after market resolution (Standard CTF)
   *
   * WARNING: Use redeemByTokenIds for Polymarket CLOB markets.
   *
   * @param conditionId - Market condition ID
   * @param outcome - Optional: Specific outcome to redeem (e.g., "YES", "UP", "TEAM A")
   */
  async redeem(conditionId: string, outcome?: string): Promise<RedeemResult> {
    return this.ctfClient.redeem(conditionId, outcome);
  }

  /**
   * Redeem winning tokens using Polymarket token IDs (Polymarket CLOB)
   *
   * This is the correct method for Polymarket CLOB markets.
   * Supports dynamic outcome names (YES/NO, UP/DOWN, TEAM A/B, etc.)
   *
   * @param conditionId - Market condition ID
   * @param tokenIds - Token IDs for primary and secondary outcomes
   * @param outcome - Optional: Specific outcome to redeem (e.g., "YES", "UP", "TEAM A")
   */
  async redeemByTokenIds(
    conditionId: string,
    tokenIds: TokenIds,
    outcome?: string
  ): Promise<RedeemResult> {
    return this.ctfClient.redeemByTokenIds(conditionId, tokenIds, outcome);
  }

  // ===== Balances =====

  /**
   * Get USDC.e (bridged USDC) balance - the token used by Polymarket CTF
   */
  async getUsdcBalance(): Promise<string> {
    return this.ctfClient.getUsdcBalance();
  }

  /**
   * Get native USDC balance (not compatible with CTF)
   */
  async getNativeUsdcBalance(): Promise<string> {
    return this.ctfClient.getNativeUsdcBalance();
  }

  /**
   * Get token balances for a market using calculated position IDs
   *
   * @deprecated Use getPositionBalanceByTokenIds for CLOB markets
   */
  async getPositionBalance(conditionId: string): Promise<PositionBalance> {
    return this.ctfClient.getPositionBalance(conditionId);
  }

  /**
   * Get token balances using CLOB API token IDs
   *
   * This is the recommended method for checking balances when working with
   * Polymarket CLOB markets.
   */
  async getPositionBalanceByTokenIds(
    conditionId: string,
    tokenIds: TokenIds
  ): Promise<PositionBalance> {
    return this.ctfClient.getPositionBalanceByTokenIds(conditionId, tokenIds);
  }

  /**
   * Check if wallet is ready for CTF trading operations
   *
   * Combines CTF readiness check with authorization status.
   */
  async checkReadyForCTF(amount: string): Promise<ReadyStatus> {
    // Check CTF readiness (balances)
    const ctfStatus = await this.ctfClient.checkReadyForCTF(amount);

    // Check authorization status
    const authStatus = await this.authService.checkAllowances();

    // Combine issues
    const issues: string[] = [];
    if (ctfStatus.suggestion) {
      issues.push(ctfStatus.suggestion);
    }
    issues.push(...authStatus.issues);

    return {
      ready: ctfStatus.ready && authStatus.tradingReady,
      usdcEBalance: ctfStatus.usdcEBalance,
      nativeUsdcBalance: ctfStatus.nativeUsdcBalance,
      maticBalance: ctfStatus.maticBalance,
      tradingReady: authStatus.tradingReady,
      issues,
      suggestion: ctfStatus.suggestion,
    };
  }

  /**
   * Check if wallet has sufficient tokens for merge
   */
  async canMerge(conditionId: string, amount: string): Promise<{ canMerge: boolean; reason?: string }> {
    return this.ctfClient.canMerge(conditionId, amount);
  }

  /**
   * Check if wallet has sufficient tokens for merge using CLOB token IDs
   */
  async canMergeWithTokenIds(
    conditionId: string,
    tokenIds: TokenIds,
    amount: string
  ): Promise<{ canMerge: boolean; reason?: string }> {
    return this.ctfClient.canMergeWithTokenIds(conditionId, tokenIds, amount);
  }

  /**
   * Check if wallet has sufficient USDC for split
   */
  async canSplit(amount: string): Promise<{ canSplit: boolean; reason?: string }> {
    return this.ctfClient.canSplit(amount);
  }

  // ===== Market Resolution =====

  /**
   * Check if a market is resolved and get payout info
   */
  async getMarketResolution(conditionId: string): Promise<MarketResolution> {
    return this.ctfClient.getMarketResolution(conditionId);
  }

  // ===== Gas Estimation =====

  /**
   * Get detailed gas estimate for a split operation
   */
  async estimateSplitGas(conditionId: string, amount: string): Promise<GasEstimate> {
    return this.ctfClient.getDetailedSplitGasEstimate(conditionId, amount);
  }

  /**
   * Get detailed gas estimate for a merge operation
   */
  async estimateMergeGas(conditionId: string, amount: string): Promise<GasEstimate> {
    return this.ctfClient.getDetailedMergeGasEstimate(conditionId, amount);
  }

  /**
   * Get current gas price info
   */
  async getGasPrice(): Promise<{ gwei: string; wei: string }> {
    return this.ctfClient.getGasPrice();
  }

  // ===== Transaction Monitoring =====

  /**
   * Get transaction status with detailed info
   */
  async getTransactionStatus(txHash: string): Promise<TransactionStatus> {
    return this.ctfClient.getTransactionStatus(txHash);
  }

  /**
   * Wait for transaction confirmation with timeout
   */
  async waitForTransaction(txHash: string, confirmations?: number): Promise<TransactionStatus> {
    return this.ctfClient.waitForTransaction(txHash, confirmations);
  }

  // ===== Swaps =====

  /**
   * Get a quote for a swap (checks if route is possible)
   */
  async getSwapQuote(
    tokenIn: string,
    tokenOut: string,
    amount: string
  ): Promise<QuoteResult> {
    return this.swapService.getQuote(tokenIn, tokenOut, amount);
  }

  /**
   * Execute a token swap using QuickSwap V3
   *
   * @param tokenIn - Token to swap from (e.g., 'MATIC', 'USDC', 'USDT')
   * @param tokenOut - Token to swap to (e.g., 'USDC_E', 'WETH')
   * @param amount - Amount to swap in token units
   * @param slippage - Slippage tolerance in percent (default: 0.5)
   */
  async swap(
    tokenIn: string,
    tokenOut: string,
    amount: string,
    slippage?: number
  ): Promise<SwapResult> {
    return this.swapService.swap(tokenIn, tokenOut, amount, { slippage });
  }

  /**
   * Swap any supported token to USDC.e and deposit to Polymarket
   *
   * This is a convenience method for converting tokens to the USDC.e
   * format required by Polymarket CTF operations.
   */
  async swapAndDeposit(
    token: string,
    amount: string,
    slippage?: number
  ): Promise<SwapResult> {
    return this.swapService.swapToUsdc(token, amount, {
      usdcType: 'USDC_E',
      slippage,
    });
  }

  /**
   * Get all available liquidity pools on QuickSwap V3
   */
  async getAvailablePools(): Promise<PoolInfo[]> {
    return this.swapService.getAvailablePools();
  }

  /**
   * Check if a pool exists for a token pair
   */
  async checkPool(tokenA: string, tokenB: string): Promise<PoolInfo> {
    return this.swapService.checkPool(tokenA, tokenB);
  }

  // ===== Token Transfers =====

  /**
   * Transfer an ERC20 token to another address
   */
  async transfer(token: string, to: string, amount: string): Promise<TransferResult> {
    return this.swapService.transfer(token, to, amount);
  }

  /**
   * Transfer native MATIC to another address
   */
  async transferMatic(to: string, amount: string): Promise<TransferResult> {
    return this.swapService.transferMatic(to, amount);
  }

  /**
   * Transfer native USDC to another address
   *
   * WARNING: This transfers NATIVE USDC, not USDC.e.
   * For Polymarket CTF operations, use transferUsdcE() instead.
   */
  async transferUsdc(to: string, amount: string): Promise<TransferResult> {
    return this.swapService.transferUsdc(to, amount);
  }

  /**
   * Transfer USDC.e (bridged USDC) to another address
   *
   * This is the correct method for Polymarket CTF operations.
   */
  async transferUsdcE(to: string, amount: string): Promise<TransferResult> {
    return this.swapService.transferUsdcE(to, amount);
  }

  // ===== MATIC Wrapping =====

  /**
   * Wrap native MATIC to WMATIC
   */
  async wrapMatic(amount: string): Promise<SwapResult> {
    return this.swapService.wrapMatic(amount);
  }

  /**
   * Unwrap WMATIC to native MATIC
   */
  async unwrapMatic(amount: string): Promise<SwapResult> {
    return this.swapService.unwrapMatic(amount);
  }

  // ===== Advanced Access =====

  /**
   * Get the underlying CTFClient for advanced operations
   */
  getCTFClient(): CTFClient {
    return this.ctfClient;
  }

  /**
   * Get the underlying AuthorizationService for advanced operations
   */
  getAuthorizationService(): AuthorizationService {
    return this.authService;
  }

  /**
   * Get the underlying SwapService for advanced operations
   */
  getSwapService(): SwapService {
    return this.swapService;
  }

  /**
   * Get the shared wallet instance
   */
  getWallet(): ethers.Wallet {
    return this.wallet;
  }

  /**
   * Get the shared provider instance
   */
  getProvider(): ethers.providers.JsonRpcProvider {
    return this.provider;
  }
}

================================================================================
// File: src/services/realtime-service-v2.ts
================================================================================
/**
 * RealtimeService V2
 *
 * Comprehensive real-time data service using official @polymarket/real-time-data-client.
 *
 * Supports ALL available topics:
 * - clob_market: price_change, agg_orderbook, last_trade_price, tick_size_change, market_created, market_resolved
 * - clob_user: order, trade (requires authentication)
 * - activity: trades, orders_matched
 * - crypto_prices: update (BTC, ETH, etc.)
 * - equity_prices: update (AAPL, etc.)
 * - comments: comment_created, comment_removed, reaction_created, reaction_removed
 * - rfq: request_*, quote_*
 */

import { EventEmitter } from 'events';
import {
  RealTimeDataClient,
  type Message,
  type ClobApiKeyCreds,
  ConnectionStatus,
} from '@polymarket/real-time-data-client';
import type { PriceUpdate, BookUpdate, Orderbook, OrderbookLevel } from '../core/types.js';

// ============================================================================
// Types
// ============================================================================

export interface RealtimeServiceConfig {
  /** Auto-reconnect on disconnect (default: true) */
  autoReconnect?: boolean;
  /** Ping interval in ms (default: 5000) */
  pingInterval?: number;
  /** Enable debug logging (default: false) */
  debug?: boolean;
}

// Market data types
/**
 * Extended orderbook snapshot from WebSocket with additional trading parameters.
 * Extends the base Orderbook type from core/types.ts.
 */
export interface OrderbookSnapshot extends Orderbook {
  /** Token ID (ERC-1155 token identifier, required in WebSocket context) */
  tokenId: string;
  /** @deprecated Use tokenId instead */
  assetId: string;
  /** Market condition ID (required in WebSocket context) */
  market: string;
  /** Tick size for price rounding */
  tickSize: string;
  /** Minimum order size */
  minOrderSize: string;
  /** Hash for change detection (required in WebSocket context) */
  hash: string;
}

export interface LastTradeInfo {
  assetId: string;
  price: number;
  side: 'BUY' | 'SELL';
  size: number;
  timestamp: number;
}

export interface PriceChange {
  assetId: string;
  changes: Array<{ price: string; size: string }>;
  timestamp: number;
}

export interface TickSizeChange {
  assetId: string;
  oldTickSize: string;
  newTickSize: string;
  timestamp: number;
}

export interface MarketEvent {
  conditionId: string;
  type: 'created' | 'resolved';
  data: Record<string, unknown>;
  timestamp: number;
}

// User data types (requires authentication)
export interface UserOrder {
  orderId: string;
  market: string;
  asset: string;
  side: 'BUY' | 'SELL';
  price: number;
  originalSize: number;
  matchedSize: number;
  eventType: 'PLACEMENT' | 'UPDATE' | 'CANCELLATION';
  timestamp: number;
}

export interface UserTrade {
  tradeId: string;
  market: string;
  outcome: string;
  price: number;
  size: number;
  side: 'BUY' | 'SELL';
  status: 'MATCHED' | 'MINED' | 'CONFIRMED' | 'RETRYING' | 'FAILED';
  timestamp: number;
  transactionHash?: string;
}

// Activity types
/**
 * Activity trade from WebSocket
 *
 * 实测验证 (2025-12-28)：proxyWallet 和 name 是顶层字段，不在 trader 对象里
 */
export interface ActivityTrade {
  /** Token ID (用于下单) */
  asset: string;
  /** Market condition ID */
  conditionId: string;
  /** Event slug */
  eventSlug: string;
  /** Market slug (可用于过滤) */
  marketSlug: string;
  /** Outcome (Yes/No) */
  outcome: string;
  /** Trade price */
  price: number;
  /** Trade side */
  side: 'BUY' | 'SELL';
  /** Trade size in shares */
  size: number;
  /** Timestamp (Unix seconds) */
  timestamp: number;
  /** Transaction hash */
  transactionHash: string;

  // ========== 交易者信息 ==========

  /**
   * Trader info object - 用于 Copy Trading 过滤目标钱包
   *
   * 注意: 实测验证 (2025-12-28) 数据结构为:
   * {
   *   trader: { name: "username", address: "0x..." }
   * }
   * 而非顶层 proxyWallet
   */
  trader?: {
    /** 交易者用户名 */
    name?: string;
    /** 交易者钱包地址 - Copy Trading 过滤关键字段！ */
    address?: string;
  };
}

// External price types
export interface CryptoPrice {
  symbol: string;
  price: number;
  timestamp: number;
}

export interface EquityPrice {
  symbol: string;
  price: number;
  timestamp: number;
}

// Comment types
export interface Comment {
  id: string;
  parentEntityId: number;
  parentEntityType: 'Event' | 'Series';
  content?: string;
  author?: string;
  timestamp: number;
}

export interface Reaction {
  id: string;
  commentId: string;
  type: string;
  author?: string;
  timestamp: number;
}

// RFQ types
export interface RFQRequest {
  id: string;
  market: string;
  side: 'BUY' | 'SELL';
  size: number;
  status: 'created' | 'edited' | 'canceled' | 'expired';
  timestamp: number;
}

export interface RFQQuote {
  id: string;
  requestId: string;
  price: number;
  size: number;
  status: 'created' | 'edited' | 'canceled' | 'expired';
  timestamp: number;
}

// Subscription types
export interface Subscription {
  id: string;
  topic: string;
  type: string;
  unsubscribe: () => void;
}

export interface MarketSubscription extends Subscription {
  tokenIds: string[];
}

// Event handler types
export interface MarketDataHandlers {
  onOrderbook?: (book: OrderbookSnapshot) => void;
  onPriceChange?: (change: PriceChange) => void;
  onLastTrade?: (trade: LastTradeInfo) => void;
  onTickSizeChange?: (change: TickSizeChange) => void;
  onMarketEvent?: (event: MarketEvent) => void;
  onError?: (error: Error) => void;
}

export interface UserDataHandlers {
  onOrder?: (order: UserOrder) => void;
  onTrade?: (trade: UserTrade) => void;
  onError?: (error: Error) => void;
}

export interface ActivityHandlers {
  onTrade?: (trade: ActivityTrade) => void;
  onError?: (error: Error) => void;
}

export interface CryptoPriceHandlers {
  onPrice?: (price: CryptoPrice) => void;
  onError?: (error: Error) => void;
}

export interface EquityPriceHandlers {
  onPrice?: (price: EquityPrice) => void;
  onError?: (error: Error) => void;
}

// ============================================================================
// RealtimeServiceV2 Implementation
// ============================================================================

export class RealtimeServiceV2 extends EventEmitter {
  private client: RealTimeDataClient | null = null;
  private config: RealtimeServiceConfig;
  private subscriptions: Map<string, Subscription> = new Map();
  private subscriptionIdCounter = 0;
  private connected = false;

  // Store subscription messages for reconnection
  private subscriptionMessages: Map<string, { subscriptions: Array<{ topic: string; type: string; filters?: string; clob_auth?: ClobApiKeyCreds }> }> = new Map();

  // Caches
  private priceCache: Map<string, PriceUpdate> = new Map();
  private bookCache: Map<string, OrderbookSnapshot> = new Map();
  private lastTradeCache: Map<string, LastTradeInfo> = new Map();

  constructor(config: RealtimeServiceConfig = {}) {
    super();
    this.config = {
      autoReconnect: config.autoReconnect ?? true,
      pingInterval: config.pingInterval ?? 5000,
      debug: config.debug ?? false,
    };
  }

  // ============================================================================
  // Connection Management
  // ============================================================================

  /**
   * Connect to WebSocket server
   */
  connect(): this {
    if (this.client) {
      this.log('Already connected or connecting');
      return this;
    }

    this.client = new RealTimeDataClient({
      onConnect: this.handleConnect.bind(this),
      onMessage: this.handleMessage.bind(this),
      onStatusChange: this.handleStatusChange.bind(this),
      autoReconnect: this.config.autoReconnect,
      pingInterval: this.config.pingInterval,
    });

    this.client.connect();
    return this;
  }

  /**
   * Disconnect from WebSocket server
   */
  disconnect(): void {
    if (this.client) {
      this.client.disconnect();
      this.client = null;
      this.connected = false;
      this.subscriptions.clear();
      this.subscriptionMessages.clear();  // Clear reconnection list
    }
  }

  /**
   * Check if connected
   */
  isConnected(): boolean {
    return this.connected;
  }

  // ============================================================================
  // Market Data Subscriptions (clob_market)
  // ============================================================================

  /**
   * Subscribe to market data (orderbook, prices, trades)
   * @param tokenIds - Array of token IDs to subscribe to
   * @param handlers - Event handlers
   */
  subscribeMarkets(tokenIds: string[], handlers: MarketDataHandlers = {}): MarketSubscription {
    const subId = `market_${++this.subscriptionIdCounter}`;
    const filterStr = JSON.stringify(tokenIds);

    // Subscribe to all market data types
    const subscriptions = [
      { topic: 'clob_market', type: 'agg_orderbook', filters: filterStr },
      { topic: 'clob_market', type: 'price_change', filters: filterStr },
      { topic: 'clob_market', type: 'last_trade_price', filters: filterStr },
      { topic: 'clob_market', type: 'tick_size_change', filters: filterStr },
    ];

    const subMsg = { subscriptions };
    this.sendSubscription(subMsg);
    this.subscriptionMessages.set(subId, subMsg);  // Store for reconnection

    // Register handlers
    const orderbookHandler = (book: OrderbookSnapshot) => {
      if (tokenIds.includes(book.assetId)) {
        handlers.onOrderbook?.(book);
      }
    };

    const priceChangeHandler = (change: PriceChange) => {
      if (tokenIds.includes(change.assetId)) {
        handlers.onPriceChange?.(change);
      }
    };

    const lastTradeHandler = (trade: LastTradeInfo) => {
      if (tokenIds.includes(trade.assetId)) {
        handlers.onLastTrade?.(trade);
      }
    };

    const tickSizeHandler = (change: TickSizeChange) => {
      if (tokenIds.includes(change.assetId)) {
        handlers.onTickSizeChange?.(change);
      }
    };

    this.on('orderbook', orderbookHandler);
    this.on('priceChange', priceChangeHandler);
    this.on('lastTrade', lastTradeHandler);
    this.on('tickSizeChange', tickSizeHandler);

    const subscription: MarketSubscription = {
      id: subId,
      topic: 'clob_market',
      type: '*',
      tokenIds,
      unsubscribe: () => {
        this.off('orderbook', orderbookHandler);
        this.off('priceChange', priceChangeHandler);
        this.off('lastTrade', lastTradeHandler);
        this.off('tickSizeChange', tickSizeHandler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
        this.subscriptionMessages.delete(subId);  // Remove from reconnection list
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  /**
   * Subscribe to a single market (YES + NO tokens)
   * Also emits derived price updates compatible with old API
   */
  subscribeMarket(
    yesTokenId: string,
    noTokenId: string,
    handlers: MarketDataHandlers & {
      onPriceUpdate?: (update: PriceUpdate) => void;
      onBookUpdate?: (update: BookUpdate) => void;
      onPairUpdate?: (update: { yes: PriceUpdate; no: PriceUpdate; spread: number }) => void;
    } = {}
  ): MarketSubscription {
    let lastYesUpdate: PriceUpdate | undefined;
    let lastNoUpdate: PriceUpdate | undefined;

    const checkPairUpdate = () => {
      if (lastYesUpdate && lastNoUpdate && handlers.onPairUpdate) {
        handlers.onPairUpdate({
          yes: lastYesUpdate,
          no: lastNoUpdate,
          spread: lastYesUpdate.price + lastNoUpdate.price,
        });
      }
    };

    return this.subscribeMarkets([yesTokenId, noTokenId], {
      onOrderbook: (book) => {
        handlers.onOrderbook?.(book);

        // Convert to BookUpdate for backward compatibility
        if (handlers.onBookUpdate) {
          const bookUpdate: BookUpdate = {
            assetId: book.assetId,
            bids: book.bids,
            asks: book.asks,
            timestamp: book.timestamp,
          };
          handlers.onBookUpdate(bookUpdate);
        }

        // Calculate derived price (Polymarket display logic)
        const priceUpdate = this.calculateDerivedPrice(book.assetId, book);
        if (priceUpdate) {
          this.priceCache.set(book.assetId, priceUpdate);

          if (book.assetId === yesTokenId) {
            lastYesUpdate = priceUpdate;
          } else if (book.assetId === noTokenId) {
            lastNoUpdate = priceUpdate;
          }

          handlers.onPriceUpdate?.(priceUpdate);
          this.emit('priceUpdate', priceUpdate);
          checkPairUpdate();
        }
      },
      onLastTrade: (trade) => {
        handlers.onLastTrade?.(trade);
        this.lastTradeCache.set(trade.assetId, trade);

        // Recalculate derived price with new last trade
        const book = this.bookCache.get(trade.assetId);
        if (book) {
          const priceUpdate = this.calculateDerivedPrice(trade.assetId, book);
          if (priceUpdate) {
            this.priceCache.set(trade.assetId, priceUpdate);

            if (trade.assetId === yesTokenId) {
              lastYesUpdate = priceUpdate;
            } else if (trade.assetId === noTokenId) {
              lastNoUpdate = priceUpdate;
            }

            handlers.onPriceUpdate?.(priceUpdate);
            this.emit('priceUpdate', priceUpdate);
            checkPairUpdate();
          }
        }
      },
      onPriceChange: handlers.onPriceChange,
      onTickSizeChange: handlers.onTickSizeChange,
      onError: handlers.onError,
    });
  }

  /**
   * Subscribe to market lifecycle events (creation, resolution)
   */
  subscribeMarketEvents(handlers: { onMarketEvent?: (event: MarketEvent) => void }): Subscription {
    const subId = `market_event_${++this.subscriptionIdCounter}`;

    const subscriptions = [
      { topic: 'clob_market', type: 'market_created' },
      { topic: 'clob_market', type: 'market_resolved' },
    ];

    this.sendSubscription({ subscriptions });

    const handler = (event: MarketEvent) => handlers.onMarketEvent?.(event);
    this.on('marketEvent', handler);

    const subscription: Subscription = {
      id: subId,
      topic: 'clob_market',
      type: 'lifecycle',
      unsubscribe: () => {
        this.off('marketEvent', handler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // User Data Subscriptions (clob_user) - Requires Authentication
  // ============================================================================

  /**
   * Subscribe to user order and trade events
   * @param credentials - CLOB API credentials
   * @param handlers - Event handlers
   */
  subscribeUserEvents(credentials: ClobApiKeyCreds, handlers: UserDataHandlers = {}): Subscription {
    const subId = `user_${++this.subscriptionIdCounter}`;

    const subscriptions = [
      { topic: 'clob_user', type: '*', clob_auth: credentials },
    ];

    this.sendSubscription({ subscriptions });

    const orderHandler = (order: UserOrder) => handlers.onOrder?.(order);
    const tradeHandler = (trade: UserTrade) => handlers.onTrade?.(trade);

    this.on('userOrder', orderHandler);
    this.on('userTrade', tradeHandler);

    const subscription: Subscription = {
      id: subId,
      topic: 'clob_user',
      type: '*',
      unsubscribe: () => {
        this.off('userOrder', orderHandler);
        this.off('userTrade', tradeHandler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // Activity Subscriptions (trades, orders_matched)
  // ============================================================================

  /**
   * Subscribe to trading activity for a market or event
   * @param filter - Event or market slug (optional - if empty, subscribes to all activity)
   * @param handlers - Event handlers
   */
  subscribeActivity(
    filter: { eventSlug?: string; marketSlug?: string } = {},
    handlers: ActivityHandlers = {}
  ): Subscription {
    const subId = `activity_${++this.subscriptionIdCounter}`;

    // Build filter object with snake_case keys (as expected by the server)
    // Only include filters if we have actual filter values
    const hasFilter = filter.eventSlug || filter.marketSlug;
    const filterObj: Record<string, string> = {};
    if (filter.eventSlug) filterObj.event_slug = filter.eventSlug;
    if (filter.marketSlug) filterObj.market_slug = filter.marketSlug;

    // Create subscription objects - only include filters field if we have filters
    const subscriptions = hasFilter
      ? [
          { topic: 'activity', type: 'trades', filters: JSON.stringify(filterObj) },
          { topic: 'activity', type: 'orders_matched', filters: JSON.stringify(filterObj) },
        ]
      : [
          { topic: 'activity', type: 'trades' },
          { topic: 'activity', type: 'orders_matched' },
        ];

    this.sendSubscription({ subscriptions });

    const handler = (trade: ActivityTrade) => handlers.onTrade?.(trade);
    this.on('activityTrade', handler);

    const subscription: Subscription = {
      id: subId,
      topic: 'activity',
      type: '*',
      unsubscribe: () => {
        this.off('activityTrade', handler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  /**
   * Subscribe to ALL trading activity across all markets (no filtering)
   * This is useful for Copy Trading - monitoring Smart Money across the platform
   * @param handlers - Event handlers
   */
  subscribeAllActivity(handlers: ActivityHandlers = {}): Subscription {
    return this.subscribeActivity({}, handlers);
  }

  // ============================================================================
  // Crypto Price Subscriptions
  // ============================================================================

  /**
   * Subscribe to crypto price updates
   * @param symbols - Array of symbols (e.g., ['BTCUSDT', 'ETHUSDT'])
   * @param handlers - Event handlers
   */
  subscribeCryptoPrices(symbols: string[], handlers: CryptoPriceHandlers = {}): Subscription {
    const subId = `crypto_${++this.subscriptionIdCounter}`;

    // Subscribe to each symbol
    const subscriptions = symbols.map(symbol => ({
      topic: 'crypto_prices',
      type: 'update',
      filters: JSON.stringify({ symbol }),
    }));

    this.sendSubscription({ subscriptions });

    const handler = (price: CryptoPrice) => {
      if (symbols.includes(price.symbol)) {
        handlers.onPrice?.(price);
      }
    };
    this.on('cryptoPrice', handler);

    const subscription: Subscription = {
      id: subId,
      topic: 'crypto_prices',
      type: 'update',
      unsubscribe: () => {
        this.off('cryptoPrice', handler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  /**
   * Subscribe to Chainlink crypto prices
   * @param symbols - Array of symbols (e.g., ['ETH/USD', 'BTC/USD'])
   */
  subscribeCryptoChainlinkPrices(symbols: string[], handlers: CryptoPriceHandlers = {}): Subscription {
    const subId = `crypto_chainlink_${++this.subscriptionIdCounter}`;

    const subscriptions = symbols.map(symbol => ({
      topic: 'crypto_prices_chainlink',
      type: 'update',
      filters: JSON.stringify({ symbol }),
    }));

    const subMsg = { subscriptions };
    this.sendSubscription(subMsg);
    this.subscriptionMessages.set(subId, subMsg);  // Store for reconnection

    const handler = (price: CryptoPrice) => {
      if (symbols.includes(price.symbol)) {
        handlers.onPrice?.(price);
      }
    };
    this.on('cryptoChainlinkPrice', handler);

    const subscription: Subscription = {
      id: subId,
      topic: 'crypto_prices_chainlink',
      type: 'update',
      unsubscribe: () => {
        this.off('cryptoChainlinkPrice', handler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
        this.subscriptionMessages.delete(subId);  // Remove from reconnection list
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // Equity Price Subscriptions
  // ============================================================================

  /**
   * Subscribe to equity price updates
   * @param symbols - Array of symbols (e.g., ['AAPL', 'GOOGL'])
   * @param handlers - Event handlers
   */
  subscribeEquityPrices(symbols: string[], handlers: EquityPriceHandlers = {}): Subscription {
    const subId = `equity_${++this.subscriptionIdCounter}`;

    const subscriptions = symbols.map(symbol => ({
      topic: 'equity_prices',
      type: 'update',
      filters: JSON.stringify({ symbol }),
    }));

    this.sendSubscription({ subscriptions });

    const handler = (price: EquityPrice) => {
      if (symbols.includes(price.symbol)) {
        handlers.onPrice?.(price);
      }
    };
    this.on('equityPrice', handler);

    const subscription: Subscription = {
      id: subId,
      topic: 'equity_prices',
      type: 'update',
      unsubscribe: () => {
        this.off('equityPrice', handler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // Comments Subscriptions
  // ============================================================================

  /**
   * Subscribe to comment and reaction events
   */
  subscribeComments(
    filter: { parentEntityId: number; parentEntityType: 'Event' | 'Series' },
    handlers: {
      onComment?: (comment: Comment) => void;
      onReaction?: (reaction: Reaction) => void;
    } = {}
  ): Subscription {
    const subId = `comments_${++this.subscriptionIdCounter}`;
    const filterStr = JSON.stringify({
      parentEntityID: filter.parentEntityId,
      parentEntityType: filter.parentEntityType,
    });

    const subscriptions = [
      { topic: 'comments', type: 'comment_created', filters: filterStr },
      { topic: 'comments', type: 'comment_removed', filters: filterStr },
      { topic: 'comments', type: 'reaction_created', filters: filterStr },
      { topic: 'comments', type: 'reaction_removed', filters: filterStr },
    ];

    this.sendSubscription({ subscriptions });

    const commentHandler = (comment: Comment) => handlers.onComment?.(comment);
    const reactionHandler = (reaction: Reaction) => handlers.onReaction?.(reaction);

    this.on('comment', commentHandler);
    this.on('reaction', reactionHandler);

    const subscription: Subscription = {
      id: subId,
      topic: 'comments',
      type: '*',
      unsubscribe: () => {
        this.off('comment', commentHandler);
        this.off('reaction', reactionHandler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // RFQ Subscriptions
  // ============================================================================

  /**
   * Subscribe to RFQ (Request for Quote) events
   */
  subscribeRFQ(handlers: {
    onRequest?: (request: RFQRequest) => void;
    onQuote?: (quote: RFQQuote) => void;
  } = {}): Subscription {
    const subId = `rfq_${++this.subscriptionIdCounter}`;

    const subscriptions = [
      { topic: 'rfq', type: 'request_created' },
      { topic: 'rfq', type: 'request_edited' },
      { topic: 'rfq', type: 'request_canceled' },
      { topic: 'rfq', type: 'request_expired' },
      { topic: 'rfq', type: 'quote_created' },
      { topic: 'rfq', type: 'quote_edited' },
      { topic: 'rfq', type: 'quote_canceled' },
      { topic: 'rfq', type: 'quote_expired' },
    ];

    this.sendSubscription({ subscriptions });

    const requestHandler = (request: RFQRequest) => handlers.onRequest?.(request);
    const quoteHandler = (quote: RFQQuote) => handlers.onQuote?.(quote);

    this.on('rfqRequest', requestHandler);
    this.on('rfqQuote', quoteHandler);

    const subscription: Subscription = {
      id: subId,
      topic: 'rfq',
      type: '*',
      unsubscribe: () => {
        this.off('rfqRequest', requestHandler);
        this.off('rfqQuote', quoteHandler);
        this.sendUnsubscription({ subscriptions });
        this.subscriptions.delete(subId);
      },
    };

    this.subscriptions.set(subId, subscription);
    return subscription;
  }

  // ============================================================================
  // Cache Access
  // ============================================================================

  /**
   * Get cached derived price for an asset
   */
  getPrice(assetId: string): PriceUpdate | undefined {
    return this.priceCache.get(assetId);
  }

  /**
   * Get all cached prices
   */
  getAllPrices(): Map<string, PriceUpdate> {
    return new Map(this.priceCache);
  }

  /**
   * Get cached orderbook for an asset
   */
  getBook(assetId: string): OrderbookSnapshot | undefined {
    return this.bookCache.get(assetId);
  }

  /**
   * Get cached last trade for an asset
   */
  getLastTrade(assetId: string): LastTradeInfo | undefined {
    return this.lastTradeCache.get(assetId);
  }

  // ============================================================================
  // Subscription Management
  // ============================================================================

  /**
   * Get all active subscriptions
   */
  getActiveSubscriptions(): Subscription[] {
    return Array.from(this.subscriptions.values());
  }

  /**
   * Unsubscribe from all
   */
  unsubscribeAll(): void {
    for (const sub of this.subscriptions.values()) {
      sub.unsubscribe();
    }
    this.subscriptions.clear();
    this.subscriptionMessages.clear();  // Clear reconnection list
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  private handleConnect(client: RealTimeDataClient): void {
    this.connected = true;
    this.log('Connected to WebSocket server');

    // Re-subscribe to all active subscriptions on reconnect
    if (this.subscriptionMessages.size > 0) {
      this.log(`Re-subscribing to ${this.subscriptionMessages.size} subscriptions...`);
      for (const [subId, msg] of this.subscriptionMessages) {
        this.log(`Re-subscribing: ${subId}`);
        this.client?.subscribe(msg);
      }
    }

    this.emit('connected');
  }

  private handleStatusChange(status: ConnectionStatus): void {
    this.log(`Connection status: ${status}`);

    if (status === ConnectionStatus.DISCONNECTED) {
      this.connected = false;
      this.emit('disconnected');
    } else if (status === ConnectionStatus.CONNECTED) {
      this.connected = true;
    }

    this.emit('statusChange', status);
  }

  private handleMessage(client: RealTimeDataClient, message: Message): void {
    this.log(`Received: ${message.topic}:${message.type}`);

    const payload = message.payload as Record<string, unknown>;

    switch (message.topic) {
      case 'clob_market':
        this.handleMarketMessage(message.type, payload, message.timestamp);
        break;

      case 'clob_user':
        this.handleUserMessage(message.type, payload, message.timestamp);
        break;

      case 'activity':
        this.handleActivityMessage(message.type, payload, message.timestamp);
        break;

      case 'crypto_prices':
        this.handleCryptoPriceMessage(payload, message.timestamp);
        break;

      case 'crypto_prices_chainlink':
        this.handleCryptoChainlinkPriceMessage(payload, message.timestamp);
        break;

      case 'equity_prices':
        this.handleEquityPriceMessage(payload, message.timestamp);
        break;

      case 'comments':
        this.handleCommentMessage(message.type, payload, message.timestamp);
        break;

      case 'rfq':
        this.handleRFQMessage(message.type, payload, message.timestamp);
        break;

      default:
        this.log(`Unknown topic: ${message.topic}`);
    }
  }

  private handleMarketMessage(type: string, payload: Record<string, unknown>, timestamp: number): void {
    switch (type) {
      case 'agg_orderbook': {
        const book = this.parseOrderbook(payload, timestamp);
        this.bookCache.set(book.assetId, book);
        this.emit('orderbook', book);
        break;
      }

      case 'price_change': {
        const change = this.parsePriceChange(payload, timestamp);
        this.emit('priceChange', change);
        break;
      }

      case 'last_trade_price': {
        const trade = this.parseLastTrade(payload, timestamp);
        this.lastTradeCache.set(trade.assetId, trade);
        this.emit('lastTrade', trade);
        break;
      }

      case 'tick_size_change': {
        const change = this.parseTickSizeChange(payload, timestamp);
        this.emit('tickSizeChange', change);
        break;
      }

      case 'market_created':
      case 'market_resolved': {
        const event: MarketEvent = {
          conditionId: payload.condition_id as string || '',
          type: type === 'market_created' ? 'created' : 'resolved',
          data: payload,
          timestamp,
        };
        this.emit('marketEvent', event);
        break;
      }
    }
  }

  private handleUserMessage(type: string, payload: Record<string, unknown>, timestamp: number): void {
    if (type === 'order') {
      const order: UserOrder = {
        orderId: payload.order_id as string || '',
        market: payload.market as string || '',
        asset: payload.asset as string || '',
        side: payload.side as 'BUY' | 'SELL',
        price: Number(payload.price) || 0,
        originalSize: Number(payload.original_size) || 0,
        matchedSize: Number(payload.matched_size) || 0,
        eventType: payload.event_type as 'PLACEMENT' | 'UPDATE' | 'CANCELLATION',
        timestamp,
      };
      this.emit('userOrder', order);
    } else if (type === 'trade') {
      const trade: UserTrade = {
        tradeId: payload.trade_id as string || '',
        market: payload.market as string || '',
        outcome: payload.outcome as string || '',
        price: Number(payload.price) || 0,
        size: Number(payload.size) || 0,
        side: payload.side as 'BUY' | 'SELL',
        status: payload.status as 'MATCHED' | 'MINED' | 'CONFIRMED' | 'RETRYING' | 'FAILED',
        timestamp,
        transactionHash: payload.transaction_hash as string | undefined,
      };
      this.emit('userTrade', trade);
    }
  }

  private handleActivityMessage(type: string, payload: Record<string, unknown>, timestamp: number): void {
    const trade: ActivityTrade = {
      asset: payload.asset as string || '',
      conditionId: payload.conditionId as string || '',
      eventSlug: payload.eventSlug as string || '',
      marketSlug: payload.slug as string || '',
      outcome: payload.outcome as string || '',
      price: Number(payload.price) || 0,
      side: payload.side as 'BUY' | 'SELL',
      size: Number(payload.size) || 0,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
      transactionHash: payload.transactionHash as string || '',
      trader: {
        name: payload.name as string | undefined,
        address: payload.proxyWallet as string | undefined,
      },
    };
    this.emit('activityTrade', trade);
  }

  private handleCryptoPriceMessage(payload: Record<string, unknown>, timestamp: number): void {
    const price: CryptoPrice = {
      symbol: payload.symbol as string || '',
      price: Number(payload.value) || 0,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
    };
    this.emit('cryptoPrice', price);
  }

  private handleCryptoChainlinkPriceMessage(payload: Record<string, unknown>, timestamp: number): void {
    const price: CryptoPrice = {
      symbol: payload.symbol as string || '',
      price: Number(payload.value) || 0,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
    };
    this.emit('cryptoChainlinkPrice', price);
  }

  private handleEquityPriceMessage(payload: Record<string, unknown>, timestamp: number): void {
    const price: EquityPrice = {
      symbol: payload.symbol as string || '',
      price: Number(payload.value) || 0,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
    };
    this.emit('equityPrice', price);
  }

  private handleCommentMessage(type: string, payload: Record<string, unknown>, timestamp: number): void {
    if (type.includes('comment')) {
      const comment: Comment = {
        id: payload.id as string || '',
        parentEntityId: payload.parentEntityID as number || 0,
        parentEntityType: payload.parentEntityType as 'Event' | 'Series',
        content: payload.content as string | undefined,
        author: payload.author as string | undefined,
        timestamp,
      };
      this.emit('comment', comment);
    } else if (type.includes('reaction')) {
      const reaction: Reaction = {
        id: payload.id as string || '',
        commentId: payload.commentId as string || '',
        type: payload.type as string || '',
        author: payload.author as string | undefined,
        timestamp,
      };
      this.emit('reaction', reaction);
    }
  }

  private handleRFQMessage(type: string, payload: Record<string, unknown>, timestamp: number): void {
    if (type.startsWith('request_')) {
      const status = type.replace('request_', '') as 'created' | 'edited' | 'canceled' | 'expired';
      const request: RFQRequest = {
        id: payload.id as string || '',
        market: payload.market as string || '',
        side: payload.side as 'BUY' | 'SELL',
        size: Number(payload.size) || 0,
        status,
        timestamp,
      };
      this.emit('rfqRequest', request);
    } else if (type.startsWith('quote_')) {
      const status = type.replace('quote_', '') as 'created' | 'edited' | 'canceled' | 'expired';
      const quote: RFQQuote = {
        id: payload.id as string || '',
        requestId: payload.request_id as string || '',
        price: Number(payload.price) || 0,
        size: Number(payload.size) || 0,
        status,
        timestamp,
      };
      this.emit('rfqQuote', quote);
    }
  }

  // Parsers

  private parseOrderbook(payload: Record<string, unknown>, timestamp: number): OrderbookSnapshot {
    const bidsRaw = payload.bids as Array<{ price: string; size: string }> || [];
    const asksRaw = payload.asks as Array<{ price: string; size: string }> || [];

    // Sort bids descending, asks ascending
    const bids = bidsRaw
      .map(l => ({ price: parseFloat(l.price), size: parseFloat(l.size) }))
      .sort((a, b) => b.price - a.price);

    const asks = asksRaw
      .map(l => ({ price: parseFloat(l.price), size: parseFloat(l.size) }))
      .sort((a, b) => a.price - b.price);

    const tokenId = payload.asset_id as string || '';
    return {
      tokenId,
      assetId: tokenId, // Backward compatibility
      market: payload.market as string || '',
      bids,
      asks,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
      tickSize: payload.tick_size as string || '0.01',
      minOrderSize: payload.min_order_size as string || '1',
      hash: payload.hash as string || '',
    };
  }

  private parsePriceChange(payload: Record<string, unknown>, timestamp: number): PriceChange {
    const changes = payload.price_changes as Array<{ price: string; size: string }> || [];
    return {
      assetId: payload.asset_id as string || '',
      changes,
      timestamp,
    };
  }

  private parseLastTrade(payload: Record<string, unknown>, timestamp: number): LastTradeInfo {
    return {
      assetId: payload.asset_id as string || '',
      price: parseFloat(payload.price as string) || 0,
      side: payload.side as 'BUY' | 'SELL' || 'BUY',
      size: parseFloat(payload.size as string) || 0,
      timestamp: this.normalizeTimestamp(payload.timestamp) || timestamp,
    };
  }

  private parseTickSizeChange(payload: Record<string, unknown>, timestamp: number): TickSizeChange {
    return {
      assetId: payload.asset_id as string || '',
      oldTickSize: payload.old_tick_size as string || '',
      newTickSize: payload.new_tick_size as string || '',
      timestamp,
    };
  }

  /**
   * Calculate derived price using Polymarket's display logic:
   * - If spread <= 0.10: use midpoint
   * - If spread > 0.10: use last trade price
   */
  private calculateDerivedPrice(assetId: string, book: OrderbookSnapshot): PriceUpdate | null {
    if (book.bids.length === 0 || book.asks.length === 0) {
      return null;
    }

    const bestBid = book.bids[0].price;
    const bestAsk = book.asks[0].price;
    const spread = bestAsk - bestBid;
    const midpoint = (bestBid + bestAsk) / 2;

    const lastTrade = this.lastTradeCache.get(assetId);
    const lastTradePrice = lastTrade?.price ?? midpoint;

    // Polymarket display logic
    const displayPrice = spread <= 0.10 ? midpoint : lastTradePrice;

    return {
      assetId,
      price: displayPrice,
      midpoint,
      spread,
      timestamp: book.timestamp,
    };
  }

  private sendSubscription(msg: { subscriptions: Array<{ topic: string; type: string; filters?: string; clob_auth?: ClobApiKeyCreds }> }): void {
    if (this.client && this.connected) {
      this.client.subscribe(msg);
    } else {
      this.log('Cannot subscribe: not connected');
    }
  }

  private sendUnsubscription(msg: { subscriptions: Array<{ topic: string; type: string; filters?: string }> }): void {
    if (this.client && this.connected) {
      this.client.unsubscribe(msg);
    }
  }

  private log(message: string): void {
    if (this.config.debug) {
      console.log(`[RealtimeService] ${message}`);
    }
  }

  /**
   * Normalize timestamp to milliseconds
   * Polymarket WebSocket returns timestamps in seconds, need to convert to milliseconds
   */
  private normalizeTimestamp(ts: unknown): number {
    if (typeof ts === 'string') {
      const parsed = parseInt(ts, 10);
      if (isNaN(parsed)) return Date.now();
      // If timestamp is in seconds (< 1e12), convert to milliseconds
      return parsed < 1e12 ? parsed * 1000 : parsed;
    }
    if (typeof ts === 'number') {
      // If timestamp is in seconds (< 1e12), convert to milliseconds
      return ts < 1e12 ? ts * 1000 : ts;
    }
    return Date.now();
  }
}

================================================================================
// File: src/services/smart-money-service.ts
================================================================================
/**
 * SmartMoneyService
 *
 * 聪明钱监控和自动跟单服务
 *
 * 核心功能：
 * 1. 监听指定地址的交易 - subscribeSmartMoneyTrades()
 * 2. 自动跟单 - startAutoCopyTrading()
 * 3. 聪明钱信息获取 - getSmartMoneyList(), getSmartMoneyInfo()
 *
 * ============================================================================
 * 设计决策
 * ============================================================================
 *
 * ## 监控方式
 * 使用 Activity WebSocket，延迟 < 100ms，实测验证有效。
 *
 * ## 下单方式
 * | 方式 | 使用场景 | 特点 |
 * |------|---------|------|
 * | FOK | 小额跟单 | 全部成交或取消 |
 * | FAK | 大额跟单 | 部分成交也接受 |
 *
 * ## 重要限制
 * ⚠️ Activity WebSocket 不会广播用户自己的交易！
 * 验证跟单结果请使用 TradingService.getTrades()
 */

import type { WalletService, TimePeriod, PeriodLeaderboardEntry } from './wallet-service.js';
import type { RealtimeServiceV2, ActivityTrade } from './realtime-service-v2.js';
import type { TradingService, OrderResult } from './trading-service.js';
import type { Position, ClosedPosition, ClosedPositionsParams, DataApiClient } from '../clients/data-api.js';

// ============================================================================
// Market Categorization (exported utilities)
// ============================================================================

/**
 * Market category for classification
 */
export type MarketCategory =
  | 'crypto'
  | 'politics'
  | 'sports'
  | 'entertainment'
  | 'economics'
  | 'science'
  | 'other';

/**
 * Keywords for market categorization by category
 */
export const CATEGORY_KEYWORDS: Record<MarketCategory, RegExp> = {
  crypto: /\b(btc|bitcoin|eth|ethereum|sol|solana|xrp|crypto|doge|ada|matic)\b/i,
  politics: /\b(trump|biden|election|president|senate|congress|vote|political|maga|democrat|republican)\b/i,
  sports: /\b(nfl|nba|mlb|nhl|super bowl|world cup|championship|game|match|ufc|soccer|football|basketball)\b/i,
  economics: /\b(fed|interest rate|inflation|gdp|recession|economic|unemployment|cpi)\b/i,
  entertainment: /\b(oscar|grammy|movie|twitter|celebrity|entertainment|netflix|spotify)\b/i,
  science: /\b(spacex|nasa|ai|openai|google|apple|tesla|tech|technology|science)\b/i,
  other: /.*/, // Matches everything as fallback
};

/**
 * Categorize a market based on its title
 *
 * @param title - Market title to categorize
 * @returns The market category
 *
 * @example
 * ```typescript
 * import { categorizeMarket } from '@catalyst-team/poly-sdk';
 *
 * categorizeMarket('Will BTC hit $100k?'); // 'crypto'
 * categorizeMarket('Trump wins 2024?');    // 'politics'
 * categorizeMarket('Lakers win NBA?');     // 'sports'
 * categorizeMarket('Random event?');       // 'other'
 * ```
 */
export function categorizeMarket(title: string): MarketCategory {
  const lowerTitle = title.toLowerCase();

  // Check each category in priority order
  if (CATEGORY_KEYWORDS.crypto.test(lowerTitle)) return 'crypto';
  if (CATEGORY_KEYWORDS.politics.test(lowerTitle)) return 'politics';
  if (CATEGORY_KEYWORDS.sports.test(lowerTitle)) return 'sports';
  if (CATEGORY_KEYWORDS.economics.test(lowerTitle)) return 'economics';
  if (CATEGORY_KEYWORDS.entertainment.test(lowerTitle)) return 'entertainment';
  if (CATEGORY_KEYWORDS.science.test(lowerTitle)) return 'science';

  return 'other';
}

// ============================================================================
// Types
// ============================================================================

/**
 * Smart Money wallet information
 */
export interface SmartMoneyWallet {
  address: string;
  name?: string;
  pnl: number;
  volume: number;
  score: number;
  rank?: number;
}

/**
 * Smart Money trade from Activity WebSocket
 */
export interface SmartMoneyTrade {
  traderAddress: string;
  traderName?: string;
  conditionId?: string;
  marketSlug?: string;
  side: 'BUY' | 'SELL';
  size: number;
  price: number;
  tokenId?: string;
  outcome?: string;
  txHash?: string;
  timestamp: number;
  isSmartMoney: boolean;
  smartMoneyInfo?: SmartMoneyWallet;
}

/**
 * Auto copy trading options
 */
export interface AutoCopyTradingOptions {
  /** Specific wallet addresses to follow */
  targetAddresses?: string[];
  /** Follow top N from leaderboard */
  topN?: number;

  /** Scale factor for size (0.1 = 10%) */
  sizeScale?: number;
  /** Maximum USDC per trade */
  maxSizePerTrade?: number;
  /** Maximum slippage (e.g., 0.03 = 3%) */
  maxSlippage?: number;
  /** Order type: FOK or FAK */
  orderType?: 'FOK' | 'FAK';
  /** Delay before executing (ms) */
  delay?: number;

  /** Minimum trade value to copy (USDC) */
  minTradeSize?: number;
  /** Only copy BUY or SELL trades */
  sideFilter?: 'BUY' | 'SELL';

  /** Dry run mode */
  dryRun?: boolean;

  /** Callbacks */
  onTrade?: (trade: SmartMoneyTrade, result: OrderResult) => void;
  onError?: (error: Error) => void;
}

/**
 * Auto copy trading statistics
 */
export interface AutoCopyTradingStats {
  startTime: number;
  tradesDetected: number;
  tradesExecuted: number;
  tradesSkipped: number;
  tradesFailed: number;
  totalUsdcSpent: number;
}

/**
 * Auto copy trading subscription
 */
export interface AutoCopyTradingSubscription {
  id: string;
  targetAddresses: string[];
  startTime: number;
  isActive: boolean;
  stats: AutoCopyTradingStats;
  stop: () => void;
  getStats: () => AutoCopyTradingStats;
}

/**
 * Service configuration
 */
export interface SmartMoneyServiceConfig {
  /** Minimum PnL to be considered Smart Money (default: $1000) */
  minPnl?: number;
  /** Cache TTL (default: 300000 = 5 min) */
  cacheTtl?: number;
}

// ============================================================================
// Leaderboard & Report Types
// ============================================================================

/**
 * Leaderboard query options
 */
export interface LeaderboardOptions {
  /** Time period: 'day' | 'week' | 'month' | 'all' */
  period?: TimePeriod;
  /** Maximum entries (default: 50, max: 500) */
  limit?: number;
  /** Sort by: 'pnl' | 'volume' */
  sortBy?: 'pnl' | 'volume';
  /** Pagination offset (default: 0, max: 10000) */
  offset?: number;
}

/**
 * Smart Money Leaderboard entry (extended from PeriodLeaderboardEntry)
 */
export interface SmartMoneyLeaderboardEntry {
  address: string;
  rank: number;
  pnl: number;
  volume: number;
  tradeCount: number;
  userName?: string;
  profileImage?: string;
  // 社交信息 (来自官方 API)
  xUsername?: string;       // Twitter/X 用户名
  verifiedBadge?: boolean;  // 是否已验证
  // Extended fields from PeriodLeaderboardEntry
  totalPnl: number;
  realizedPnl: number;
  unrealizedPnl: number;
  buyCount: number;
  sellCount: number;
  buyVolume: number;
  sellVolume: number;
  makerVolume: number;
  takerVolume: number;
}

/**
 * Leaderboard result with proper semantics
 *
 * Note: Polymarket API doesn't return total count.
 */
export interface SmartMoneyLeaderboardResult {
  /** Leaderboard entries returned by the API */
  entries: SmartMoneyLeaderboardEntry[];
  /** Whether there may be more entries (entries.length === request.limit) */
  hasMore: boolean;
  /** Echo of request parameters for pagination convenience */
  request: {
    offset: number;
    limit: number;
  };
}

/**
 * Period ranking info
 */
export interface PeriodRanking {
  rank: number;
  pnl: number;
  volume: number;
}

/**
 * Wallet report - comprehensive wallet analysis
 */
export interface WalletReport {
  address: string;
  generatedAt: Date;

  overview: {
    totalPnL: number;
    realizedPnL: number;
    unrealizedPnL: number;
    positionCount: number;
    tradeCount: number;
    smartScore: number;
    lastActiveAt: Date;
  };

  rankings: {
    daily: PeriodRanking | null;
    weekly: PeriodRanking | null;
    monthly: PeriodRanking | null;
    allTime: PeriodRanking | null;
  };

  performance: {
    winRate: number;
    winCount: number;
    lossCount: number;
    avgPositionSize: number;
    avgWinAmount: number;
    avgLossAmount: number;
    uniqueMarkets: number;
  };

  categoryBreakdown: Array<{
    category: string;
    positionCount: number;
    totalPnl: number;
  }>;

  topPositions: Array<{
    market: string;
    slug?: string;
    outcome: string;
    size: number;
    avgPrice: number;
    currentPrice?: number;
    pnl: number;
    percentPnl?: number;
  }>;

  recentTrades: Array<{
    timestamp: number;
    side: 'BUY' | 'SELL';
    size: number;
    price: number;
    usdcSize?: number;
    // Market info
    title?: string;
    slug?: string;
    outcome?: string;
    conditionId?: string;
  }>;

  activitySummary: {
    totalBuys: number;
    totalSells: number;
    buyVolume: number;
    sellVolume: number;
    activeMarketsCount: number;
  };
}

/**
 * Wallet comparison result
 */
export interface WalletComparison {
  period: TimePeriod;
  generatedAt: Date;
  wallets: Array<{
    address: string;
    userName?: string;
    rank: number | null;
    pnl: number;
    volume: number;
    positionCount: number;
    winRate: number;
  }>;
}

// ============================================================================
// Report Types (02-smart-money)
// ============================================================================

/**
 * Category color scheme for charts
 */
export const CATEGORY_COLORS: Record<MarketCategory, string> = {
  crypto: '#f7931a',      // Bitcoin orange
  politics: '#3b82f6',    // Blue
  sports: '#22c55e',      // Green
  entertainment: '#a855f7', // Purple
  economics: '#eab308',   // Yellow
  science: '#06b6d4',     // Cyan
  other: '#6b7280',       // Gray
};

/**
 * Category labels for display
 */
export const CATEGORY_LABELS: Record<MarketCategory, string> = {
  crypto: 'Crypto',
  politics: 'Politics',
  sports: 'Sports',
  entertainment: 'Entertainment',
  economics: 'Economics',
  science: 'Science',
  other: 'Other',
};

/**
 * Daily summary statistics
 */
export interface DailySummary {
  totalTrades: number;
  buyCount: number;
  sellCount: number;
  buyVolume: number;
  sellVolume: number;
  realizedPnL: number;
  positionsClosed: number;
  positionsOpened: number;
}

/**
 * Category statistics for breakdown
 */
export interface CategoryStats {
  category: MarketCategory;
  tradeCount: number;
  volume: number;
  pnl: number;
  percentage: number;
}

/**
 * Trade record for significant trades
 */
export interface TradeRecord {
  market: string;
  conditionId?: string;
  outcome: string;
  side: 'BUY' | 'SELL';
  price: number;
  size: number;
  usdcValue: number;
  timestamp: Date;
}

/**
 * Position summary
 */
export interface PositionSummary {
  market: string;
  conditionId?: string;
  outcome: string;
  size: number;
  avgPrice: number;
}

/**
 * Closed market summary
 */
export interface ClosedMarketSummary {
  market: string;
  conditionId: string;
  outcome: string;
  realizedPnL: number;
  closePrice: number;
}

/**
 * Daily wallet report
 */
export interface DailyWalletReport {
  address: string;
  reportDate: string;  // "YYYY-MM-DD"
  generatedAt: Date;
  summary: DailySummary;
  categoryBreakdown: CategoryStats[];
  significantTrades: TradeRecord[];
  newPositions: PositionSummary[];
  closedMarkets: ClosedMarketSummary[];
}

/**
 * Data range for lifecycle report
 */
export interface DataRange {
  firstActivityAt: Date;
  lastActivityAt: Date;
  totalDays: number;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  totalPnL: number;
  realizedPnL: number;
  unrealizedPnL: number;
  totalVolume: number;
  winRate: number;           // 0-1
  profitFactor: number;      // total profit / total loss
  avgWin: number;
  avgLoss: number;
  maxWin: number;
  maxLoss: number;
  totalMarketsTraded: number;
  winningMarkets: number;
  losingMarkets: number;
}

/**
 * Market statistics for top/worst markets
 */
export interface MarketStats {
  market: string;
  conditionId: string;
  category: MarketCategory;
  pnl: number;
  volume: number;
  tradeCount: number;
  outcome: 'win' | 'lose' | 'open';
  avgPrice: number;
  closePrice?: number;
}

/**
 * Trading patterns analysis
 */
export interface TradingPatterns {
  avgTradesPerDay: number;
  avgTradesPerWeek: number;
  preferredSide: 'YES' | 'NO' | 'balanced';
  avgPositionSize: number;
  avgHoldingDays: number;
  topCategories: MarketCategory[];
  positionConcentration: number;  // max single position share
}

/**
 * Current positions summary
 */
export interface CurrentPositionsSummary {
  count: number;
  totalValue: number;
  unrealizedPnL: number;
  categories: CategoryStats[];
}

/**
 * Wallet lifecycle report
 */
export interface WalletLifecycleReport {
  address: string;
  generatedAt: Date;
  dataRange: DataRange;
  performance: PerformanceMetrics;
  categoryDistribution: CategoryStats[];
  topMarkets: MarketStats[];
  worstMarkets: MarketStats[];
  patterns: TradingPatterns;
  currentPositions: CurrentPositionsSummary;
}

/**
 * Pie chart slice
 */
export interface PieSlice {
  name: string;
  value: number;
  percentage: number;
  color: string;
}

/**
 * Pie chart data
 */
export interface PieChartData {
  name: string;
  data: PieSlice[];
  total: number;
}

/**
 * Bar chart item
 */
export interface BarItem {
  label: string;
  value: number;
  color: string;
}

/**
 * Bar chart data
 */
export interface BarChartData {
  name: string;
  data: BarItem[];
}

/**
 * Monthly PnL item
 */
export interface MonthlyPnLItem extends BarItem {
  month: string;
  pnl: number;
  tradeCount: number;
  cumulativePnL: number;
}

/**
 * Monthly PnL chart data
 */
export interface MonthlyPnLData extends BarChartData {
  data: MonthlyPnLItem[];
}

/**
 * Chart metadata
 */
export interface ChartMetadata {
  address: string;
  generatedAt: Date;
  dataRange: {
    from: Date;
    to: Date;
  };
}

/**
 * Wallet chart data
 */
export interface WalletChartData {
  tradeDistribution: PieChartData;
  positionDistribution: PieChartData;
  profitDistribution: PieChartData;
  monthlyPnL?: MonthlyPnLData;
  metadata: ChartMetadata;
}

/**
 * Report generation progress callback
 */
export type ReportProgressCallback = (progress: number, message: string) => void;

/**
 * Lifecycle report options
 */
export interface LifecycleReportOptions {
  onProgress?: ReportProgressCallback;
}

/**
 * Text report output
 */
export interface TextReport {
  address: string;
  generatedAt: Date;
  markdown: string;
  metrics: {
    totalPnL: number;
    winRate: number;
    profitFactor: number;
    totalMarketsTraded: number;
    totalDays: number;
  };
}

/**
 * Trading style analysis
 */
interface TradingStyle {
  positionPreference: string;
  tradingFrequency: string;
  positionManagement: string;
  primaryFocus: string;
}

/**
 * Risk assessment
 */
interface RiskAssessment {
  concentrationRisk: string;
  drawdownRisk: string;
  overallRisk: string;
}

/**
 * Copy trading recommendation
 */
interface CopyRecommendation {
  verdict: string;
  reasoning: string;
  suitableMarkets: string[];
  avoidMarkets: string[];
  warnings: string[];
}

// ============================================================================
// SmartMoneyService
// ============================================================================

export class SmartMoneyService {
  private walletService: WalletService;
  private realtimeService: RealtimeServiceV2;
  private tradingService: TradingService;
  private dataApi: DataApiClient | null;
  private config: Required<SmartMoneyServiceConfig>;

  private smartMoneyCache: Map<string, SmartMoneyWallet> = new Map();
  private smartMoneySet: Set<string> = new Set();
  private cacheTimestamp: number = 0;

  private activeSubscription: { unsubscribe: () => void } | null = null;
  private tradeHandlers: Set<(trade: SmartMoneyTrade) => void> = new Set();

  constructor(
    walletService: WalletService,
    realtimeService: RealtimeServiceV2,
    tradingService: TradingService,
    config: SmartMoneyServiceConfig = {},
    dataApi?: DataApiClient
  ) {
    this.walletService = walletService;
    this.realtimeService = realtimeService;
    this.tradingService = tradingService;
    this.dataApi = dataApi ?? null;

    this.config = {
      minPnl: config.minPnl ?? 1000,
      cacheTtl: config.cacheTtl ?? 300000,
    };
  }

  /**
   * Set DataApiClient for report generation
   * This allows setting the client after construction
   */
  setDataApiClient(dataApi: DataApiClient): void {
    this.dataApi = dataApi;
  }

  // ============================================================================
  // Smart Money Info
  // ============================================================================

  /**
   * Get list of Smart Money wallets from leaderboard
   */
  async getSmartMoneyList(limit: number = 100): Promise<SmartMoneyWallet[]> {
    if (this.isCacheValid()) {
      return Array.from(this.smartMoneyCache.values());
    }

    const leaderboardPage = await this.walletService.getLeaderboard(0, limit);
    const entries = leaderboardPage.entries;

    const smartMoneyList: SmartMoneyWallet[] = [];

    for (let i = 0; i < entries.length; i++) {
      const trader = entries[i];
      if (trader.pnl < this.config.minPnl) continue;

      const wallet: SmartMoneyWallet = {
        address: trader.address.toLowerCase(),
        name: trader.userName,
        pnl: trader.pnl,
        volume: trader.volume,
        score: Math.min(100, Math.round((trader.pnl / 100000) * 50 + (trader.volume / 1000000) * 50)),
        rank: trader.rank ?? i + 1,
      };

      smartMoneyList.push(wallet);
      this.smartMoneyCache.set(wallet.address, wallet);
      this.smartMoneySet.add(wallet.address);
    }

    this.cacheTimestamp = Date.now();
    return smartMoneyList;
  }

  /**
   * Check if an address is Smart Money
   */
  async isSmartMoney(address: string): Promise<boolean> {
    const normalized = address.toLowerCase();
    if (this.isCacheValid()) {
      return this.smartMoneySet.has(normalized);
    }
    await this.getSmartMoneyList();
    return this.smartMoneySet.has(normalized);
  }

  /**
   * Get Smart Money info for an address
   */
  async getSmartMoneyInfo(address: string): Promise<SmartMoneyWallet | null> {
    const normalized = address.toLowerCase();
    if (this.isCacheValid() && this.smartMoneyCache.has(normalized)) {
      return this.smartMoneyCache.get(normalized)!;
    }
    await this.getSmartMoneyList();
    return this.smartMoneyCache.get(normalized) || null;
  }

  // ============================================================================
  // Trade Subscription - 监听交易
  // ============================================================================

  /**
   * Subscribe to trades from specific addresses
   *
   * @example
   * ```typescript
   * const sub = smartMoneyService.subscribeSmartMoneyTrades(
   *   (trade) => {
   *     console.log(`${trade.traderName} ${trade.side} ${trade.size} @ ${trade.price}`);
   *   },
   *   { filterAddresses: ['0x1234...', '0x5678...'] }
   * );
   *
   * // Stop listening
   * sub.unsubscribe();
   * ```
   */
  subscribeSmartMoneyTrades(
    onTrade: (trade: SmartMoneyTrade) => void,
    options: {
      filterAddresses?: string[];
      minSize?: number;
      smartMoneyOnly?: boolean;
    } = {}
  ): { id: string; unsubscribe: () => void } {
    this.tradeHandlers.add(onTrade);

    // Ensure cache is populated
    this.getSmartMoneyList().catch(() => {});

    // Start subscription if not active
    if (!this.activeSubscription) {
      this.activeSubscription = this.realtimeService.subscribeAllActivity({
        onTrade: (activityTrade: ActivityTrade) => {
          this.handleActivityTrade(activityTrade, options);
        },
        onError: (error) => {
          console.error('[SmartMoneyService] Subscription error:', error);
        },
      });
    }

    return {
      id: `smart_money_${Date.now()}`,
      unsubscribe: () => {
        this.tradeHandlers.delete(onTrade);
        if (this.tradeHandlers.size === 0 && this.activeSubscription) {
          this.activeSubscription.unsubscribe();
          this.activeSubscription = null;
        }
      },
    };
  }

  private async handleActivityTrade(
    trade: ActivityTrade,
    options: { filterAddresses?: string[]; minSize?: number; smartMoneyOnly?: boolean }
  ): Promise<void> {
    const rawAddress = trade.trader?.address;
    if (!rawAddress) return;

    const traderAddress = rawAddress.toLowerCase();

    // Address filter
    if (options.filterAddresses && options.filterAddresses.length > 0) {
      const normalized = options.filterAddresses.map(a => a.toLowerCase());
      if (!normalized.includes(traderAddress)) return;
    }

    // Size filter
    if (options.minSize && trade.size < options.minSize) return;

    // Smart Money filter
    const isSmartMoney = this.smartMoneySet.has(traderAddress);
    if (options.smartMoneyOnly && !isSmartMoney) return;

    const smartMoneyTrade: SmartMoneyTrade = {
      traderAddress,
      traderName: trade.trader?.name,
      conditionId: trade.conditionId,
      marketSlug: trade.marketSlug,
      side: trade.side,
      size: trade.size,
      price: trade.price,
      tokenId: trade.asset,
      outcome: trade.outcome,
      txHash: trade.transactionHash,
      timestamp: trade.timestamp,
      isSmartMoney,
      smartMoneyInfo: this.smartMoneyCache.get(traderAddress),
    };

    for (const handler of this.tradeHandlers) {
      try {
        handler(smartMoneyTrade);
      } catch (error) {
        console.error('[SmartMoneyService] Handler error:', error);
      }
    }
  }

  // ============================================================================
  // Auto Copy Trading - 自动跟单
  // ============================================================================

  /**
   * Start auto copy trading - 自动跟单
   *
   * @example
   * ```typescript
   * const sub = await smartMoneyService.startAutoCopyTrading({
   *   targetAddresses: ['0x1234...'],
   *   // 或者跟踪排行榜前N名
   *   topN: 10,
   *
   *   sizeScale: 0.1,        // 10%
   *   maxSizePerTrade: 50,   // $50
   *   maxSlippage: 0.03,     // 3%
   *   orderType: 'FOK',
   *
   *   dryRun: true,          // 测试模式
   *
   *   onTrade: (trade, result) => console.log(result),
   * });
   *
   * // 停止
   * sub.stop();
   * ```
   */
  async startAutoCopyTrading(options: AutoCopyTradingOptions): Promise<AutoCopyTradingSubscription> {
    const startTime = Date.now();

    // Build target list
    let targetAddresses: string[] = [];

    if (options.targetAddresses?.length) {
      targetAddresses = options.targetAddresses.map(a => a.toLowerCase());
    }

    if (options.topN && options.topN > 0) {
      const smartMoneyList = await this.getSmartMoneyList(options.topN);
      const topAddresses = smartMoneyList.map(w => w.address);
      targetAddresses = [...new Set([...targetAddresses, ...topAddresses])];
    }

    if (targetAddresses.length === 0) {
      throw new Error('No target addresses. Use targetAddresses or topN.');
    }

    // Stats
    const stats: AutoCopyTradingStats = {
      startTime,
      tradesDetected: 0,
      tradesExecuted: 0,
      tradesSkipped: 0,
      tradesFailed: 0,
      totalUsdcSpent: 0,
    };

    // Config
    const sizeScale = options.sizeScale ?? 0.1;
    const maxSizePerTrade = options.maxSizePerTrade ?? 50;
    const maxSlippage = options.maxSlippage ?? 0.03;
    const orderType = options.orderType ?? 'FOK';
    const minTradeSize = options.minTradeSize ?? 10;
    const sideFilter = options.sideFilter;
    const delay = options.delay ?? 0;
    const dryRun = options.dryRun ?? false;

    // Subscribe
    const subscription = this.subscribeSmartMoneyTrades(
      async (trade: SmartMoneyTrade) => {
        stats.tradesDetected++;

        try {
          // Check target
          if (!targetAddresses.includes(trade.traderAddress.toLowerCase())) {
            return;
          }

          // Filters
          const tradeValue = trade.size * trade.price;
          if (tradeValue < minTradeSize) {
            stats.tradesSkipped++;
            return;
          }

          if (sideFilter && trade.side !== sideFilter) {
            stats.tradesSkipped++;
            return;
          }

          // Calculate size
          let copySize = trade.size * sizeScale;
          let copyValue = copySize * trade.price;

          // Enforce max size
          if (copyValue > maxSizePerTrade) {
            copySize = maxSizePerTrade / trade.price;
            copyValue = maxSizePerTrade;
          }

          // Polymarket minimum order is $1
          const MIN_ORDER_SIZE = 1;
          if (copyValue < MIN_ORDER_SIZE) {
            stats.tradesSkipped++;
            return;
          }

          // Delay
          if (delay > 0) {
            await new Promise(resolve => setTimeout(resolve, delay));
          }

          // Token
          const tokenId = trade.tokenId;
          if (!tokenId) {
            stats.tradesSkipped++;
            return;
          }

          // Price with slippage
          const slippagePrice = trade.side === 'BUY'
            ? trade.price * (1 + maxSlippage)
            : trade.price * (1 - maxSlippage);

          const usdcAmount = copyValue; // Already calculated above

          // Execute
          let result: OrderResult;

          if (dryRun) {
            result = { success: true, orderId: `dry_run_${Date.now()}` };
            console.log('[DRY RUN]', {
              trader: trade.traderAddress.slice(0, 10),
              side: trade.side,
              market: trade.marketSlug,
              copy: { size: copySize.toFixed(2), usdc: usdcAmount.toFixed(2) },
            });
          } else {
            result = await this.tradingService.createMarketOrder({
              tokenId,
              side: trade.side,
              amount: usdcAmount,
              price: slippagePrice,
              orderType,
            });
          }

          if (result.success) {
            stats.tradesExecuted++;
            stats.totalUsdcSpent += usdcAmount;
          } else {
            stats.tradesFailed++;
          }

          options.onTrade?.(trade, result);
        } catch (error) {
          stats.tradesFailed++;
          options.onError?.(error instanceof Error ? error : new Error(String(error)));
        }
      },
      { filterAddresses: targetAddresses, minSize: minTradeSize }
    );

    return {
      id: subscription.id,
      targetAddresses,
      startTime,
      isActive: true,
      stats,
      stop: () => subscription.unsubscribe(),
      getStats: () => ({ ...stats }),
    };
  }

  // ============================================================================
  // Leaderboard - 排行榜
  // ============================================================================

  /**
   * Get leaderboard by time period
   *
   * @example
   * ```typescript
   * // Get weekly top 100 by PnL
   * const leaderboard = await sdk.smartMoney.getLeaderboard({
   *   period: 'week',
   *   limit: 100,
   *   sortBy: 'pnl'
   * });
   * ```
   */
  async getLeaderboard(options: LeaderboardOptions = {}): Promise<SmartMoneyLeaderboardResult> {
    const period = options.period ?? 'week';
    const limit = Math.min(options.limit ?? 50, 500);
    const sortBy = options.sortBy ?? 'pnl';
    const offset = Math.min(options.offset ?? 0, 10000);

    const result = await this.walletService.fetchLeaderboardByPeriod(period, limit, sortBy, 'OVERALL', offset);

    const entries = result.entries.map(e => ({
      address: e.address,
      rank: e.rank,
      pnl: e.pnl,
      volume: e.volume,
      tradeCount: e.tradeCount,
      userName: e.userName,
      profileImage: e.profileImage,
      // 社交信息
      xUsername: e.xUsername,
      verifiedBadge: e.verifiedBadge,
      // Extended fields
      totalPnl: e.totalPnl,
      realizedPnl: e.realizedPnl,
      unrealizedPnl: e.unrealizedPnl,
      buyCount: e.buyCount,
      sellCount: e.sellCount,
      buyVolume: e.buyVolume,
      sellVolume: e.sellVolume,
      makerVolume: e.makerVolume,
      takerVolume: e.takerVolume,
    }));

    return {
      entries,
      hasMore: result.hasMore,
      request: result.request,
    };
  }

  // ============================================================================
  // Wallet Report - 钱包报告
  // ============================================================================

  /**
   * Generate comprehensive wallet report
   *
   * @example
   * ```typescript
   * const report = await sdk.smartMoney.getWalletReport('0x...');
   * console.log(report.overview.totalPnL);
   * console.log(report.rankings.weekly?.rank);
   * ```
   */
  async getWalletReport(address: string): Promise<WalletReport> {
    // Fetch all data in parallel
    const [
      profile,
      positions,
      activitySummary,
      dailyPnl,
      weeklyPnl,
      monthlyPnl,
      allTimePnl,
    ] = await Promise.all([
      this.walletService.getWalletProfile(address),
      this.walletService.getWalletPositions(address),
      this.walletService.getWalletActivity(address, 100),
      this.walletService.getUserPeriodPnl(address, 'day').catch(() => null),
      this.walletService.getUserPeriodPnl(address, 'week').catch(() => null),
      this.walletService.getUserPeriodPnl(address, 'month').catch(() => null),
      this.walletService.getUserPeriodPnl(address, 'all').catch(() => null),
    ]);

    // Calculate performance metrics
    const winningPositions = positions.filter(p => (p.cashPnl ?? 0) > 0);
    const losingPositions = positions.filter(p => (p.cashPnl ?? 0) < 0);

    // Use initialValue (cost basis) instead of currentValue (which is 0 for settled markets)
    const avgPositionSize = positions.length > 0
      ? positions.reduce((sum, p) => sum + (p.initialValue ?? (p.size * p.avgPrice)), 0) / positions.length
      : 0;

    const avgWinAmount = winningPositions.length > 0
      ? winningPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0) / winningPositions.length
      : 0;

    const avgLossAmount = losingPositions.length > 0
      ? Math.abs(losingPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0) / losingPositions.length)
      : 0;

    const uniqueMarkets = new Set(positions.map(p => p.conditionId)).size;

    // Category analysis
    const categoryStats = this.analyzeCategories(positions);

    // Recent trades
    const trades = activitySummary.activities.filter(a => a.type === 'TRADE');
    const recentTrades = trades.slice(0, 10);

    // Build rankings
    const toRanking = (entry: PeriodLeaderboardEntry | null): PeriodRanking | null => {
      if (!entry) return null;
      return { rank: entry.rank, pnl: entry.pnl, volume: entry.volume };
    };

    return {
      address,
      generatedAt: new Date(),

      overview: {
        totalPnL: profile.totalPnL,
        realizedPnL: profile.realizedPnL,
        unrealizedPnL: profile.unrealizedPnL,
        positionCount: positions.length,
        tradeCount: profile.tradeCount,
        smartScore: profile.smartScore,
        lastActiveAt: profile.lastActiveAt,
      },

      rankings: {
        daily: toRanking(dailyPnl),
        weekly: toRanking(weeklyPnl),
        monthly: toRanking(monthlyPnl),
        allTime: toRanking(allTimePnl),
      },

      performance: {
        winRate: positions.length > 0 ? (winningPositions.length / positions.length) * 100 : 0,
        winCount: winningPositions.length,
        lossCount: losingPositions.length,
        avgPositionSize,
        avgWinAmount,
        avgLossAmount,
        uniqueMarkets,
      },

      categoryBreakdown: categoryStats,

      topPositions: positions
        .sort((a, b) => Math.abs(b.cashPnl ?? 0) - Math.abs(a.cashPnl ?? 0))
        .slice(0, 10)
        .map(p => ({
          market: p.title,
          slug: p.slug,
          outcome: p.outcome,
          size: p.size,
          avgPrice: p.avgPrice,
          currentPrice: p.curPrice,
          pnl: p.cashPnl ?? 0,
          percentPnl: p.percentPnl,
        })),

      recentTrades: recentTrades.map(t => ({
        timestamp: t.timestamp,
        side: t.side,
        size: t.size,
        price: t.price,
        usdcSize: t.usdcSize,
        // Include market info for display
        title: t.title,
        slug: t.slug,
        outcome: t.outcome,
        conditionId: t.conditionId,
      })),

      activitySummary: {
        totalBuys: activitySummary.summary.totalBuys,
        totalSells: activitySummary.summary.totalSells,
        buyVolume: activitySummary.summary.buyVolume,
        sellVolume: activitySummary.summary.sellVolume,
        activeMarketsCount: activitySummary.summary.activeMarkets.length,
      },
    };
  }

  /**
   * Analyze position categories based on title keywords
   */
  private analyzeCategories(positions: Position[]): Array<{ category: string; positionCount: number; totalPnl: number }> {
    const categoryStats: Record<string, { count: number; totalPnl: number }> = {};

    for (const pos of positions) {
      const title = (pos.title || '').toLowerCase();
      let category = 'other';

      if (title.includes('trump') || title.includes('biden') || title.includes('election') || title.includes('president') || title.includes('congress')) {
        category = 'politics';
      } else if (title.includes('bitcoin') || title.includes('btc') || title.includes('eth') || title.includes('crypto') || title.includes('solana')) {
        category = 'crypto';
      } else if (title.includes('nba') || title.includes('nfl') || title.includes('soccer') || title.includes('football') || title.includes('ufc') || title.includes('mlb')) {
        category = 'sports';
      } else if (title.includes('fed') || title.includes('inflation') || title.includes('gdp') || title.includes('interest rate') || title.includes('unemployment')) {
        category = 'economy';
      } else if (title.includes('ai') || title.includes('openai') || title.includes('google') || title.includes('apple') || title.includes('tesla')) {
        category = 'tech';
      }

      if (!categoryStats[category]) {
        categoryStats[category] = { count: 0, totalPnl: 0 };
      }
      categoryStats[category].count++;
      categoryStats[category].totalPnl += (pos.cashPnl ?? 0);
    }

    return Object.entries(categoryStats)
      .map(([category, stats]) => ({
        category,
        positionCount: stats.count,
        totalPnl: stats.totalPnl,
      }))
      .sort((a, b) => b.positionCount - a.positionCount);
  }

  // ============================================================================
  // Wallet Comparison - 钱包对比
  // ============================================================================

  /**
   * Compare multiple wallets
   *
   * @example
   * ```typescript
   * const comparison = await sdk.smartMoney.compareWallets(
   *   ['0x111...', '0x222...', '0x333...'],
   *   { period: 'week' }
   * );
   * ```
   */
  async compareWallets(
    addresses: string[],
    options: { period?: TimePeriod } = {}
  ): Promise<WalletComparison> {
    const period = options.period ?? 'week';

    // Fetch data for all wallets in parallel
    const results = await Promise.all(
      addresses.map(async (address) => {
        const [periodPnl, positions] = await Promise.all([
          this.walletService.getUserPeriodPnl(address, period).catch(() => null),
          this.walletService.getWalletPositions(address).catch(() => []),
        ]);

        const winningPositions = positions.filter(p => (p.cashPnl ?? 0) > 0);
        const winRate = positions.length > 0
          ? (winningPositions.length / positions.length) * 100
          : 0;

        return {
          address,
          userName: periodPnl?.userName,
          rank: periodPnl?.rank ?? null,
          pnl: periodPnl?.pnl ?? 0,
          volume: periodPnl?.volume ?? 0,
          positionCount: positions.length,
          winRate,
        };
      })
    );

    // Sort by PnL descending
    results.sort((a, b) => b.pnl - a.pnl);

    return {
      period,
      generatedAt: new Date(),
      wallets: results,
    };
  }

  // ============================================================================
  // Report Generation (02-smart-money)
  // ============================================================================

  /**
   * Get daily wallet report
   *
   * @param address - Wallet address
   * @param date - Date for the report (default: today)
   *
   * @example
   * ```typescript
   * const report = await sdk.smartMoney.getDailyReport('0x...', new Date('2026-01-08'));
   * console.log(report.summary.realizedPnL);
   * ```
   */
  async getDailyReport(address: string, date?: Date): Promise<DailyWalletReport> {
    const targetDate = date || new Date();
    const dateStr = this.formatDate(targetDate);

    // Get start/end of day in Unix seconds
    const startOfDay = new Date(targetDate);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(targetDate);
    endOfDay.setHours(23, 59, 59, 999);

    const startTimestamp = Math.floor(startOfDay.getTime() / 1000);
    const endTimestamp = Math.floor(endOfDay.getTime() / 1000);

    // Fetch activities for the day
    const activitySummary = await this.walletService.getWalletActivity(address, {
      start: startTimestamp,
      end: endTimestamp,
      limit: 500,
    });

    // Fetch closed positions for the day
    const closedPositions = this.dataApi
      ? await this.dataApi.getClosedPositions(address, {
          sortBy: 'TIMESTAMP',
          sortDirection: 'DESC',
          limit: 50,
        })
      : [];

    // Filter closed positions for today
    const todaysClosed = closedPositions.filter(p => {
      const posDate = new Date(p.timestamp);
      return posDate >= startOfDay && posDate <= endOfDay;
    });

    // Calculate summary
    const trades = activitySummary.activities.filter(a => a.type === 'TRADE');
    const buys = trades.filter(t => t.side === 'BUY');
    const sells = trades.filter(t => t.side === 'SELL');

    const summary: DailySummary = {
      totalTrades: trades.length,
      buyCount: buys.length,
      sellCount: sells.length,
      buyVolume: buys.reduce((sum, t) => sum + (t.usdcSize || 0), 0),
      sellVolume: sells.reduce((sum, t) => sum + (t.usdcSize || 0), 0),
      realizedPnL: todaysClosed.reduce((sum, p) => sum + p.realizedPnl, 0),
      positionsClosed: todaysClosed.length,
      positionsOpened: buys.filter(b => {
        // Count unique new positions (approximate)
        return !sells.some(s => s.conditionId === b.conditionId);
      }).length,
    };

    // Calculate category breakdown
    const categoryBreakdown = this.calculateCategoryBreakdownFromActivities(trades);

    // Get significant trades (top 10 by value)
    const significantTrades: TradeRecord[] = trades
      .map(t => ({
        market: t.title || '',
        conditionId: t.conditionId,
        outcome: t.outcome || '',
        side: t.side as 'BUY' | 'SELL',
        price: t.price,
        size: t.size,
        usdcValue: t.usdcSize || t.size * t.price,
        timestamp: new Date(t.timestamp),
      }))
      .sort((a, b) => b.usdcValue - a.usdcValue)
      .slice(0, 10);

    // New positions
    const newPositions: PositionSummary[] = buys
      .filter(b => !sells.some(s => s.conditionId === b.conditionId))
      .slice(0, 10)
      .map(b => ({
        market: b.title || '',
        conditionId: b.conditionId,
        outcome: b.outcome || '',
        size: b.size,
        avgPrice: b.price,
      }));

    // Closed markets
    const closedMarkets: ClosedMarketSummary[] = todaysClosed.map(p => ({
      market: p.title,
      conditionId: p.conditionId,
      outcome: p.outcome,
      realizedPnL: p.realizedPnl,
      closePrice: p.curPrice,
    }));

    return {
      address,
      reportDate: dateStr,
      generatedAt: new Date(),
      summary,
      categoryBreakdown,
      significantTrades,
      newPositions,
      closedMarkets,
    };
  }

  /**
   * Get wallet lifecycle report
   *
   * @param address - Wallet address
   * @param options - Report options with progress callback
   *
   * @example
   * ```typescript
   * const report = await sdk.smartMoney.getLifecycleReport('0x...', {
   *   onProgress: (p, msg) => console.log(`${p * 100}%: ${msg}`)
   * });
   * console.log(report.performance.winRate);
   * ```
   */
  async getLifecycleReport(
    address: string,
    options?: LifecycleReportOptions
  ): Promise<WalletLifecycleReport> {
    const { onProgress } = options || {};

    // 1. Get basic info
    onProgress?.(0.1, 'Fetching profile...');
    const profile = await this.walletService.getWalletProfile(address);

    // 2. Get all closed positions (paginated)
    onProgress?.(0.2, 'Fetching closed positions...');
    const closedPositions = await this.fetchAllClosedPositions(address);

    // 3. Get current positions
    onProgress?.(0.6, 'Fetching current positions...');
    const currentPositions = await this.walletService.getWalletPositions(address);

    // 4. Calculate metrics
    onProgress?.(0.8, 'Calculating metrics...');
    const performance = this.calculatePerformanceMetricsFromClosed(closedPositions, currentPositions);
    const categoryDistribution = this.calculateCategoryDistributionFromClosed(closedPositions);
    const topMarkets = this.getTopMarkets(closedPositions, 10);
    const worstMarkets = this.getWorstMarkets(closedPositions, 10);
    const patterns = this.analyzeTradingPatterns(closedPositions, currentPositions);

    // 5. Determine data range
    let firstActivityAt = new Date();
    let lastActivityAt = new Date();
    let totalDays = 0;

    if (closedPositions.length > 0) {
      const timestamps = closedPositions.map(p => p.timestamp);
      firstActivityAt = new Date(Math.min(...timestamps));
      lastActivityAt = new Date(Math.max(...timestamps));
      totalDays = Math.ceil(
        (lastActivityAt.getTime() - firstActivityAt.getTime()) / (1000 * 60 * 60 * 24)
      );
    }

    // 6. Current positions summary
    const currentPosCategories = this.calculateCategoryDistributionFromPositions(currentPositions);
    const currentPositionsSummary: CurrentPositionsSummary = {
      count: currentPositions.length,
      totalValue: currentPositions.reduce((sum, p) => sum + (p.currentValue ?? p.size * (p.curPrice ?? 0)), 0),
      unrealizedPnL: currentPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0),
      categories: currentPosCategories,
    };

    onProgress?.(1.0, 'Report generated');

    return {
      address,
      generatedAt: new Date(),
      dataRange: {
        firstActivityAt,
        lastActivityAt,
        totalDays,
      },
      performance,
      categoryDistribution,
      topMarkets,
      worstMarkets,
      patterns,
      currentPositions: currentPositionsSummary,
    };
  }

  /**
   * Get wallet chart data
   *
   * @param address - Wallet address
   *
   * @example
   * ```typescript
   * const chartData = await sdk.smartMoney.getWalletChartData('0x...');
   * // Use chartData.tradeDistribution with recharts
   * ```
   */
  async getWalletChartData(address: string): Promise<WalletChartData> {
    // Fetch data
    const closedPositions = await this.fetchAllClosedPositions(address);
    const currentPositions = await this.walletService.getWalletPositions(address);

    // Trade distribution (by count)
    const tradeDistribution = this.buildPieChart(
      'Trade Distribution',
      closedPositions.map(p => ({ title: p.title, value: 1 })),
      'count'
    );

    // Position distribution (by value)
    const positionDistribution = this.buildPieChart(
      'Position Distribution',
      currentPositions.map(p => ({
        title: p.title,
        value: p.currentValue ?? p.size * (p.curPrice ?? 0),
      })),
      'value'
    );

    // Profit distribution (by PnL)
    const profitPositions = closedPositions.filter(p => p.realizedPnl > 0);
    const profitDistribution = this.buildPieChart(
      'Profit Distribution',
      profitPositions.map(p => ({ title: p.title, value: p.realizedPnl })),
      'pnl'
    );

    // Determine data range
    let fromDate = new Date();
    let toDate = new Date();
    if (closedPositions.length > 0) {
      const timestamps = closedPositions.map(p => p.timestamp);
      fromDate = new Date(Math.min(...timestamps));
      toDate = new Date(Math.max(...timestamps));
    }

    return {
      tradeDistribution,
      positionDistribution,
      profitDistribution,
      metadata: {
        address,
        generatedAt: new Date(),
        dataRange: { from: fromDate, to: toDate },
      },
    };
  }

  /**
   * Generate a text analysis report for a wallet
   *
   * @param address - Wallet address
   * @param options - Report options with progress callback
   *
   * @example
   * ```typescript
   * const textReport = await sdk.smartMoney.generateTextReport('0x...');
   * console.log(textReport.markdown);
   * ```
   */
  async generateTextReport(
    address: string,
    options?: LifecycleReportOptions
  ): Promise<TextReport> {
    const { onProgress } = options || {};

    // Get lifecycle report data
    onProgress?.(0.1, 'Fetching wallet data...');
    const report = await this.getLifecycleReport(address, {
      onProgress: (p, msg) => onProgress?.(0.1 + p * 0.7, msg),
    });

    // Get chart data for category distribution
    onProgress?.(0.8, 'Analyzing patterns...');
    const chartData = await this.getWalletChartData(address);

    // Generate text report
    onProgress?.(0.9, 'Generating report...');
    const markdown = this.buildTextReport(address, report, chartData);

    onProgress?.(1.0, 'Report complete');

    return {
      address,
      generatedAt: new Date(),
      markdown,
      metrics: {
        totalPnL: report.performance.realizedPnL + report.currentPositions.unrealizedPnL,
        winRate: report.performance.winRate,
        profitFactor: report.performance.profitFactor,
        totalMarketsTraded: report.performance.totalMarketsTraded,
        totalDays: report.dataRange.totalDays,
      },
    };
  }

  /**
   * Build markdown text report from data
   */
  private buildTextReport(
    address: string,
    report: WalletLifecycleReport,
    chartData: WalletChartData
  ): string {
    const { performance, categoryDistribution, topMarkets, worstMarkets, patterns, currentPositions, dataRange } = report;

    const totalPnL = performance.realizedPnL + currentPositions.unrealizedPnL;
    const formatPnL = (v: number) => v >= 0 ? `+$${v.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : `-$${Math.abs(v).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    const formatPercent = (v: number) => `${(v * 100).toFixed(1)}%`;
    const formatDate = (d: Date) => d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });

    // Determine trading style
    const tradingStyle = this.analyzeTradingStyle(patterns, categoryDistribution);
    const riskAssessment = this.assessRisk(performance, patterns, categoryDistribution);
    const recommendation = this.generateRecommendation(performance, riskAssessment, tradingStyle);

    const sections: string[] = [];

    // Header
    sections.push(`# Wallet Analysis Report\n`);
    sections.push(`**Address**: \`${address.slice(0, 10)}...${address.slice(-8)}\``);
    sections.push(`**Report Date**: ${formatDate(new Date())}`);
    sections.push(`**Data Range**: ${formatDate(dataRange.firstActivityAt)} - ${formatDate(dataRange.lastActivityAt)} (${dataRange.totalDays} days)\n`);

    // Executive Summary
    sections.push(`## Executive Summary\n`);
    sections.push(`| Metric | Value |`);
    sections.push(`|--------|-------|`);
    sections.push(`| Total PnL | ${formatPnL(totalPnL)} |`);
    sections.push(`| Realized PnL | ${formatPnL(performance.realizedPnL)} |`);
    sections.push(`| Unrealized PnL | ${formatPnL(currentPositions.unrealizedPnL)} |`);
    sections.push(`| Win Rate | ${formatPercent(performance.winRate)} |`);
    sections.push(`| Profit Factor | ${performance.profitFactor.toFixed(2)} |`);
    sections.push(`| Markets Traded | ${performance.totalMarketsTraded} |`);
    sections.push(`| Current Positions | ${currentPositions.count} |`);
    sections.push(``);

    // Trading Style
    sections.push(`## Trading Style Analysis\n`);
    sections.push(`- **Position Preference**: ${tradingStyle.positionPreference}`);
    sections.push(`- **Trading Frequency**: ${tradingStyle.tradingFrequency}`);
    sections.push(`- **Position Management**: ${tradingStyle.positionManagement}`);
    sections.push(`- **Primary Focus**: ${tradingStyle.primaryFocus}`);
    sections.push(``);

    // Category Distribution
    sections.push(`## Market Category Distribution\n`);
    sections.push(`| Category | Trades | PnL | Share |`);
    sections.push(`|----------|--------|-----|-------|`);
    for (const cat of categoryDistribution.slice(0, 6)) {
      sections.push(`| ${CATEGORY_LABELS[cat.category]} | ${cat.tradeCount} | ${formatPnL(cat.pnl)} | ${cat.percentage.toFixed(1)}% |`);
    }
    sections.push(``);

    // Top Markets
    if (topMarkets.length > 0) {
      sections.push(`## Best Performing Markets\n`);
      for (let i = 0; i < Math.min(5, topMarkets.length); i++) {
        const m = topMarkets[i];
        sections.push(`${i + 1}. **${m.market}**: ${formatPnL(m.pnl)}`);
      }
      sections.push(``);
    }

    // Worst Markets
    if (worstMarkets.length > 0) {
      sections.push(`## Worst Performing Markets\n`);
      for (let i = 0; i < Math.min(5, worstMarkets.length); i++) {
        const m = worstMarkets[i];
        sections.push(`${i + 1}. **${m.market}**: ${formatPnL(m.pnl)}`);
      }
      sections.push(``);
    }

    // Risk Assessment
    sections.push(`## Risk Assessment\n`);
    sections.push(`- **Concentration Risk**: ${riskAssessment.concentrationRisk}`);
    sections.push(`- **Drawdown Risk**: ${riskAssessment.drawdownRisk}`);
    sections.push(`- **Overall Risk Level**: ${riskAssessment.overallRisk}`);
    sections.push(``);

    // Copy Trading Recommendation
    sections.push(`## Copy Trading Recommendation\n`);
    sections.push(`**Verdict**: ${recommendation.verdict}\n`);
    sections.push(`${recommendation.reasoning}\n`);
    if (recommendation.suitableMarkets.length > 0) {
      sections.push(`**Suitable Markets**: ${recommendation.suitableMarkets.join(', ')}`);
    }
    if (recommendation.avoidMarkets.length > 0) {
      sections.push(`**Markets to Avoid**: ${recommendation.avoidMarkets.join(', ')}`);
    }
    if (recommendation.warnings.length > 0) {
      sections.push(`\n**Warnings**:`);
      for (const w of recommendation.warnings) {
        sections.push(`- ${w}`);
      }
    }

    return sections.join('\n');
  }

  /**
   * Analyze trading style from patterns
   */
  private analyzeTradingStyle(
    patterns: TradingPatterns,
    categoryDistribution: CategoryStats[]
  ): TradingStyle {
    // Position preference
    let positionPreference: string;
    if (patterns.preferredSide === 'YES') {
      positionPreference = 'YES-biased (tends to bet on positive outcomes)';
    } else if (patterns.preferredSide === 'NO') {
      positionPreference = 'NO-biased (tends to bet against outcomes)';
    } else {
      positionPreference = 'Balanced (no strong directional bias)';
    }

    // Trading frequency
    let tradingFrequency: string;
    if (patterns.avgTradesPerDay > 10) {
      tradingFrequency = 'High-frequency (>10 trades/day)';
    } else if (patterns.avgTradesPerDay > 3) {
      tradingFrequency = 'Active (3-10 trades/day)';
    } else if (patterns.avgTradesPerDay > 1) {
      tradingFrequency = 'Moderate (1-3 trades/day)';
    } else {
      tradingFrequency = 'Low-frequency (<1 trade/day)';
    }

    // Position management
    let positionManagement: string;
    if (patterns.positionConcentration > 0.5) {
      positionManagement = 'Concentrated (high single-position exposure)';
    } else if (patterns.positionConcentration > 0.25) {
      positionManagement = 'Moderate diversification';
    } else {
      positionManagement = 'Well-diversified';
    }

    // Primary focus
    const topCategory = categoryDistribution[0];
    const primaryFocus = topCategory
      ? `${CATEGORY_LABELS[topCategory.category]} (${topCategory.percentage.toFixed(0)}% of trades)`
      : 'Diversified';

    return {
      positionPreference,
      tradingFrequency,
      positionManagement,
      primaryFocus,
    };
  }

  /**
   * Assess risk profile
   */
  private assessRisk(
    performance: PerformanceMetrics,
    patterns: TradingPatterns,
    categoryDistribution: CategoryStats[]
  ): RiskAssessment {
    // Concentration risk
    const topCategoryShare = categoryDistribution[0]?.percentage || 0;
    let concentrationRisk: string;
    if (topCategoryShare > 70) {
      concentrationRisk = 'High (>70% in single category)';
    } else if (topCategoryShare > 50) {
      concentrationRisk = 'Medium (50-70% in top category)';
    } else {
      concentrationRisk = 'Low (well diversified)';
    }

    // Drawdown risk
    const maxLossRatio = performance.maxLoss / Math.max(Math.abs(performance.realizedPnL), 1);
    let drawdownRisk: string;
    if (maxLossRatio > 0.5) {
      drawdownRisk = 'High (max loss >50% of total PnL)';
    } else if (maxLossRatio > 0.25) {
      drawdownRisk = 'Medium';
    } else {
      drawdownRisk = 'Low';
    }

    // Overall risk
    let overallRisk: string;
    if (performance.winRate < 0.4 || performance.profitFactor < 1) {
      overallRisk = 'HIGH - Unprofitable strategy';
    } else if (performance.winRate < 0.5 || performance.profitFactor < 1.5) {
      overallRisk = 'MEDIUM - Moderate performance';
    } else if (patterns.positionConcentration > 0.5) {
      overallRisk = 'MEDIUM - High concentration';
    } else {
      overallRisk = 'LOW - Solid track record';
    }

    return { concentrationRisk, drawdownRisk, overallRisk };
  }

  /**
   * Generate copy trading recommendation
   */
  private generateRecommendation(
    performance: PerformanceMetrics,
    risk: RiskAssessment,
    style: TradingStyle
  ): CopyRecommendation {
    const warnings: string[] = [];
    const suitableMarkets: string[] = [];
    const avoidMarkets: string[] = [];

    // Determine verdict
    let verdict: string;
    let reasoning: string;

    if (performance.winRate >= 0.6 && performance.profitFactor >= 1.5) {
      verdict = 'RECOMMENDED';
      reasoning = `This wallet shows consistent profitability with a ${(performance.winRate * 100).toFixed(0)}% win rate and ${performance.profitFactor.toFixed(1)}x profit factor. The trading pattern is suitable for copy trading.`;
    } else if (performance.winRate >= 0.5 && performance.profitFactor >= 1.2) {
      verdict = 'CAUTIOUSLY RECOMMENDED';
      reasoning = `This wallet is profitable but with moderate consistency. Consider following with smaller position sizes.`;
    } else if (performance.realizedPnL > 0) {
      verdict = 'NOT RECOMMENDED';
      reasoning = `While overall profitable, the low win rate (${(performance.winRate * 100).toFixed(0)}%) or profit factor (${performance.profitFactor.toFixed(1)}x) suggests inconsistent performance.`;
    } else {
      verdict = 'AVOID';
      reasoning = `This wallet has negative overall performance. Not suitable for copy trading.`;
    }

    // Add warnings
    if (risk.overallRisk.includes('HIGH')) {
      warnings.push('High risk profile detected');
    }
    if (performance.losingMarkets > performance.winningMarkets) {
      warnings.push('More losing markets than winning markets');
    }
    if (style.tradingFrequency.includes('High-frequency')) {
      warnings.push('High-frequency trading may incur significant fees when copying');
    }

    return {
      verdict,
      reasoning,
      suitableMarkets,
      avoidMarkets,
      warnings,
    };
  }

  // ============================================================================
  // Report Helper Methods
  // ============================================================================

  /**
   * Categorize market based on title keywords
   */
  private categorizeMarket(title: string): MarketCategory {
    const lowerTitle = title.toLowerCase();

    // Crypto
    if (/\b(btc|bitcoin|eth|ethereum|sol|solana|xrp|crypto|doge|ada|matic)\b/.test(lowerTitle)) {
      return 'crypto';
    }

    // Politics
    if (/\b(trump|biden|election|president|senate|congress|vote|political|maga|democrat|republican)\b/.test(lowerTitle)) {
      return 'politics';
    }

    // Sports
    if (/\b(nfl|nba|mlb|nhl|super bowl|world cup|championship|game|match|ufc|soccer|football|basketball)\b/.test(lowerTitle)) {
      return 'sports';
    }

    // Economics
    if (/\b(fed|interest rate|inflation|gdp|recession|economic|unemployment|cpi)\b/.test(lowerTitle)) {
      return 'economics';
    }

    // Entertainment
    if (/\b(oscar|grammy|movie|twitter|celebrity|entertainment|netflix|spotify)\b/.test(lowerTitle)) {
      return 'entertainment';
    }

    // Science
    if (/\b(spacex|nasa|ai|openai|google|apple|tesla|tech|technology|science)\b/.test(lowerTitle)) {
      return 'science';
    }

    return 'other';
  }

  /**
   * Fetch all closed positions with pagination
   */
  private async fetchAllClosedPositions(address: string): Promise<ClosedPosition[]> {
    if (!this.dataApi) {
      return [];
    }

    const allPositions: ClosedPosition[] = [];
    let offset = 0;
    const limit = 50;
    const maxIterations = 200; // Max 10000 positions

    for (let i = 0; i < maxIterations; i++) {
      const result = await this.dataApi.getClosedPositions(address, {
        limit,
        offset,
        sortBy: 'TIMESTAMP',
        sortDirection: 'DESC',
      });

      if (result.length === 0) break;

      allPositions.push(...result);
      offset += limit;

      // If less than limit returned, we've reached the end
      if (result.length < limit) break;
    }

    return allPositions;
  }

  /**
   * Calculate performance metrics from closed positions
   */
  private calculatePerformanceMetricsFromClosed(
    closedPositions: ClosedPosition[],
    currentPositions: Position[]
  ): PerformanceMetrics {
    const wins = closedPositions.filter(p => p.realizedPnl > 0);
    const losses = closedPositions.filter(p => p.realizedPnl < 0);

    const totalWinAmount = wins.reduce((sum, p) => sum + p.realizedPnl, 0);
    const totalLossAmount = Math.abs(losses.reduce((sum, p) => sum + p.realizedPnl, 0));

    const realizedPnL = closedPositions.reduce((sum, p) => sum + p.realizedPnl, 0);
    const unrealizedPnL = currentPositions.reduce((sum, p) => sum + (p.cashPnl ?? 0), 0);

    return {
      totalPnL: realizedPnL + unrealizedPnL,
      realizedPnL,
      unrealizedPnL,
      totalVolume: closedPositions.reduce((sum, p) => sum + p.totalBought, 0),
      winRate: closedPositions.length > 0 ? wins.length / closedPositions.length : 0,
      profitFactor: totalLossAmount > 0 ? totalWinAmount / totalLossAmount : totalWinAmount,
      avgWin: wins.length > 0 ? totalWinAmount / wins.length : 0,
      avgLoss: losses.length > 0 ? totalLossAmount / losses.length : 0,
      maxWin: wins.length > 0 ? Math.max(...wins.map(p => p.realizedPnl)) : 0,
      maxLoss: losses.length > 0 ? Math.max(...losses.map(p => Math.abs(p.realizedPnl))) : 0,
      totalMarketsTraded: closedPositions.length,
      winningMarkets: wins.length,
      losingMarkets: losses.length,
    };
  }

  /**
   * Calculate category distribution from closed positions
   */
  private calculateCategoryDistributionFromClosed(positions: ClosedPosition[]): CategoryStats[] {
    const categoryMap = new Map<MarketCategory, { count: number; volume: number; pnl: number }>();

    for (const pos of positions) {
      const category = this.categorizeMarket(pos.title);
      const current = categoryMap.get(category) || { count: 0, volume: 0, pnl: 0 };
      categoryMap.set(category, {
        count: current.count + 1,
        volume: current.volume + pos.totalBought,
        pnl: current.pnl + pos.realizedPnl,
      });
    }

    const total = positions.length;

    return Array.from(categoryMap.entries())
      .map(([category, stats]) => ({
        category,
        tradeCount: stats.count,
        volume: stats.volume,
        pnl: stats.pnl,
        percentage: total > 0 ? (stats.count / total) * 100 : 0,
      }))
      .sort((a, b) => b.tradeCount - a.tradeCount);
  }

  /**
   * Calculate category distribution from current positions
   */
  private calculateCategoryDistributionFromPositions(positions: Position[]): CategoryStats[] {
    const categoryMap = new Map<MarketCategory, { count: number; volume: number; pnl: number }>();

    for (const pos of positions) {
      const category = this.categorizeMarket(pos.title || '');
      const current = categoryMap.get(category) || { count: 0, volume: 0, pnl: 0 };
      categoryMap.set(category, {
        count: current.count + 1,
        volume: current.volume + (pos.currentValue ?? pos.size * (pos.curPrice ?? 0)),
        pnl: current.pnl + (pos.cashPnl ?? 0),
      });
    }

    const total = positions.length;

    return Array.from(categoryMap.entries())
      .map(([category, stats]) => ({
        category,
        tradeCount: stats.count,
        volume: stats.volume,
        pnl: stats.pnl,
        percentage: total > 0 ? (stats.count / total) * 100 : 0,
      }))
      .sort((a, b) => b.tradeCount - a.tradeCount);
  }

  /**
   * Calculate category breakdown from activity trades
   */
  private calculateCategoryBreakdownFromActivities(
    trades: Array<{ title?: string; usdcSize?: number; size: number; price: number }>
  ): CategoryStats[] {
    const categoryMap = new Map<MarketCategory, { count: number; volume: number }>();

    for (const trade of trades) {
      const category = this.categorizeMarket(trade.title || '');
      const current = categoryMap.get(category) || { count: 0, volume: 0 };
      categoryMap.set(category, {
        count: current.count + 1,
        volume: current.volume + (trade.usdcSize || trade.size * trade.price),
      });
    }

    const total = trades.length;

    return Array.from(categoryMap.entries())
      .map(([category, stats]) => ({
        category,
        tradeCount: stats.count,
        volume: stats.volume,
        pnl: 0, // Not available from trades
        percentage: total > 0 ? (stats.count / total) * 100 : 0,
      }))
      .sort((a, b) => b.tradeCount - a.tradeCount);
  }

  /**
   * Get top markets by PnL
   */
  private getTopMarkets(positions: ClosedPosition[], limit: number): MarketStats[] {
    return positions
      .filter(p => p.realizedPnl > 0)
      .sort((a, b) => b.realizedPnl - a.realizedPnl)
      .slice(0, limit)
      .map(p => ({
        market: p.title,
        conditionId: p.conditionId,
        category: this.categorizeMarket(p.title),
        pnl: p.realizedPnl,
        volume: p.totalBought,
        tradeCount: 1, // Each closed position is one market
        outcome: 'win' as const,
        avgPrice: p.avgPrice,
        closePrice: p.curPrice,
      }));
  }

  /**
   * Get worst markets by PnL
   */
  private getWorstMarkets(positions: ClosedPosition[], limit: number): MarketStats[] {
    return positions
      .filter(p => p.realizedPnl < 0)
      .sort((a, b) => a.realizedPnl - b.realizedPnl)
      .slice(0, limit)
      .map(p => ({
        market: p.title,
        conditionId: p.conditionId,
        category: this.categorizeMarket(p.title),
        pnl: p.realizedPnl,
        volume: p.totalBought,
        tradeCount: 1,
        outcome: 'lose' as const,
        avgPrice: p.avgPrice,
        closePrice: p.curPrice,
      }));
  }

  /**
   * Analyze trading patterns
   */
  private analyzeTradingPatterns(
    closedPositions: ClosedPosition[],
    currentPositions: Position[]
  ): TradingPatterns {
    // Calculate average trades per day/week
    let avgTradesPerDay = 0;
    let avgTradesPerWeek = 0;

    if (closedPositions.length > 0) {
      const timestamps = closedPositions.map(p => p.timestamp);
      const firstDate = new Date(Math.min(...timestamps));
      const lastDate = new Date(Math.max(...timestamps));
      const totalDays = Math.max(1, Math.ceil(
        (lastDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24)
      ));
      avgTradesPerDay = closedPositions.length / totalDays;
      avgTradesPerWeek = avgTradesPerDay * 7;
    }

    // Determine preferred side
    const yesPositions = currentPositions.filter(p =>
      p.outcome?.toLowerCase() === 'yes' || p.outcome?.toLowerCase() === 'up'
    );
    const noPositions = currentPositions.filter(p =>
      p.outcome?.toLowerCase() === 'no' || p.outcome?.toLowerCase() === 'down'
    );

    let preferredSide: 'YES' | 'NO' | 'balanced' = 'balanced';
    if (yesPositions.length > noPositions.length * 1.5) {
      preferredSide = 'YES';
    } else if (noPositions.length > yesPositions.length * 1.5) {
      preferredSide = 'NO';
    }

    // Average position size
    const avgPositionSize = closedPositions.length > 0
      ? closedPositions.reduce((sum, p) => sum + p.totalBought, 0) / closedPositions.length
      : 0;

    // Top categories
    const categoryStats = this.calculateCategoryDistributionFromClosed(closedPositions);
    const topCategories = categoryStats
      .slice(0, 3)
      .map(c => c.category);

    // Position concentration (max single position share)
    const totalValue = currentPositions.reduce((sum, p) =>
      sum + (p.currentValue ?? p.size * (p.curPrice ?? 0)), 0
    );
    const maxPositionValue = currentPositions.length > 0
      ? Math.max(...currentPositions.map(p => p.currentValue ?? p.size * (p.curPrice ?? 0)))
      : 0;
    const positionConcentration = totalValue > 0 ? maxPositionValue / totalValue : 0;

    return {
      avgTradesPerDay,
      avgTradesPerWeek,
      preferredSide,
      avgPositionSize,
      avgHoldingDays: 0, // Would need more data to calculate
      topCategories,
      positionConcentration,
    };
  }

  /**
   * Build pie chart data
   */
  private buildPieChart(
    name: string,
    items: Array<{ title: string; value: number }>,
    _valueField: 'count' | 'value' | 'pnl'
  ): PieChartData {
    const categoryMap = new Map<MarketCategory, number>();

    for (const item of items) {
      const category = this.categorizeMarket(item.title);
      const current = categoryMap.get(category) || 0;
      categoryMap.set(category, current + item.value);
    }

    const total = Array.from(categoryMap.values()).reduce((a, b) => a + b, 0);

    const data: PieSlice[] = Array.from(categoryMap.entries())
      .map(([category, value]) => ({
        name: CATEGORY_LABELS[category],
        value,
        percentage: total > 0 ? (value / total) * 100 : 0,
        color: CATEGORY_COLORS[category],
      }))
      .sort((a, b) => b.value - a.value);

    return { name, data, total };
  }

  /**
   * Format date as YYYY-MM-DD
   */
  private formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // ============================================================================
  // Utilities
  // ============================================================================

  private isCacheValid(): boolean {
    return Date.now() - this.cacheTimestamp < this.config.cacheTtl && this.smartMoneyCache.size > 0;
  }

  disconnect(): void {
    if (this.activeSubscription) {
      this.activeSubscription.unsubscribe();
      this.activeSubscription = null;
    }
    this.tradeHandlers.clear();
    this.smartMoneyCache.clear();
    this.smartMoneySet.clear();
  }
}

================================================================================
// File: src/services/swap-service.ts
================================================================================
/**
 * Swap Service
 *
 * Provides DEX swap functionality on Polygon using QuickSwap V3.
 * Supports swapping between various tokens including MATIC, WETH, USDC, USDC.e, USDT, DAI.
 */

import { ethers, Contract, BigNumber } from 'ethers';

// QuickSwap V3 Contracts on Polygon
export const QUICKSWAP_ROUTER = '0xf5b509bB0909a69B1c207E495f687a596C168E12';
export const QUICKSWAP_QUOTER = '0xa15F0D7377B2A0C0c10db057f641beD21028FC89';
export const QUICKSWAP_FACTORY = '0x411b0fAcC3489691f28ad58c47006AF5E3Ab3A28';

// Wrapped MATIC for swapping native MATIC
export const WMATIC = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270';

/**
 * Supported tokens on Polygon
 *
 * ⚠️ IMPORTANT: USDC vs USDC.e for Polymarket CTF
 *
 * | Token       | Address                                    | Polymarket CTF |
 * |-------------|--------------------------------------------|-----------------
 * | USDC_E      | 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 | ✅ Required    |
 * | USDC/NATIVE | 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359 | ❌ Not accepted|
 *
 * For Polymarket CTF operations (split/merge/redeem):
 * - Use transferUsdcE() to send USDC.e
 * - Use swap('USDC', 'USDC_E', amount) to convert native USDC to USDC.e
 *
 * For general transfers:
 * - transferUsdc() sends native USDC (most DEXs, CEXs use this)
 * - transferUsdcE() sends bridged USDC.e (Polymarket CTF requires this)
 */
export const POLYGON_TOKENS = {
  // Native MATIC (use WMATIC address for swaps)
  MATIC: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',
  WMATIC: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',
  // USDC variants - SEE ABOVE FOR POLYMARKET COMPATIBILITY
  USDC: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',       // Native USDC - NOT for Polymarket CTF
  NATIVE_USDC: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', // Alias for USDC
  USDC_E: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',      // Bridged USDC.e - REQUIRED for Polymarket CTF
  // Other stables
  USDT: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
  DAI: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',
  // ETH
  WETH: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',
} as const;

// Token decimals
export const TOKEN_DECIMALS: Record<string, number> = {
  MATIC: 18,
  WMATIC: 18,
  USDC: 6,
  NATIVE_USDC: 6,
  USDC_E: 6,
  USDT: 6,
  DAI: 18,
  WETH: 18,
};

export type SupportedToken = keyof typeof POLYGON_TOKENS;

// ABIs
const ERC20_ABI = [
  'function balanceOf(address) view returns (uint256)',
  'function decimals() view returns (uint8)',
  'function symbol() view returns (string)',
  'function approve(address spender, uint256 amount) returns (bool)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function transfer(address to, uint256 amount) returns (bool)',
];

const QUICKSWAP_ROUTER_ABI = [
  'function exactInputSingle((address tokenIn, address tokenOut, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 limitSqrtPrice)) external payable returns (uint256 amountOut)',
  'function exactInput((bytes path, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum)) external payable returns (uint256 amountOut)',
];

const QUICKSWAP_QUOTER_ABI = [
  'function quoteExactInputSingle(address tokenIn, address tokenOut, uint256 amountIn, uint160 limitSqrtPrice) external returns (uint256 amountOut, uint16 fee)',
  'function quoteExactInput(bytes path, uint256 amountIn) external returns (uint256 amountOut, uint16[] fees)',
];

const QUICKSWAP_FACTORY_ABI = [
  'function poolByPair(address tokenA, address tokenB) external view returns (address pool)',
];

const WMATIC_ABI = [
  'function deposit() external payable',
  'function withdraw(uint256 amount) external',
];

export interface SwapQuote {
  tokenIn: string;
  tokenOut: string;
  amountIn: string;
  estimatedAmountOut: string;
  minAmountOut: string;
  slippage: number;
  priceImpact: string;
}

/** Quote result from Quoter contract */
export interface QuoteResult {
  possible: boolean;
  tokenIn: string;
  tokenOut: string;
  amountIn: string;
  amountOut: string | null;
  route: string[];
  poolExists: boolean;
  reason?: string;
}

/** Pool info */
export interface PoolInfo {
  tokenA: string;
  tokenB: string;
  poolAddress: string | null;
  exists: boolean;
}

export interface SwapResult {
  success: boolean;
  transactionHash: string;
  tokenIn: string;
  tokenOut: string;
  amountIn: string;
  amountOut: string;
  gasUsed: string;
}

export interface TokenBalance {
  token: string;
  symbol: string;
  balance: string;
  decimals: number;
}

export interface TransferResult {
  success: boolean;
  transactionHash: string;
  token: string;
  to: string;
  amount: string;
  gasUsed: string;
}

export class SwapService {
  private signer: ethers.Wallet;
  private provider: ethers.providers.Provider;
  private router: Contract;
  private quoter: Contract;
  private factory: Contract;

  constructor(signer: ethers.Wallet) {
    // Use signer's provider if available, otherwise create a default Polygon provider
    this.provider = signer.provider || new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
    // Ensure signer is connected to the provider
    this.signer = signer.provider ? signer : signer.connect(this.provider);
    this.router = new Contract(QUICKSWAP_ROUTER, QUICKSWAP_ROUTER_ABI, this.signer);
    this.quoter = new Contract(QUICKSWAP_QUOTER, QUICKSWAP_QUOTER_ABI, this.provider);
    this.factory = new Contract(QUICKSWAP_FACTORY, QUICKSWAP_FACTORY_ABI, this.provider);
  }

  /**
   * Get dynamic gas options for Polygon network
   * Uses RPC fee data with minimum priority fee of 30 gwei
   */
  private async getGasOptions(): Promise<{
    maxPriorityFeePerGas: BigNumber;
    maxFeePerGas: BigNumber;
  }> {
    const feeData = await this.provider.getFeeData();
    const baseFee = feeData.lastBaseFeePerGas || feeData.gasPrice || ethers.utils.parseUnits('100', 'gwei');
    const minPriorityFee = ethers.utils.parseUnits('30', 'gwei');
    const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas && feeData.maxPriorityFeePerGas.gt(minPriorityFee)
      ? feeData.maxPriorityFeePerGas
      : minPriorityFee;
    const maxFeePerGas = baseFee.mul(3).div(2).add(maxPriorityFeePerGas);
    return { maxPriorityFeePerGas, maxFeePerGas };
  }

  /**
   * Get the wallet address
   */
  get address(): string {
    return this.signer.address;
  }

  /**
   * Get token address from symbol
   */
  getTokenAddress(token: string): string {
    const upperToken = token.toUpperCase() as SupportedToken;
    const address = POLYGON_TOKENS[upperToken];
    if (!address) {
      // Check if it's already an address
      if (token.startsWith('0x') && token.length === 42) {
        return token;
      }
      throw new Error(`Unknown token: ${token}. Supported: ${Object.keys(POLYGON_TOKENS).join(', ')}`);
    }
    return address;
  }

  /**
   * Get token decimals
   */
  getTokenDecimals(token: string): number {
    const upperToken = token.toUpperCase();
    return TOKEN_DECIMALS[upperToken] || 18;
  }

  /**
   * Check if a pool exists for a token pair
   */
  async checkPool(tokenA: string, tokenB: string): Promise<PoolInfo> {
    const addressA = this.getTokenAddress(tokenA);
    const addressB = this.getTokenAddress(tokenB);

    try {
      const poolAddress = await this.factory.poolByPair(addressA, addressB);
      const exists = poolAddress !== ethers.constants.AddressZero;

      return {
        tokenA: tokenA.toUpperCase(),
        tokenB: tokenB.toUpperCase(),
        poolAddress: exists ? poolAddress : null,
        exists,
      };
    } catch {
      return {
        tokenA: tokenA.toUpperCase(),
        tokenB: tokenB.toUpperCase(),
        poolAddress: null,
        exists: false,
      };
    }
  }

  /**
   * Get all available pools for supported tokens
   */
  async getAvailablePools(): Promise<PoolInfo[]> {
    const tokens = Object.keys(POLYGON_TOKENS).filter(
      (t) => t !== 'NATIVE_USDC' && t !== 'WMATIC' // Skip aliases
    );
    const pools: PoolInfo[] = [];

    for (let i = 0; i < tokens.length; i++) {
      for (let j = i + 1; j < tokens.length; j++) {
        const pool = await this.checkPool(tokens[i], tokens[j]);
        if (pool.exists) {
          pools.push(pool);
        }
      }
    }

    return pools;
  }

  /**
   * Get a quote for a swap (checks if route is possible)
   */
  async getQuote(
    tokenIn: string,
    tokenOut: string,
    amountIn: string
  ): Promise<QuoteResult> {
    const upperTokenIn = tokenIn.toUpperCase();
    const upperTokenOut = tokenOut.toUpperCase();

    // Handle MATIC → need to use WMATIC for the pool
    const actualTokenIn = upperTokenIn === 'MATIC' ? 'WMATIC' : upperTokenIn;
    const actualTokenOut = upperTokenOut === 'MATIC' ? 'WMATIC' : upperTokenOut;

    const addressIn = this.getTokenAddress(actualTokenIn);
    const addressOut = this.getTokenAddress(actualTokenOut);
    const decimalsIn = this.getTokenDecimals(actualTokenIn);
    const decimalsOut = this.getTokenDecimals(actualTokenOut);
    const amountInWei = ethers.utils.parseUnits(amountIn, decimalsIn);

    // First check if direct pool exists
    const directPool = await this.checkPool(actualTokenIn, actualTokenOut);

    if (directPool.exists) {
      // Try direct quote
      try {
        const result = await this.quoter.callStatic.quoteExactInputSingle(
          addressIn,
          addressOut,
          amountInWei,
          0 // no price limit
        );
        const amountOut = ethers.utils.formatUnits(result.amountOut, decimalsOut);

        return {
          possible: true,
          tokenIn: upperTokenIn,
          tokenOut: upperTokenOut,
          amountIn,
          amountOut,
          route: [upperTokenIn, upperTokenOut],
          poolExists: true,
        };
      } catch {
        // Pool exists but quote failed (maybe low liquidity)
        return {
          possible: false,
          tokenIn: upperTokenIn,
          tokenOut: upperTokenOut,
          amountIn,
          amountOut: null,
          route: [upperTokenIn, upperTokenOut],
          poolExists: true,
          reason: 'Pool exists but insufficient liquidity for this amount',
        };
      }
    }

    // Try multi-hop through USDC or WMATIC
    const intermediates = ['USDC', 'WMATIC', 'WETH'];
    for (const mid of intermediates) {
      if (mid === actualTokenIn || mid === actualTokenOut) continue;

      const pool1 = await this.checkPool(actualTokenIn, mid);
      const pool2 = await this.checkPool(mid, actualTokenOut);

      if (pool1.exists && pool2.exists) {
        // Try multi-hop quote
        try {
          const midAddress = this.getTokenAddress(mid);
          const path = ethers.utils.solidityPack(
            ['address', 'address', 'address'],
            [addressIn, midAddress, addressOut]
          );

          const result = await this.quoter.callStatic.quoteExactInput(path, amountInWei);
          const amountOut = ethers.utils.formatUnits(result.amountOut, decimalsOut);

          return {
            possible: true,
            tokenIn: upperTokenIn,
            tokenOut: upperTokenOut,
            amountIn,
            amountOut,
            route: [upperTokenIn, mid, upperTokenOut],
            poolExists: true,
          };
        } catch {
          // Continue to try other routes
        }
      }
    }

    // No route found
    return {
      possible: false,
      tokenIn: upperTokenIn,
      tokenOut: upperTokenOut,
      amountIn,
      amountOut: null,
      route: [],
      poolExists: false,
      reason: 'No liquidity pool or route available for this pair',
    };
  }

  /**
   * Execute a multi-hop swap
   */
  async swapMultiHop(
    tokenIn: string,
    tokenOut: string,
    amountIn: string,
    route: string[],
    options: { slippage?: number; deadline?: number } = {}
  ): Promise<SwapResult> {
    const { slippage = 0.5, deadline = 300 } = options;

    if (route.length < 2) {
      throw new Error('Route must have at least 2 tokens');
    }

    const upperTokenIn = tokenIn.toUpperCase();
    const upperTokenOut = tokenOut.toUpperCase();

    // Handle MATIC wrapping
    let wrappedAmount = amountIn;
    if (upperTokenIn === 'MATIC') {
      await this.wrapMatic(amountIn);
    }

    // Build path
    const addresses = route.map((t) => {
      const upper = t.toUpperCase();
      return this.getTokenAddress(upper === 'MATIC' ? 'WMATIC' : upper);
    });

    const path = ethers.utils.solidityPack(
      addresses.map(() => 'address'),
      addresses
    );

    const decimalsIn = this.getTokenDecimals(route[0] === 'MATIC' ? 'WMATIC' : route[0]);
    const decimalsOut = this.getTokenDecimals(route[route.length - 1] === 'MATIC' ? 'WMATIC' : route[route.length - 1]);
    const amountInWei = ethers.utils.parseUnits(wrappedAmount, decimalsIn);

    // Get gas options
    const gasOptions = await this.getGasOptions();

    // Check and approve if needed
    const tokenInAddress = addresses[0];
    const tokenContract = new Contract(tokenInAddress, ERC20_ABI, this.signer);
    const currentAllowance = await tokenContract.allowance(this.signer.address, QUICKSWAP_ROUTER);

    if (currentAllowance.lt(amountInWei)) {
      const approveTx = await tokenContract.approve(QUICKSWAP_ROUTER, ethers.constants.MaxUint256, gasOptions);
      await approveTx.wait();
    }

    // Execute multi-hop swap
    const swapParams = {
      path,
      recipient: this.signer.address,
      deadline: Math.floor(Date.now() / 1000) + deadline,
      amountIn: amountInWei,
      amountOutMinimum: 0, // For simplicity; in production use quote with slippage
    };

    const tx = await this.router.exactInput(swapParams, { ...gasOptions, gasLimit: 500000 });
    const receipt = await tx.wait();

    // Get actual output amount
    const tokenOutAddress = addresses[addresses.length - 1];
    const tokenOutContract = new Contract(tokenOutAddress, ERC20_ABI, this.provider);
    const finalBalance = await tokenOutContract.balanceOf(this.signer.address);

    return {
      success: receipt.status === 1,
      transactionHash: receipt.transactionHash,
      tokenIn: upperTokenIn,
      tokenOut: upperTokenOut,
      amountIn,
      amountOut: ethers.utils.formatUnits(finalBalance, decimalsOut),
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Get balances for all supported tokens
   */
  async getBalances(): Promise<TokenBalance[]> {
    const balances: TokenBalance[] = [];

    // Get native MATIC balance
    const maticBalance = await this.provider.getBalance(this.signer.address);
    balances.push({
      token: 'MATIC',
      symbol: 'MATIC',
      balance: ethers.utils.formatEther(maticBalance),
      decimals: 18,
    });

    // Get ERC20 balances
    const tokens = ['USDC', 'USDC_E', 'USDT', 'DAI', 'WETH', 'WMATIC'];
    for (const tokenSymbol of tokens) {
      const address = POLYGON_TOKENS[tokenSymbol as SupportedToken];
      const contract = new Contract(address, ERC20_ABI, this.provider);
      try {
        const balance = await contract.balanceOf(this.signer.address);
        const decimals = TOKEN_DECIMALS[tokenSymbol];
        balances.push({
          token: tokenSymbol,
          symbol: tokenSymbol,
          balance: ethers.utils.formatUnits(balance, decimals),
          decimals,
        });
      } catch {
        // Skip if token query fails
      }
    }

    return balances;
  }

  /**
   * Get balance for a specific token
   */
  async getBalance(token: string): Promise<string> {
    const upperToken = token.toUpperCase();

    if (upperToken === 'MATIC') {
      const balance = await this.provider.getBalance(this.signer.address);
      return ethers.utils.formatEther(balance);
    }

    const address = this.getTokenAddress(token);
    const contract = new Contract(address, ERC20_ABI, this.provider);
    const balance = await contract.balanceOf(this.signer.address);
    const decimals = this.getTokenDecimals(token);
    return ethers.utils.formatUnits(balance, decimals);
  }

  /**
   * Wrap native MATIC to WMATIC
   */
  async wrapMatic(amount: string): Promise<SwapResult> {
    const amountWei = ethers.utils.parseEther(amount);
    const wmatic = new Contract(WMATIC, WMATIC_ABI, this.signer);
    const gasOptions = await this.getGasOptions();

    const tx = await wmatic.deposit({ value: amountWei, ...gasOptions });
    const receipt = await tx.wait();

    return {
      success: true,
      transactionHash: receipt.transactionHash,
      tokenIn: 'MATIC',
      tokenOut: 'WMATIC',
      amountIn: amount,
      amountOut: amount,
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Unwrap WMATIC to native MATIC
   */
  async unwrapMatic(amount: string): Promise<SwapResult> {
    const amountWei = ethers.utils.parseEther(amount);
    const wmatic = new Contract(WMATIC, WMATIC_ABI, this.signer);
    const gasOptions = await this.getGasOptions();

    const tx = await wmatic.withdraw(amountWei, gasOptions);
    const receipt = await tx.wait();

    return {
      success: true,
      transactionHash: receipt.transactionHash,
      tokenIn: 'WMATIC',
      tokenOut: 'MATIC',
      amountIn: amount,
      amountOut: amount,
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Execute a token swap using QuickSwap V3
   */
  async swap(
    tokenIn: string,
    tokenOut: string,
    amountIn: string,
    options: {
      slippage?: number; // Default 0.5%
      deadline?: number; // Default 5 minutes
    } = {}
  ): Promise<SwapResult> {
    const { slippage = 0.5, deadline = 300 } = options;

    const upperTokenIn = tokenIn.toUpperCase();
    const upperTokenOut = tokenOut.toUpperCase();

    // Handle native MATIC swaps
    if (upperTokenIn === 'MATIC' && upperTokenOut === 'WMATIC') {
      return this.wrapMatic(amountIn);
    }
    if (upperTokenIn === 'WMATIC' && upperTokenOut === 'MATIC') {
      return this.unwrapMatic(amountIn);
    }

    // For MATIC input, first wrap to WMATIC
    let actualTokenIn = upperTokenIn;
    let wrappedAmount = amountIn;
    if (upperTokenIn === 'MATIC') {
      await this.wrapMatic(amountIn);
      actualTokenIn = 'WMATIC';
    }

    const tokenInAddress = this.getTokenAddress(actualTokenIn);
    const tokenOutAddress = this.getTokenAddress(tokenOut);
    const decimalsIn = this.getTokenDecimals(actualTokenIn);
    const decimalsOut = this.getTokenDecimals(tokenOut);

    const amountInWei = ethers.utils.parseUnits(wrappedAmount, decimalsIn);

    // Get gas options for all transactions
    const gasOptions = await this.getGasOptions();

    // Check and approve if needed
    const tokenContract = new Contract(tokenInAddress, ERC20_ABI, this.signer);
    const currentAllowance = await tokenContract.allowance(this.signer.address, QUICKSWAP_ROUTER);

    if (currentAllowance.lt(amountInWei)) {
      const approveTx = await tokenContract.approve(QUICKSWAP_ROUTER, ethers.constants.MaxUint256, gasOptions);
      await approveTx.wait();
    }

    // Calculate min output with slippage
    // Only stablecoin pairs can use ~1:1 ratio estimation
    const stablecoins = ['USDC', 'NATIVE_USDC', 'USDC_E', 'USDT', 'DAI'];
    const isStablecoinPair = stablecoins.includes(actualTokenIn) && stablecoins.includes(upperTokenOut);

    let minAmountOut: BigNumber;
    if (isStablecoinPair) {
      // For stablecoin pairs, assume ~1:1 ratio with slippage
      let estimatedOut = amountInWei;
      if (decimalsIn !== decimalsOut) {
        if (decimalsIn > decimalsOut) {
          estimatedOut = amountInWei.div(BigNumber.from(10).pow(decimalsIn - decimalsOut));
        } else {
          estimatedOut = amountInWei.mul(BigNumber.from(10).pow(decimalsOut - decimalsIn));
        }
      }
      const slippageBps = Math.floor(slippage * 100);
      minAmountOut = estimatedOut.mul(10000 - slippageBps).div(10000);
    } else {
      // For non-stablecoin pairs (like MATIC → USDC), set minAmountOut to 0
      // The actual protection comes from the DEX's price oracle
      // In production, you should use a quoter contract for accurate price
      minAmountOut = BigNumber.from(0);
    }

    // Execute swap
    const swapParams = {
      tokenIn: tokenInAddress,
      tokenOut: tokenOutAddress,
      recipient: this.signer.address,
      deadline: Math.floor(Date.now() / 1000) + deadline,
      amountIn: amountInWei,
      amountOutMinimum: minAmountOut,
      limitSqrtPrice: 0,
    };

    const tx = await this.router.exactInputSingle(swapParams, { ...gasOptions, gasLimit: 300000 });
    const receipt = await tx.wait();

    // Get actual output amount
    const tokenOutContract = new Contract(tokenOutAddress, ERC20_ABI, this.provider);
    const finalBalance = await tokenOutContract.balanceOf(this.signer.address);

    return {
      success: true,
      transactionHash: receipt.transactionHash,
      tokenIn: upperTokenIn,
      tokenOut: upperTokenOut,
      amountIn,
      amountOut: ethers.utils.formatUnits(finalBalance, decimalsOut),
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Swap any supported token to USDC (for deposit)
   */
  async swapToUsdc(
    tokenIn: string,
    amountIn: string,
    options: {
      usdcType?: 'NATIVE_USDC' | 'USDC_E';
      slippage?: number;
    } = {}
  ): Promise<SwapResult> {
    const { usdcType = 'NATIVE_USDC', slippage = 0.5 } = options;

    const upperTokenIn = tokenIn.toUpperCase();

    // If already USDC, no swap needed
    if (upperTokenIn === 'USDC' || upperTokenIn === 'NATIVE_USDC') {
      if (usdcType === 'NATIVE_USDC') {
        return {
          success: true,
          transactionHash: '',
          tokenIn: upperTokenIn,
          tokenOut: 'NATIVE_USDC',
          amountIn,
          amountOut: amountIn,
          gasUsed: '0',
        };
      }
      // Swap USDC to USDC.e
      return this.swap('USDC', 'USDC_E', amountIn, { slippage });
    }

    if (upperTokenIn === 'USDC_E') {
      if (usdcType === 'USDC_E') {
        return {
          success: true,
          transactionHash: '',
          tokenIn: upperTokenIn,
          tokenOut: 'USDC_E',
          amountIn,
          amountOut: amountIn,
          gasUsed: '0',
        };
      }
      // Swap USDC.e to USDC
      return this.swap('USDC_E', 'USDC', amountIn, { slippage });
    }

    // Swap other tokens to USDC
    const targetUsdc = usdcType === 'NATIVE_USDC' ? 'USDC' : 'USDC_E';
    return this.swap(tokenIn, targetUsdc, amountIn, { slippage });
  }

  /**
   * Get list of supported tokens
   */
  getSupportedTokens(): string[] {
    return Object.keys(POLYGON_TOKENS);
  }

  /**
   * Get balances for any wallet address (static method, no signer required)
   */
  static async getWalletBalances(
    address: string,
    provider?: ethers.providers.Provider
  ): Promise<TokenBalance[]> {
    const rpcProvider = provider || new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
    const balances: TokenBalance[] = [];

    // Get native MATIC balance
    const maticBalance = await rpcProvider.getBalance(address);
    balances.push({
      token: 'MATIC',
      symbol: 'MATIC',
      balance: ethers.utils.formatEther(maticBalance),
      decimals: 18,
    });

    // Get ERC20 balances
    const tokens = ['USDC', 'USDC_E', 'USDT', 'DAI', 'WETH', 'WMATIC'];
    for (const tokenSymbol of tokens) {
      const tokenAddress = POLYGON_TOKENS[tokenSymbol as SupportedToken];
      const contract = new Contract(tokenAddress, ERC20_ABI, rpcProvider);
      try {
        const balance = await contract.balanceOf(address);
        const decimals = TOKEN_DECIMALS[tokenSymbol];
        balances.push({
          token: tokenSymbol,
          symbol: tokenSymbol,
          balance: ethers.utils.formatUnits(balance, decimals),
          decimals,
        });
      } catch {
        // Skip if token query fails
      }
    }

    return balances;
  }

  /**
   * Get balance for a specific token for any wallet (static)
   */
  static async getWalletBalance(
    address: string,
    token: string,
    provider?: ethers.providers.Provider
  ): Promise<string> {
    const rpcProvider = provider || new ethers.providers.JsonRpcProvider('https://polygon-rpc.com');
    const upperToken = token.toUpperCase();

    if (upperToken === 'MATIC') {
      const balance = await rpcProvider.getBalance(address);
      return ethers.utils.formatEther(balance);
    }

    const tokenAddress = POLYGON_TOKENS[upperToken as SupportedToken];
    if (!tokenAddress) {
      throw new Error(`Unknown token: ${token}`);
    }

    const contract = new Contract(tokenAddress, ERC20_ABI, rpcProvider);
    const balance = await contract.balanceOf(address);
    const decimals = TOKEN_DECIMALS[upperToken] || 18;
    return ethers.utils.formatUnits(balance, decimals);
  }

  // ============= Transfer Methods =============

  /**
   * Transfer native MATIC (POL) to another address
   */
  async transferMatic(to: string, amount: string): Promise<TransferResult> {
    const amountWei = ethers.utils.parseEther(amount);

    // Check balance
    const balance = await this.provider.getBalance(this.signer.address);
    if (balance.lt(amountWei)) {
      throw new Error(`Insufficient MATIC balance: have ${ethers.utils.formatEther(balance)}, need ${amount}`);
    }

    const gasOptions = await this.getGasOptions();

    const tx = await this.signer.sendTransaction({
      to,
      value: amountWei,
      ...gasOptions,
      gasLimit: 21000, // Standard ETH transfer gas limit
    });
    const receipt = await tx.wait();

    return {
      success: true,
      transactionHash: receipt.transactionHash,
      token: 'MATIC',
      to,
      amount,
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Transfer an ERC20 token to another address
   */
  async transfer(token: string, to: string, amount: string): Promise<TransferResult> {
    const upperToken = token.toUpperCase();

    // For native MATIC, use transferMatic
    if (upperToken === 'MATIC') {
      return this.transferMatic(to, amount);
    }

    const tokenAddress = this.getTokenAddress(token);
    const decimals = this.getTokenDecimals(token);
    const amountWei = ethers.utils.parseUnits(amount, decimals);

    const contract = new Contract(tokenAddress, ERC20_ABI, this.signer);

    // Check balance
    const balance = await contract.balanceOf(this.signer.address);
    if (balance.lt(amountWei)) {
      throw new Error(`Insufficient ${upperToken} balance: have ${ethers.utils.formatUnits(balance, decimals)}, need ${amount}`);
    }

    const gasOptions = await this.getGasOptions();

    const tx = await contract.transfer(to, amountWei, {
      ...gasOptions,
      gasLimit: 100000, // ERC20 transfer gas limit (USDC.e needs ~71k)
    });
    const receipt = await tx.wait();

    return {
      success: true,
      transactionHash: receipt.transactionHash,
      token: upperToken,
      to,
      amount,
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  /**
   * Transfer native USDC to another address
   *
   * ⚠️ WARNING: This transfers NATIVE USDC (0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359)
   *
   * For Polymarket CTF operations, you need USDC.e instead.
   * Use transferUsdcE() for Polymarket CTF compatibility.
   *
   * @see transferUsdcE - For Polymarket CTF operations
   */
  async transferUsdc(to: string, amount: string): Promise<TransferResult> {
    return this.transfer('USDC', to, amount);
  }

  /**
   * Transfer USDC.e (bridged USDC) to another address
   *
   * ✅ This is the correct method for Polymarket CTF operations.
   *
   * Polymarket's Conditional Token Framework (CTF) only accepts
   * USDC.e (0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).
   *
   * If you're funding a wallet for CTF trading, use this method.
   *
   * @example
   * ```typescript
   * // Fund a session wallet for Polymarket trading
   * await swapService.transferUsdcE(sessionWallet, '100');
   *
   * // The session wallet can now perform CTF operations
   * await ctf.split(conditionId, '100');
   * ```
   */
  async transferUsdcE(to: string, amount: string): Promise<TransferResult> {
    return this.transfer('USDC_E', to, amount);
  }
}

================================================================================
// File: src/services/trading-service.ts
================================================================================
/**
 * TradingService
 *
 * Trading service using official @polymarket/clob-client.
 *
 * Provides:
 * - Order creation (limit, market)
 * - Order management (cancel, query)
 * - Rewards tracking
 * - Balance management
 *
 * Note: Market data methods have been moved to MarketService.
 */

import {
  ClobClient,
  Side as ClobSide,
  OrderType as ClobOrderType,
  Chain,
  type OpenOrder,
  type Trade as ClobTrade,
  type TickSize,
} from '@polymarket/clob-client';

import { Wallet } from 'ethers';
import { RateLimiter, ApiType } from '../core/rate-limiter.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { CACHE_TTL } from '../core/unified-cache.js';
import { PolymarketError, ErrorCode } from '../core/errors.js';
import type { Side, OrderType } from '../core/types.js';

// Chain IDs
export const POLYGON_MAINNET = 137;
export const POLYGON_AMOY = 80002;

// CLOB Host
const CLOB_HOST = 'https://clob.polymarket.com';

// ============================================================================
// Polymarket Order Minimums
// ============================================================================
// These are enforced by Polymarket's CLOB API. Orders below these limits will
// be rejected with errors like:
// - "invalid amount for a marketable BUY order ($X), min size: $1"
// - "Size (X) lower than the minimum: 5"
//
// Strategies should ensure orders meet these requirements BEFORE sending.
// ============================================================================

/** Minimum order value in USDC (price * size >= MIN_ORDER_VALUE) */
export const MIN_ORDER_VALUE_USDC = 1;

/** Minimum order size in shares */
export const MIN_ORDER_SIZE_SHARES = 5;

// ============================================================================
// Types
// ============================================================================

// Side and OrderType are imported from core/types.ts
// Re-export for backward compatibility
export type { Side, OrderType } from '../core/types.js';

export interface ApiCredentials {
  key: string;
  secret: string;
  passphrase: string;
}

export interface TradingServiceConfig {
  /** Private key for signing */
  privateKey: string;
  /** Chain ID (default: Polygon mainnet 137) */
  chainId?: number;
  /** Pre-generated API credentials (optional) */
  credentials?: ApiCredentials;
}

// Order types
export interface LimitOrderParams {
  tokenId: string;
  side: Side;
  price: number;
  size: number;
  orderType?: 'GTC' | 'GTD';
  expiration?: number;
}

export interface MarketOrderParams {
  tokenId: string;
  side: Side;
  amount: number;
  price?: number;
  orderType?: 'FOK' | 'FAK';
}

export interface Order {
  id: string;
  status: string;
  tokenId: string;
  side: Side;
  price: number;
  originalSize: number;
  filledSize: number;
  remainingSize: number;
  associateTrades: string[];
  createdAt: number;
}

export interface OrderResult {
  success: boolean;
  orderId?: string;
  orderIds?: string[];
  errorMsg?: string;
  transactionHashes?: string[];
}

export interface TradeInfo {
  id: string;
  tokenId: string;
  side: Side;
  price: number;
  size: number;
  fee: number;
  timestamp: number;
}

// Rewards types
export interface UserEarning {
  date: string;
  conditionId: string;
  assetAddress: string;
  makerAddress: string;
  earnings: number;
  assetRate: number;
}

export interface MarketReward {
  conditionId: string;
  question: string;
  marketSlug: string;
  eventSlug: string;
  rewardsMaxSpread: number;
  rewardsMinSize: number;
  tokens: Array<{ tokenId: string; outcome: string; price: number }>;
  rewardsConfig: Array<{
    assetAddress: string;
    startDate: string;
    endDate: string;
    ratePerDay: number;
    totalRewards: number;
  }>;
}

// ============================================================================
// TradingService Implementation
// ============================================================================

export class TradingService {
  private clobClient: ClobClient | null = null;
  private wallet: Wallet;
  private chainId: Chain;
  private credentials: ApiCredentials | null = null;
  private initialized = false;
  private tickSizeCache: Map<string, string> = new Map();
  private negRiskCache: Map<string, boolean> = new Map();

  constructor(
    private rateLimiter: RateLimiter,
    private cache: UnifiedCache,
    private config: TradingServiceConfig
  ) {
    this.wallet = new Wallet(config.privateKey);
    this.chainId = (config.chainId || POLYGON_MAINNET) as Chain;
    this.credentials = config.credentials || null;
  }

  // ============================================================================
  // Initialization
  // ============================================================================

  async initialize(): Promise<void> {
    if (this.initialized) return;

    // Create CLOB client with L1 auth (wallet)
    this.clobClient = new ClobClient(CLOB_HOST, this.chainId, this.wallet);

    // Get or create API credentials
    // We use derive-first strategy (opposite of official createOrDeriveApiKey)
    // because most users already have a key, avoiding unnecessary 400 error logs.
    if (!this.credentials) {
      const creds = await this.deriveOrCreateApiKey();
      this.credentials = {
        key: creds.key,
        secret: creds.secret,
        passphrase: creds.passphrase,
      };
    }

    // Re-initialize with L2 auth (credentials)
    this.clobClient = new ClobClient(
      CLOB_HOST,
      this.chainId,
      this.wallet,
      {
        key: this.credentials.key,
        secret: this.credentials.secret,
        passphrase: this.credentials.passphrase,
      }
    );

    this.initialized = true;
  }

  /**
   * Try to derive existing API key first, create new one if not exists.
   * This is the reverse of official createOrDeriveApiKey() to avoid
   * 400 "Could not create api key" error log for existing keys.
   */
  private async deriveOrCreateApiKey(): Promise<{ key: string; secret: string; passphrase: string }> {
    // First try to derive existing key (most common case for existing users)
    const derived = await this.clobClient!.deriveApiKey();
    if (derived.key) {
      return derived;
    }

    // Derive failed (key doesn't exist), create new key (first-time users)
    const created = await this.clobClient!.createApiKey();
    if (!created.key) {
      throw new PolymarketError(
        ErrorCode.AUTH_FAILED,
        'Failed to create or derive API key. Wallet may not be registered on Polymarket.'
      );
    }
    return created;
  }

  private async ensureInitialized(): Promise<ClobClient> {
    if (!this.initialized || !this.clobClient) {
      await this.initialize();
    }
    return this.clobClient!;
  }

  // ============================================================================
  // Trading Helpers
  // ============================================================================

  /**
   * Get tick size for a token
   */
  async getTickSize(tokenId: string): Promise<TickSize> {
    if (this.tickSizeCache.has(tokenId)) {
      return this.tickSizeCache.get(tokenId)! as TickSize;
    }

    const client = await this.ensureInitialized();
    const tickSize = await client.getTickSize(tokenId);
    this.tickSizeCache.set(tokenId, tickSize);
    return tickSize;
  }

  /**
   * Check if token is neg risk
   */
  async isNegRisk(tokenId: string): Promise<boolean> {
    if (this.negRiskCache.has(tokenId)) {
      return this.negRiskCache.get(tokenId)!;
    }

    const client = await this.ensureInitialized();
    const negRisk = await client.getNegRisk(tokenId);
    this.negRiskCache.set(tokenId, negRisk);
    return negRisk;
  }

  // ============================================================================
  // Order Creation
  // ============================================================================

  /**
   * Create and post a limit order
   *
   * Note: Polymarket enforces minimum order requirements:
   * - Minimum size: 5 shares (MIN_ORDER_SIZE_SHARES)
   * - Minimum value: $1 USDC (MIN_ORDER_VALUE_USDC)
   *
   * Orders below these limits will be rejected by the API.
   */
  async createLimitOrder(params: LimitOrderParams): Promise<OrderResult> {
    // Validate minimum order requirements before sending to API
    if (params.size < MIN_ORDER_SIZE_SHARES) {
      return {
        success: false,
        errorMsg: `Order size (${params.size}) is below Polymarket minimum (${MIN_ORDER_SIZE_SHARES} shares)`,
      };
    }

    const orderValue = params.price * params.size;
    if (orderValue < MIN_ORDER_VALUE_USDC) {
      return {
        success: false,
        errorMsg: `Order value ($${orderValue.toFixed(2)}) is below Polymarket minimum ($${MIN_ORDER_VALUE_USDC})`,
      };
    }

    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      try {
        const [tickSize, negRisk] = await Promise.all([
          this.getTickSize(params.tokenId),
          this.isNegRisk(params.tokenId),
        ]);

        const orderType = params.orderType === 'GTD' ? ClobOrderType.GTD : ClobOrderType.GTC;

        const result = await client.createAndPostOrder(
          {
            tokenID: params.tokenId,
            side: params.side === 'BUY' ? ClobSide.BUY : ClobSide.SELL,
            price: params.price,
            size: params.size,
            expiration: params.expiration || 0,
          },
          { tickSize, negRisk },
          orderType
        );

        const success = result.success === true ||
          (result.success !== false &&
            ((result.orderID !== undefined && result.orderID !== '') ||
              (result.transactionsHashes !== undefined && result.transactionsHashes.length > 0)));

        return {
          success,
          orderId: result.orderID,
          orderIds: result.orderIDs,
          errorMsg: result.errorMsg,
          transactionHashes: result.transactionsHashes,
        };
      } catch (error) {
        return {
          success: false,
          errorMsg: `Order failed: ${error instanceof Error ? error.message : String(error)}`,
        };
      }
    });
  }

  /**
   * Create and post a market order
   *
   * Note: Polymarket enforces minimum order requirements:
   * - Minimum value: $1 USDC (MIN_ORDER_VALUE_USDC)
   *
   * Market orders below this limit will be rejected by the API.
   */
  async createMarketOrder(params: MarketOrderParams): Promise<OrderResult> {
    // Validate minimum order value before sending to API
    if (params.amount < MIN_ORDER_VALUE_USDC) {
      return {
        success: false,
        errorMsg: `Order amount ($${params.amount.toFixed(2)}) is below Polymarket minimum ($${MIN_ORDER_VALUE_USDC})`,
      };
    }

    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      try {
        const [tickSize, negRisk] = await Promise.all([
          this.getTickSize(params.tokenId),
          this.isNegRisk(params.tokenId),
        ]);

        const orderType = params.orderType === 'FAK' ? ClobOrderType.FAK : ClobOrderType.FOK;

        const result = await client.createAndPostMarketOrder(
          {
            tokenID: params.tokenId,
            side: params.side === 'BUY' ? ClobSide.BUY : ClobSide.SELL,
            amount: params.amount,
            price: params.price,
          },
          { tickSize, negRisk },
          orderType
        );

        const success = result.success === true ||
          (result.success !== false &&
            ((result.orderID !== undefined && result.orderID !== '') ||
              (result.transactionsHashes !== undefined && result.transactionsHashes.length > 0)));

        return {
          success,
          orderId: result.orderID,
          orderIds: result.orderIDs,
          errorMsg: result.errorMsg,
          transactionHashes: result.transactionsHashes,
        };
      } catch (error) {
        return {
          success: false,
          errorMsg: `Market order failed: ${error instanceof Error ? error.message : String(error)}`,
        };
      }
    });
  }

  // ============================================================================
  // Order Management
  // ============================================================================

  async cancelOrder(orderId: string): Promise<OrderResult> {
    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      try {
        const result = await client.cancelOrder({ orderID: orderId });
        return { success: result.canceled ?? false, orderId };
      } catch (error) {
        throw new PolymarketError(
          ErrorCode.ORDER_FAILED,
          `Cancel failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  async cancelOrders(orderIds: string[]): Promise<OrderResult> {
    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      try {
        const result = await client.cancelOrders(orderIds);
        return { success: result.canceled ?? false, orderIds };
      } catch (error) {
        throw new PolymarketError(
          ErrorCode.ORDER_FAILED,
          `Cancel orders failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  async cancelAllOrders(): Promise<OrderResult> {
    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      try {
        const result = await client.cancelAll();
        return { success: result.canceled ?? false };
      } catch (error) {
        throw new PolymarketError(
          ErrorCode.ORDER_FAILED,
          `Cancel all failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  async getOpenOrders(marketId?: string): Promise<Order[]> {
    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const orders = await client.getOpenOrders(marketId ? { market: marketId } : undefined);

      return orders.map((o: OpenOrder) => {
        const originalSize = Number(o.original_size) || 0;
        const filledSize = Number(o.size_matched) || 0;
        return {
          id: o.id,
          status: o.status,
          tokenId: o.asset_id,
          side: o.side.toUpperCase() as Side,
          price: Number(o.price) || 0,
          originalSize,
          filledSize,
          remainingSize: originalSize - filledSize,
          associateTrades: o.associate_trades || [],
          createdAt: o.created_at,
        };
      });
    });
  }

  async getTrades(marketId?: string): Promise<TradeInfo[]> {
    const client = await this.ensureInitialized();

    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const trades = await client.getTrades(marketId ? { market: marketId } : undefined);

      return trades.map((t: ClobTrade) => ({
        id: t.id,
        tokenId: t.asset_id,
        side: t.side as Side,
        price: Number(t.price) || 0,
        size: Number(t.size) || 0,
        fee: Number(t.fee_rate_bps) || 0,
        timestamp: Number(t.match_time) || Date.now(),
      }));
    });
  }

  // ============================================================================
  // Rewards
  // ============================================================================

  async isOrderScoring(orderId: string): Promise<boolean> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const result = await client.isOrderScoring({ order_id: orderId });
      return result.scoring;
    });
  }

  async areOrdersScoring(orderIds: string[]): Promise<Record<string, boolean>> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      return await client.areOrdersScoring({ orderIds });
    });
  }

  async getEarningsForDay(date: string): Promise<UserEarning[]> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const earnings = await client.getEarningsForUserForDay(date);
      return earnings.map(e => ({
        date: e.date,
        conditionId: e.condition_id,
        assetAddress: e.asset_address,
        makerAddress: e.maker_address,
        earnings: e.earnings,
        assetRate: e.asset_rate,
      }));
    });
  }

  async getCurrentRewards(): Promise<MarketReward[]> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const rewards = await client.getCurrentRewards();
      return rewards.map(r => ({
        conditionId: r.condition_id,
        question: r.question,
        marketSlug: r.market_slug,
        eventSlug: r.event_slug,
        rewardsMaxSpread: r.rewards_max_spread,
        rewardsMinSize: r.rewards_min_size,
        tokens: r.tokens.map(t => ({
          tokenId: t.token_id,
          outcome: t.outcome,
          price: t.price,
        })),
        rewardsConfig: r.rewards_config.map(c => ({
          assetAddress: c.asset_address,
          startDate: c.start_date,
          endDate: c.end_date,
          ratePerDay: c.rate_per_day,
          totalRewards: c.total_rewards,
        })),
      }));
    });
  }

  // ============================================================================
  // Balance & Allowance
  // ============================================================================

  async getBalanceAllowance(
    assetType: 'COLLATERAL' | 'CONDITIONAL',
    tokenId?: string
  ): Promise<{ balance: string; allowance: string }> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      const result = await client.getBalanceAllowance({
        asset_type: assetType as any,
        token_id: tokenId,
      });
      return { balance: result.balance, allowance: result.allowance };
    });
  }

  async updateBalanceAllowance(
    assetType: 'COLLATERAL' | 'CONDITIONAL',
    tokenId?: string
  ): Promise<void> {
    const client = await this.ensureInitialized();
    return this.rateLimiter.execute(ApiType.CLOB_API, async () => {
      await client.updateBalanceAllowance({
        asset_type: assetType as any,
        token_id: tokenId,
      });
    });
  }

  // ============================================================================
  // Account Info
  // ============================================================================

  getAddress(): string {
    return this.wallet.address;
  }

  getWallet(): Wallet {
    return this.wallet;
  }

  getCredentials(): ApiCredentials | null {
    return this.credentials;
  }

  isInitialized(): boolean {
    return this.initialized;
  }

  getClobClient(): ClobClient | null {
    return this.clobClient;
  }

}

================================================================================
// File: src/services/wallet-service.ts
================================================================================
/**
 * Wallet Service
 *
 * Provides smart money analysis features:
 * - Wallet profile analysis
 * - Position tracking
 * - Activity monitoring
 * - Sell detection for follow wallet strategy
 * - Time-based leaderboard and wallet stats
 */

import {
  DataApiClient,
  Position,
  Activity,
  LeaderboardEntry,
  LeaderboardResult,
  LeaderboardTimePeriod,
  LeaderboardOrderBy,
  LeaderboardCategory,
} from '../clients/data-api.js';
import { SubgraphClient, OrderFilledEvent } from '../clients/subgraph.js';
import type { UnifiedCache } from '../core/unified-cache.js';
import { CACHE_TTL } from '../core/unified-cache.js';

// ===== Time Period Types =====

/** Time period (lowercase for SDK, maps to API's uppercase) */
export type TimePeriod = 'day' | 'week' | 'month' | 'all';

/** Sort criteria for period leaderboard (official API supports PNL and VOL) */
export type LeaderboardSortBy = 'volume' | 'pnl';

// Re-export API types for convenience
export type { LeaderboardTimePeriod, LeaderboardOrderBy, LeaderboardCategory };

/**
 * Collateral Asset ID (USDC)
 * In Polymarket orderbook, "0" represents the collateral token (USDC)
 */
const COLLATERAL_ASSET_ID = '0';

/**
 * Check if an asset ID is collateral (USDC) or outcome token
 */
function isCollateralAsset(assetId: string): boolean {
  return assetId === COLLATERAL_ASSET_ID;
}

/**
 * Parsed trade from OrderFilledEvent
 */
export interface ParsedTrade {
  timestamp: number;
  user: string;
  role: 'maker' | 'taker';
  side: 'BUY' | 'SELL';
  tokenId: string;          // Outcome token ID
  tokenAmount: number;      // Outcome token 数量
  usdcAmount: number;       // USDC 数量
  price: number;            // 价格 (USDC per token)
}

/**
 * Position tracking for PnL calculation
 */
export interface TokenPosition {
  tokenId: string;
  amount: number;           // 当前持仓数量
  avgCost: number;          // 平均成本
  totalCost: number;        // 总成本
  realizedPnl: number;      // 已实现盈亏
}

/**
 * User stats with PnL
 */
export interface UserPeriodStats {
  address: string;
  volume: number;           // 总 USDC 成交量
  tradeCount: number;
  buyCount: number;
  sellCount: number;
  buyVolume: number;        // 买入 USDC 量
  sellVolume: number;       // 卖出 USDC 量
  realizedPnl: number;      // 已实现盈亏
  unrealizedPnl: number;    // 未实现盈亏 (需要当前价格)
  positions: Map<string, TokenPosition>;  // 各 token 持仓
}

export interface PeriodLeaderboardEntry {
  address: string;
  rank: number;
  // Core metrics from official API
  volume: number;           // 时间段内成交量 (USDC)
  pnl: number;              // 时间段内盈亏 (USDC) - 官方 API 提供
  // PnL breakdown (官方 API 不区分已实现/未实现)
  totalPnl: number;         // 总盈亏 = pnl
  realizedPnl: number;      // 已实现盈亏
  unrealizedPnl: number;    // 未实现盈亏
  // 交易统计 (部分来自官方 API)
  tradeCount: number;       // 时间段内成交次数
  buyCount: number;         // 买入次数
  sellCount: number;        // 卖出次数
  buyVolume: number;        // 买入金额
  sellVolume: number;       // 卖出金额
  // 兼容旧字段
  makerVolume: number;
  takerVolume: number;
  // 用户资料 (来自官方 API)
  userName?: string;
  profileImage?: string;
  // 社交信息 (来自官方 API)
  xUsername?: string;       // Twitter/X 用户名
  verifiedBadge?: boolean;  // 是否已验证
}

/**
 * Leaderboard result with proper semantics
 *
 * Note: Polymarket API doesn't return total count.
 */
export interface PeriodLeaderboardResult {
  /** Leaderboard entries returned by the API */
  entries: PeriodLeaderboardEntry[];
  /** Whether there may be more entries (entries.length === request.limit) */
  hasMore: boolean;
  /** Echo of request parameters for pagination convenience */
  request: {
    offset: number;
    limit: number;
  };
}

export interface WalletPeriodStats {
  address: string;
  period: TimePeriod;
  startTime: number;        // Unix timestamp
  endTime: number;          // Unix timestamp
  // 成交统计
  volume: number;           // 总成交量 (USDC)
  tradeCount: number;       // 成交次数
  makerVolume: number;
  takerVolume: number;
  makerCount: number;
  takerCount: number;
  // 活动统计
  splitCount: number;
  mergeCount: number;
  redemptionCount: number;
  redemptionPayout: number; // 赎回金额
}

export interface WalletProfile {
  address: string;
  totalPnL: number;
  realizedPnL: number;
  unrealizedPnL: number;
  avgPercentPnL: number;
  positionCount: number;
  tradeCount: number;
  smartScore: number; // 0-100
  lastActiveAt: Date;
}

export interface WalletActivityOptions {
  /** Maximum number of activities to return */
  limit?: number;
  /** Pagination offset */
  offset?: number;
  /** Start timestamp (Unix seconds) - filter activities after this time */
  start?: number;
  /** End timestamp (Unix seconds) - filter activities before this time */
  end?: number;
  /** Filter by activity type */
  type?: 'TRADE' | 'SPLIT' | 'MERGE' | 'REDEEM' | 'REWARD' | 'CONVERSION';
  /** Filter by trade side */
  side?: 'BUY' | 'SELL';
  /** Filter by market conditionId */
  market?: string;
  /** Fetch all activities with auto-pagination (up to maxItems) */
  fetchAll?: boolean;
  /** Maximum items when fetchAll=true (default 10000) */
  maxItems?: number;
}

export interface WalletActivitySummary {
  address: string;
  activities: Activity[];
  summary: {
    totalBuys: number;
    totalSells: number;
    buyVolume: number;
    sellVolume: number;
    activeMarkets: string[];
  };
  /** Time range of returned activities */
  timeRange?: {
    earliest: Date;
    latest: Date;
  };
}

export interface SellActivityResult {
  totalSellAmount: number;
  sellTransactions: Activity[];
  sellRatio: number;
  shouldExit: boolean;
}

export class WalletService {
  constructor(
    private dataApi: DataApiClient,
    private subgraph: SubgraphClient,
    private cache: UnifiedCache
  ) {}

  // ===== Time Period Helpers =====

  /**
   * Get start timestamp for a time period
   */
  private getPeriodStartTime(period: TimePeriod): number {
    const now = Math.floor(Date.now() / 1000);
    switch (period) {
      case 'day':
        return now - 24 * 60 * 60;
      case 'week':
        return now - 7 * 24 * 60 * 60;
      case 'month':
        return now - 30 * 24 * 60 * 60;
      case 'all':
        return 0;
    }
  }

  // ===== Wallet Analysis =====

  /**
   * Get comprehensive wallet profile with PnL analysis
   */
  async getWalletProfile(address: string): Promise<WalletProfile> {
    const [positions, activities] = await Promise.all([
      this.dataApi.getPositions(address),
      this.dataApi.getActivity(address, { limit: 100 }),
    ]);

    const totalPnL = positions.reduce((sum, p) => sum + (p.cashPnl || 0), 0);
    const realizedPnL = positions.reduce((sum, p) => sum + (p.realizedPnl || 0), 0);
    const unrealizedPnL = totalPnL - realizedPnL;

    const avgPercentPnL =
      positions.length > 0
        ? positions.reduce((sum, p) => sum + (p.percentPnl || 0), 0) / positions.length
        : 0;

    const lastActivity = activities[0];

    return {
      address,
      totalPnL,
      realizedPnL,
      unrealizedPnL,
      avgPercentPnL,
      positionCount: positions.length,
      tradeCount: activities.filter((a) => a.type === 'TRADE').length,
      smartScore: this.calculateSmartScore(positions, activities),
      lastActiveAt: lastActivity ? new Date(lastActivity.timestamp) : new Date(0),
    };
  }

  /**
   * Get positions for a wallet
   */
  async getWalletPositions(address: string): Promise<Position[]> {
    return this.dataApi.getPositions(address);
  }

  /**
   * Get positions for a specific market
   */
  async getPositionsForMarket(address: string, conditionId: string): Promise<Position[]> {
    const positions = await this.dataApi.getPositions(address);
    return positions.filter((p) => p.conditionId === conditionId);
  }

  /**
   * Get wallet activity with summary
   *
   * @param address - Wallet address
   * @param options - Activity query options (limit, start, end, type, side, market, fetchAll)
   *
   * @example
   * ```typescript
   * // Get recent 100 activities
   * const activity = await walletService.getWalletActivity(address);
   *
   * // Get activities from past week
   * const oneWeekAgo = Math.floor(Date.now() / 1000) - 7 * 24 * 60 * 60;
   * const weekActivity = await walletService.getWalletActivity(address, { start: oneWeekAgo });
   *
   * // Get all activities (auto-pagination, up to API limit)
   * const allActivity = await walletService.getWalletActivity(address, { fetchAll: true });
   * ```
   */
  async getWalletActivity(
    address: string,
    options: WalletActivityOptions | number = 100
  ): Promise<WalletActivitySummary> {
    // Support legacy signature: getWalletActivity(address, limit)
    const opts: WalletActivityOptions =
      typeof options === 'number' ? { limit: options } : options;

    let activities: Activity[];

    if (opts.fetchAll) {
      // Use getAllActivity for complete history with auto-pagination
      activities = await this.dataApi.getAllActivity(
        address,
        {
          start: opts.start,
          end: opts.end,
          type: opts.type,
          side: opts.side,
          market: opts.market ? [opts.market] : undefined,
        },
        opts.maxItems || 10000
      );
    } else {
      // Use getActivity for single page
      activities = await this.dataApi.getActivity(address, {
        limit: opts.limit || 100,
        offset: opts.offset,
        start: opts.start,
        end: opts.end,
        type: opts.type,
        side: opts.side,
        market: opts.market ? [opts.market] : undefined,
      });
    }

    const buys = activities.filter((a) => a.side === 'BUY');
    const sells = activities.filter((a) => a.side === 'SELL');

    // Calculate time range
    let timeRange: { earliest: Date; latest: Date } | undefined;
    if (activities.length > 0) {
      const timestamps = activities.map((a) => a.timestamp);
      timeRange = {
        earliest: new Date(Math.min(...timestamps)),
        latest: new Date(Math.max(...timestamps)),
      };
    }

    return {
      address,
      activities,
      summary: {
        totalBuys: buys.length,
        totalSells: sells.length,
        buyVolume: buys.reduce((sum, a) => sum + (a.usdcSize || 0), 0),
        sellVolume: sells.reduce((sum, a) => sum + (a.usdcSize || 0), 0),
        activeMarkets: [...new Set(activities.map((a) => a.conditionId))],
      },
      timeRange,
    };
  }

  // ===== Wallet Discovery =====

  /**
   * Get leaderboard
   */
  async getLeaderboard(page = 0, pageSize = 50): Promise<LeaderboardResult> {
    return this.dataApi.fetchLeaderboard({ limit: pageSize, offset: page * pageSize });
  }

  /**
   * Get top traders from leaderboard
   */
  async getTopTraders(limit = 10): Promise<LeaderboardEntry[]> {
    const result = await this.dataApi.fetchLeaderboard({ limit });
    return result.entries;
  }

  // ===== Time-Based Leaderboard =====

  /**
   * Get leaderboard by time period using official Polymarket API
   *
   * Uses the official Data API which supports time period filtering.
   * This is the recommended method as it uses server-side calculations.
   *
   * @param period - Time period: 'day', 'week', 'month', or 'all'
   * @param limit - Maximum entries to return (default: 50, max: 50)
   * @param sortBy - Sort criteria: 'volume' or 'pnl' (default: 'pnl')
   * @param category - Market category filter (default: 'OVERALL')
   *
   * @example
   * ```typescript
   * // Get top traders of the week by PnL
   * const weeklyByPnl = await walletService.getLeaderboardByPeriod('week', 20, 'pnl');
   *
   * // Get top traders by volume
   * const weeklyByVolume = await walletService.getLeaderboardByPeriod('week', 20, 'volume');
   *
   * // Get politics category leaderboard
   * const politics = await walletService.getLeaderboardByPeriod('week', 20, 'pnl', 'POLITICS');
   * ```
   */
  async getLeaderboardByPeriod(
    period: TimePeriod,
    limit = 50,
    sortBy: LeaderboardSortBy = 'pnl',
    category: LeaderboardCategory = 'OVERALL',
    offset = 0
  ): Promise<PeriodLeaderboardEntry[]> {
    // Map lowercase period to API's uppercase format
    const timePeriodMap: Record<TimePeriod, LeaderboardTimePeriod> = {
      day: 'DAY',
      week: 'WEEK',
      month: 'MONTH',
      all: 'ALL',
    };

    // Map sortBy to API's orderBy format
    const orderByMap: Record<LeaderboardSortBy, LeaderboardOrderBy> = {
      volume: 'VOL',
      pnl: 'PNL',
    };

    const timePeriod = timePeriodMap[period];
    const orderBy = orderByMap[sortBy];

    // Use official API
    const result = await this.dataApi.fetchLeaderboard({
      timePeriod,
      orderBy,
      category,
      limit,
      offset,
    });

    // Map to PeriodLeaderboardEntry format
    return result.entries.map((entry: LeaderboardEntry, index: number) => ({
      address: entry.address,
      rank: entry.rank || index + 1,
      volume: entry.volume,
      pnl: entry.pnl,
      // API provides combined PnL, set as total
      totalPnl: entry.pnl,
      realizedPnl: entry.pnl, // API doesn't separate realized/unrealized
      unrealizedPnl: 0,
      // API doesn't provide these breakdowns
      tradeCount: entry.trades || 0,
      buyCount: 0,
      sellCount: 0,
      buyVolume: 0,
      sellVolume: 0,
      makerVolume: 0,
      takerVolume: 0,
      // User profile
      userName: entry.userName,
      profileImage: entry.profileImage,
    }));
  }

  /**
   * Get leaderboard by time period with pagination info
   *
   * Same as getLeaderboardByPeriod but returns pagination metadata.
   *
   * @param period - Time period: 'day', 'week', 'month', or 'all'
   * @param limit - Maximum entries to return (default: 50, max: 500)
   * @param sortBy - Sort by 'pnl' or 'volume' (default: 'pnl')
   * @param category - Market category filter (default: 'OVERALL')
   * @param offset - Pagination offset (default: 0)
   *
   * @example
   * ```typescript
   * const result = await walletService.fetchLeaderboardByPeriod('week', 20, 'pnl', 'OVERALL', 0);
   * console.log(`Showing ${result.entries.length}, hasMore: ${result.hasMore}`);
   * ```
   */
  async fetchLeaderboardByPeriod(
    period: TimePeriod,
    limit = 50,
    sortBy: LeaderboardSortBy = 'pnl',
    category: LeaderboardCategory = 'OVERALL',
    offset = 0
  ): Promise<PeriodLeaderboardResult> {
    // Map lowercase period to API's uppercase format
    const timePeriodMap: Record<TimePeriod, LeaderboardTimePeriod> = {
      day: 'DAY',
      week: 'WEEK',
      month: 'MONTH',
      all: 'ALL',
    };

    // Map sortBy to API's orderBy format
    const orderByMap: Record<LeaderboardSortBy, LeaderboardOrderBy> = {
      volume: 'VOL',
      pnl: 'PNL',
    };

    const timePeriod = timePeriodMap[period];
    const orderBy = orderByMap[sortBy];

    // Use official API with new fetchLeaderboard method
    const result = await this.dataApi.fetchLeaderboard({
      timePeriod,
      orderBy,
      category,
      limit,
      offset,
    });

    // Map to PeriodLeaderboardEntry format
    const entries = result.entries.map((entry, index) => ({
      address: entry.address,
      rank: entry.rank || offset + index + 1,
      volume: entry.volume,
      pnl: entry.pnl,
      totalPnl: entry.pnl,
      realizedPnl: entry.pnl,
      unrealizedPnl: 0,
      tradeCount: entry.trades || 0,
      buyCount: 0,
      sellCount: 0,
      buyVolume: 0,
      sellVolume: 0,
      makerVolume: 0,
      takerVolume: 0,
      userName: entry.userName,
      profileImage: entry.profileImage,
      xUsername: entry.xUsername,
      verifiedBadge: entry.verifiedBadge,
    }));

    return {
      entries,
      hasMore: result.hasMore,
      request: result.request,
    };
  }

  /**
   * Get a specific user's PnL and ranking for a time period
   *
   * Uses the official Data API's user filter to get a single user's stats.
   *
   * @param address - User's wallet address
   * @param period - Time period: 'day', 'week', 'month', or 'all'
   * @param category - Market category filter (default: 'OVERALL')
   *
   * @example
   * ```typescript
   * // Get user's weekly PnL
   * const stats = await walletService.getUserPeriodPnl(address, 'week');
   * console.log(`Rank: #${stats.rank}, PnL: $${stats.pnl}`);
   *
   * // Get user's monthly PnL in politics category
   * const politicsStats = await walletService.getUserPeriodPnl(address, 'month', 'POLITICS');
   * ```
   */
  async getUserPeriodPnl(
    address: string,
    period: TimePeriod,
    category: LeaderboardCategory = 'OVERALL'
  ): Promise<PeriodLeaderboardEntry | null> {
    // Map lowercase period to API's uppercase format
    const timePeriodMap: Record<TimePeriod, LeaderboardTimePeriod> = {
      day: 'DAY',
      week: 'WEEK',
      month: 'MONTH',
      all: 'ALL',
    };

    const timePeriod = timePeriodMap[period];

    // Use official API with user filter
    const result = await this.dataApi.fetchLeaderboard({
      timePeriod,
      orderBy: 'PNL',
      category,
      user: address,
      limit: 1,
    });

    if (result.entries.length === 0) {
      return null;
    }

    const entry = result.entries[0];
    return {
      address: entry.address,
      rank: entry.rank || 0,
      volume: entry.volume,
      pnl: entry.pnl,
      totalPnl: entry.pnl,
      realizedPnl: entry.pnl,
      unrealizedPnl: 0,
      tradeCount: entry.trades || 0,
      buyCount: 0,
      sellCount: 0,
      buyVolume: 0,
      sellVolume: 0,
      makerVolume: 0,
      takerVolume: 0,
      userName: entry.userName,
      profileImage: entry.profileImage,
    };
  }

  /**
   * Get wallet stats for a specific time period
   *
   * Combines data from Orderbook Subgraph (trades) and Activity Subgraph (splits/merges/redemptions)
   *
   * @param address - Wallet address
   * @param period - Time period: 'day', 'week', 'month', or 'all'
   *
   * @example
   * ```typescript
   * // Get wallet's monthly stats
   * const stats = await walletService.getWalletStatsByPeriod(address, 'month');
   * console.log(`Monthly volume: $${stats.volume}`);
   * ```
   */
  async getWalletStatsByPeriod(
    address: string,
    period: TimePeriod
  ): Promise<WalletPeriodStats> {
    const startTime = this.getPeriodStartTime(period);
    const endTime = Math.floor(Date.now() / 1000);
    const cacheKey = `wallet:stats:${address}:${period}`;

    return this.cache.getOrSet(cacheKey, CACHE_TTL.ACTIVITY, async () => {
      // Fetch data in parallel
      const [makerFills, takerFills, splits, merges, redemptions] = await Promise.all([
        this.subgraph.getMakerFills(address, {
          first: 1000,
          where: { timestamp_gte: String(startTime) },
        }),
        this.subgraph.getTakerFills(address, {
          first: 1000,
          where: { timestamp_gte: String(startTime) },
        }),
        this.subgraph.getSplits(address, {
          first: 500,
          where: { timestamp_gte: String(startTime) },
        }),
        this.subgraph.getMerges(address, {
          first: 500,
          where: { timestamp_gte: String(startTime) },
        }),
        this.subgraph.getRedemptions(address, {
          first: 500,
          where: { timestamp_gte: String(startTime) },
        }),
      ]);

      // Calculate volumes (amounts are in micro-units, divide by 1e6 for USDC)
      const makerVolume = makerFills.reduce(
        (sum, f) => sum + Number(f.makerAmountFilled) / 1e6,
        0
      );
      const takerVolume = takerFills.reduce(
        (sum, f) => sum + Number(f.takerAmountFilled) / 1e6,
        0
      );
      const redemptionPayout = redemptions.reduce(
        (sum, r) => sum + Number(r.payout) / 1e6,
        0
      );

      return {
        address,
        period,
        startTime,
        endTime,
        volume: makerVolume + takerVolume,
        tradeCount: makerFills.length + takerFills.length,
        makerVolume,
        takerVolume,
        makerCount: makerFills.length,
        takerCount: takerFills.length,
        splitCount: splits.length,
        mergeCount: merges.length,
        redemptionCount: redemptions.length,
        redemptionPayout,
      };
    });
  }

  /**
   * Fetch all order filled events in a time period with pagination
   */
  private async fetchAllFillsInPeriod(
    startTime: number,
    maxItems = 5000
  ): Promise<OrderFilledEvent[]> {
    const allFills: OrderFilledEvent[] = [];
    let skip = 0;
    const first = 1000;

    while (allFills.length < maxItems) {
      const fills = await this.subgraph.getOrderFilledEvents({
        first,
        skip,
        where: startTime > 0 ? { timestamp_gte: String(startTime) } : undefined,
        orderBy: 'timestamp',
        orderDirection: 'desc',
      });

      if (fills.length === 0) break;

      allFills.push(...fills);
      skip += first;

      // Break if we got less than requested (no more data)
      if (fills.length < first) break;
    }

    return allFills.slice(0, maxItems);
  }

  /**
   * Parse OrderFilledEvent into user trades
   *
   * OrderFilledEvent 结构:
   * - makerAssetId = "0" (USDC): Maker 卖 USDC = BUY outcome token
   * - makerAssetId = 长数字: Maker 卖 outcome token = SELL
   */
  private parseOrderFilledEvent(fill: OrderFilledEvent): ParsedTrade[] {
    const timestamp = Number(fill.timestamp);
    const makerSellsCollateral = isCollateralAsset(fill.makerAssetId);

    if (makerSellsCollateral) {
      // Maker: 卖 USDC, 买 Outcome Token = BUY
      // Taker: 卖 Outcome Token, 买 USDC = SELL
      const usdcAmount = Number(fill.makerAmountFilled) / 1e6;
      const tokenAmount = Number(fill.takerAmountFilled) / 1e6;
      const price = tokenAmount > 0 ? usdcAmount / tokenAmount : 0;
      const tokenId = fill.takerAssetId;

      return [
        {
          timestamp,
          user: fill.maker.toLowerCase(),
          role: 'maker',
          side: 'BUY',
          tokenId,
          tokenAmount,
          usdcAmount,
          price,
        },
        {
          timestamp,
          user: fill.taker.toLowerCase(),
          role: 'taker',
          side: 'SELL',
          tokenId,
          tokenAmount,
          usdcAmount,
          price,
        },
      ];
    } else {
      // Maker: 卖 Outcome Token, 买 USDC = SELL
      // Taker: 卖 USDC, 买 Outcome Token = BUY
      const tokenAmount = Number(fill.makerAmountFilled) / 1e6;
      const usdcAmount = Number(fill.takerAmountFilled) / 1e6;
      const price = tokenAmount > 0 ? usdcAmount / tokenAmount : 0;
      const tokenId = fill.makerAssetId;

      return [
        {
          timestamp,
          user: fill.maker.toLowerCase(),
          role: 'maker',
          side: 'SELL',
          tokenId,
          tokenAmount,
          usdcAmount,
          price,
        },
        {
          timestamp,
          user: fill.taker.toLowerCase(),
          role: 'taker',
          side: 'BUY',
          tokenId,
          tokenAmount,
          usdcAmount,
          price,
        },
      ];
    }
  }

  /**
   * Update position with a trade and calculate realized PnL
   *
   * 买入: 增加持仓，更新平均成本
   * 卖出: 减少持仓，计算已实现盈亏 = 卖出收入 - 成本基础
   */
  private updatePositionWithTrade(
    position: TokenPosition,
    trade: ParsedTrade
  ): TokenPosition {
    if (trade.side === 'BUY') {
      // 买入：增加持仓，更新平均成本
      const newAmount = position.amount + trade.tokenAmount;
      const newTotalCost = position.totalCost + trade.usdcAmount;
      const newAvgCost = newAmount > 0 ? newTotalCost / newAmount : 0;

      return {
        ...position,
        amount: newAmount,
        totalCost: newTotalCost,
        avgCost: newAvgCost,
      };
    } else {
      // 卖出：减少持仓，计算已实现盈亏
      const sellAmount = Math.min(trade.tokenAmount, position.amount);
      const costBasis = sellAmount * position.avgCost;
      const revenue = (sellAmount / trade.tokenAmount) * trade.usdcAmount;
      const realizedPnl = revenue - costBasis;

      const newAmount = position.amount - sellAmount;
      const newTotalCost = newAmount > 0 ? newAmount * position.avgCost : 0;

      return {
        ...position,
        amount: newAmount,
        totalCost: newTotalCost,
        realizedPnl: position.realizedPnl + realizedPnl,
      };
    }
  }

  /**
   * Calculate unrealized PnL for a position
   *
   * 未实现盈亏 = 当前市值 - 总成本
   * 假设当前价格约等于最后交易价格 (简化处理)
   */
  private calculateUnrealizedPnl(position: TokenPosition, lastPrice: number): number {
    if (position.amount <= 0) return 0;
    const currentValue = position.amount * lastPrice;
    return currentValue - position.totalCost;
  }

  /**
   * Aggregate user statistics with PnL calculation from order filled events
   *
   * 核心计算流程:
   * 1. 解析 OrderFilledEvent 为标准化的 ParsedTrade
   * 2. 按时间顺序处理每笔交易
   * 3. 追踪每个用户每个 token 的持仓和平均成本
   * 4. 卖出时计算已实现盈亏
   * 5. 期末计算未实现盈亏
   */
  private aggregateUserStatsWithPnl(
    fills: OrderFilledEvent[]
  ): Map<string, UserPeriodStats> {
    const userStats = new Map<string, UserPeriodStats>();
    const lastPrices = new Map<string, number>(); // 记录每个 token 的最后交易价格

    // 初始化用户统计
    const getOrCreateUserStats = (address: string): UserPeriodStats => {
      let stats = userStats.get(address);
      if (!stats) {
        stats = {
          address,
          volume: 0,
          tradeCount: 0,
          buyCount: 0,
          sellCount: 0,
          buyVolume: 0,
          sellVolume: 0,
          realizedPnl: 0,
          unrealizedPnl: 0,
          positions: new Map(),
        };
        userStats.set(address, stats);
      }
      return stats;
    };

    // 解析所有交易
    const allTrades: ParsedTrade[] = [];
    for (const fill of fills) {
      const trades = this.parseOrderFilledEvent(fill);
      allTrades.push(...trades);
    }

    // 按时间排序 (升序，确保正确计算成本基础)
    allTrades.sort((a, b) => a.timestamp - b.timestamp);

    // 处理每笔交易
    for (const trade of allTrades) {
      const stats = getOrCreateUserStats(trade.user);

      // 更新交易统计
      stats.volume += trade.usdcAmount;
      stats.tradeCount += 1;

      if (trade.side === 'BUY') {
        stats.buyCount += 1;
        stats.buyVolume += trade.usdcAmount;
      } else {
        stats.sellCount += 1;
        stats.sellVolume += trade.usdcAmount;
      }

      // 更新持仓和计算已实现 PnL
      let position = stats.positions.get(trade.tokenId);
      if (!position) {
        position = {
          tokenId: trade.tokenId,
          amount: 0,
          avgCost: 0,
          totalCost: 0,
          realizedPnl: 0,
        };
      }

      const oldRealizedPnl = position.realizedPnl;
      position = this.updatePositionWithTrade(position, trade);
      stats.positions.set(trade.tokenId, position);

      // 累加已实现 PnL
      stats.realizedPnl += position.realizedPnl - oldRealizedPnl;

      // 记录最后价格
      if (trade.price > 0) {
        lastPrices.set(trade.tokenId, trade.price);
      }
    }

    // 计算每个用户的未实现 PnL
    for (const [, stats] of userStats) {
      let totalUnrealizedPnl = 0;
      for (const [tokenId, position] of stats.positions) {
        if (position.amount > 0) {
          const lastPrice = lastPrices.get(tokenId) || position.avgCost;
          totalUnrealizedPnl += this.calculateUnrealizedPnl(position, lastPrice);
        }
      }
      stats.unrealizedPnl = totalUnrealizedPnl;
    }

    return userStats;
  }

  /**
   * Discover active wallets from recent trades
   */
  async discoverActiveWallets(limit = 100): Promise<Array<{ address: string; tradeCount: number }>> {
    const trades = await this.dataApi.getTrades({ limit: 1000 });

    // Count trades per wallet
    const walletCounts = new Map<string, number>();
    for (const trade of trades) {
      if (trade.proxyWallet) {
        walletCounts.set(trade.proxyWallet, (walletCounts.get(trade.proxyWallet) || 0) + 1);
      }
    }

    // Sort by trade count
    return [...walletCounts.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([address, tradeCount]) => ({ address, tradeCount }));
  }

  // ===== Sell Detection (Follow Wallet Strategy) =====

  /**
   * Detect sell activity for a wallet in a specific market
   */
  async detectSellActivity(
    address: string,
    conditionId: string,
    sinceTimestamp: number,
    peakValue?: number
  ): Promise<SellActivityResult> {
    const activities = await this.dataApi.getActivity(address, { limit: 200, type: 'TRADE' });

    const sellTransactions = activities.filter(
      (a) => a.conditionId === conditionId && a.side === 'SELL' && a.timestamp >= sinceTimestamp
    );

    const totalSellAmount = sellTransactions.reduce((sum, a) => sum + (a.usdcSize || a.size * a.price), 0);

    // Calculate sell ratio if peak value is provided
    const sellRatio = peakValue && peakValue > 0 ? totalSellAmount / peakValue : 0;

    return {
      totalSellAmount,
      sellTransactions,
      sellRatio,
      shouldExit: sellRatio >= 0.3, // 30% threshold for exit signal
    };
  }

  /**
   * Track sell ratio for multiple wallets (aggregated)
   */
  async trackGroupSellRatio(
    addresses: string[],
    conditionId: string,
    peakTotalValue: number,
    sinceTimestamp: number
  ): Promise<{
    cumulativeSellAmount: number;
    sellRatio: number;
    shouldExit: boolean;
    walletSells: Array<{ address: string; sellAmount: number }>;
  }> {
    const walletSells: Array<{ address: string; sellAmount: number }> = [];
    let cumulativeSellAmount = 0;

    for (const address of addresses) {
      const sellData = await this.detectSellActivity(address, conditionId, sinceTimestamp);
      walletSells.push({ address, sellAmount: sellData.totalSellAmount });
      cumulativeSellAmount += sellData.totalSellAmount;
    }

    const sellRatio = peakTotalValue > 0 ? cumulativeSellAmount / peakTotalValue : 0;

    return {
      cumulativeSellAmount,
      sellRatio,
      shouldExit: sellRatio >= 0.3,
      walletSells,
    };
  }

  // ===== Smart Score Calculation =====

  private calculateSmartScore(positions: Position[], activities: Activity[]): number {
    // Weights: PnL 40%, Win Rate 30%, Consistency 20%, Activity 10%

    // PnL Score (0-40)
    const avgPnL =
      positions.length > 0
        ? positions.reduce((sum, p) => sum + (p.percentPnl || 0), 0) / positions.length
        : 0;
    const pnlScore = Math.min(40, Math.max(0, ((avgPnL + 50) / 100) * 40));

    // Win Rate Score (0-30)
    const winningPositions = positions.filter((p) => (p.cashPnl || 0) > 0).length;
    const winRate = positions.length > 0 ? winningPositions / positions.length : 0;
    const winRateScore = winRate * 30;

    // Consistency Score (0-20)
    const pnlValues = positions.map((p) => p.percentPnl || 0);
    const variance = this.calculateVariance(pnlValues);
    const consistencyScore = Math.max(0, 20 - variance / 10);

    // Activity Score (0-10)
    const recentTrades = activities.filter((a) => a.timestamp > Date.now() - 7 * 24 * 60 * 60 * 1000).length;
    const activityScore = Math.min(10, (recentTrades / 5) * 10);

    return Math.round(pnlScore + winRateScore + consistencyScore + activityScore);
  }

  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
  }
}

================================================================================
// File: src/utils/price-utils.ts
================================================================================
/**
 * Price Utilities for Polymarket Trading
 *
 * Provides helpers for:
 * - Price validation and rounding to tick size
 * - Size validation
 * - Order amount calculation
 */

// Tick size types (as defined by Polymarket)
export type TickSize = '0.1' | '0.01' | '0.001' | '0.0001';

// Rounding configuration for each tick size
export const ROUNDING_CONFIG: Record<
  TickSize,
  { price: number; size: number; amount: number }
> = {
  '0.1': { price: 1, size: 2, amount: 2 },
  '0.01': { price: 2, size: 2, amount: 4 },
  '0.001': { price: 3, size: 2, amount: 5 },
  '0.0001': { price: 4, size: 2, amount: 6 },
};

/**
 * Round a price to the appropriate tick size
 *
 * @param price - The price to round (0 to 1)
 * @param tickSize - The tick size for the market
 * @param direction - 'floor' for sells, 'ceil' for buys, 'round' for midpoint
 * @returns Rounded price
 *
 * @example
 * roundPrice(0.523, '0.01', 'floor') // 0.52
 * roundPrice(0.523, '0.01', 'ceil') // 0.53
 */
export function roundPrice(
  price: number,
  tickSize: TickSize,
  direction: 'floor' | 'ceil' | 'round' = 'round'
): number {
  const decimals = ROUNDING_CONFIG[tickSize].price;
  const multiplier = Math.pow(10, decimals);

  let rounded: number;
  switch (direction) {
    case 'floor':
      rounded = Math.floor(price * multiplier) / multiplier;
      break;
    case 'ceil':
      rounded = Math.ceil(price * multiplier) / multiplier;
      break;
    default:
      rounded = Math.round(price * multiplier) / multiplier;
  }

  // Clamp to valid price range
  return Math.max(0.001, Math.min(0.999, rounded));
}

/**
 * Round a size to valid decimals (always 2 decimal places)
 */
export function roundSize(size: number): number {
  return Math.round(size * 100) / 100;
}

/**
 * Validate a price is within valid range and tick size
 *
 * @param price - The price to validate
 * @param tickSize - The tick size for the market
 * @returns Validation result with error message if invalid
 */
export function validatePrice(
  price: number,
  tickSize: TickSize
): { valid: boolean; error?: string } {
  // Check range
  if (price < 0.001 || price > 0.999) {
    return { valid: false, error: 'Price must be between 0.001 and 0.999' };
  }

  // Check tick size alignment
  const decimals = ROUNDING_CONFIG[tickSize].price;
  const multiplier = Math.pow(10, decimals);
  const rounded = Math.round(price * multiplier) / multiplier;

  if (Math.abs(price - rounded) > 1e-10) {
    return {
      valid: false,
      error: `Price ${price} does not align with tick size ${tickSize}. Use ${rounded} instead.`,
    };
  }

  return { valid: true };
}

/**
 * Validate minimum size requirements
 *
 * @param size - The size to validate
 * @param minOrderSize - Minimum order size from market config (usually 0.1)
 */
export function validateSize(
  size: number,
  minOrderSize = 0.1
): { valid: boolean; error?: string } {
  if (size < minOrderSize) {
    return {
      valid: false,
      error: `Size ${size} is below minimum order size ${minOrderSize}`,
    };
  }

  return { valid: true };
}

/**
 * Calculate the amount needed for a buy order (in USDC)
 *
 * @param price - Price per share
 * @param size - Number of shares to buy
 * @returns Amount in USDC
 */
export function calculateBuyAmount(price: number, size: number): number {
  return price * size;
}

/**
 * Calculate the payout for a sell order (in USDC)
 *
 * @param price - Price per share
 * @param size - Number of shares to sell
 * @returns Amount in USDC
 */
export function calculateSellPayout(price: number, size: number): number {
  return price * size;
}

/**
 * Calculate number of shares that can be bought with a given amount
 *
 * @param amount - USDC amount to spend
 * @param price - Price per share
 * @returns Number of shares
 */
export function calculateSharesForAmount(
  amount: number,
  price: number
): number {
  return roundSize(amount / price);
}

/**
 * Calculate the spread between bid and ask
 *
 * @param bid - Highest bid price
 * @param ask - Lowest ask price
 * @returns Spread as a decimal (0 to 1)
 */
export function calculateSpread(bid: number, ask: number): number {
  return ask - bid;
}

/**
 * Calculate the midpoint price between bid and ask
 *
 * @param bid - Highest bid price
 * @param ask - Lowest ask price
 * @returns Midpoint price
 */
export function calculateMidpoint(bid: number, ask: number): number {
  return (bid + ask) / 2;
}

/**
 * 计算有效价格（考虑 Polymarket 订单簿的镜像特性）
 *
 * Polymarket 的关键特性：买 YES @ P = 卖 NO @ (1-P)
 * 因此同一订单会在两个订单簿中出现
 *
 * 有效价格是考虑镜像后的最优价格
 *
 * @param yesAsk - YES token 的最低卖价
 * @param yesBid - YES token 的最高买价
 * @param noAsk - NO token 的最低卖价
 * @param noBid - NO token 的最高买价
 */
export function getEffectivePrices(
  yesAsk: number,
  yesBid: number,
  noAsk: number,
  noBid: number
): {
  effectiveBuyYes: number;
  effectiveBuyNo: number;
  effectiveSellYes: number;
  effectiveSellNo: number;
} {
  return {
    // 买 YES: 直接买 YES.ask 或 通过卖 NO (成本 = 1 - NO.bid)
    effectiveBuyYes: Math.min(yesAsk, 1 - noBid),

    // 买 NO: 直接买 NO.ask 或 通过卖 YES (成本 = 1 - YES.bid)
    effectiveBuyNo: Math.min(noAsk, 1 - yesBid),

    // 卖 YES: 直接卖 YES.bid 或 通过买 NO (收入 = 1 - NO.ask)
    effectiveSellYes: Math.max(yesBid, 1 - noAsk),

    // 卖 NO: 直接卖 NO.bid 或 通过买 YES (收入 = 1 - YES.ask)
    effectiveSellNo: Math.max(noBid, 1 - yesAsk),
  };
}

/**
 * Check if there's an arbitrage opportunity
 *
 * 使用有效价格计算套利机会（正确考虑镜像订单）
 *
 * Long arb: Buy YES + Buy NO < 1 (使用有效买入价格)
 * Short arb: Sell YES + Sell NO > 1 (使用有效卖出价格)
 *
 * 详细文档见: docs/01-polymarket-orderbook-arbitrage.md
 *
 * @param yesAsk - Lowest ask for YES token
 * @param noAsk - Lowest ask for NO token
 * @param yesBid - Highest bid for YES token
 * @param noBid - Highest bid for NO token
 * @returns Arbitrage info or null
 */
export function checkArbitrage(
  yesAsk: number,
  noAsk: number,
  yesBid: number,
  noBid: number
): { type: 'long' | 'short'; profit: number; description: string } | null {
  // 计算有效价格
  const effective = getEffectivePrices(yesAsk, yesBid, noAsk, noBid);

  // Long arbitrage: Buy complete set (YES + NO) cheaper than $1
  const effectiveLongCost = effective.effectiveBuyYes + effective.effectiveBuyNo;
  const longProfit = 1 - effectiveLongCost;

  if (longProfit > 0) {
    return {
      type: 'long',
      profit: longProfit,
      description: `Buy YES @ ${effective.effectiveBuyYes.toFixed(4)} + NO @ ${effective.effectiveBuyNo.toFixed(4)}, Merge for $1`,
    };
  }

  // Short arbitrage: Sell complete set (YES + NO) for more than $1
  const effectiveShortRevenue = effective.effectiveSellYes + effective.effectiveSellNo;
  const shortProfit = effectiveShortRevenue - 1;

  if (shortProfit > 0) {
    return {
      type: 'short',
      profit: shortProfit,
      description: `Split $1, Sell YES @ ${effective.effectiveSellYes.toFixed(4)} + NO @ ${effective.effectiveSellNo.toFixed(4)}`,
    };
  }

  return null;
}

/**
 * Format price for display
 */
export function formatPrice(price: number, tickSize?: TickSize): string {
  const decimals = tickSize ? ROUNDING_CONFIG[tickSize].price : 4;
  return price.toFixed(decimals);
}

/**
 * Format amount in USDC
 */
export function formatUSDC(amount: number): string {
  return `$${amount.toFixed(2)}`;
}

/**
 * Calculate PnL for a position
 *
 * @param entryPrice - Average entry price
 * @param currentPrice - Current market price
 * @param size - Position size
 * @param side - 'long' for YES, 'short' for NO
 */
export function calculatePnL(
  entryPrice: number,
  currentPrice: number,
  size: number,
  side: 'long' | 'short' = 'long'
): { pnl: number; pnlPercent: number } {
  const pnl =
    side === 'long'
      ? (currentPrice - entryPrice) * size
      : (entryPrice - currentPrice) * size;

  const pnlPercent =
    side === 'long'
      ? ((currentPrice - entryPrice) / entryPrice) * 100
      : ((entryPrice - currentPrice) / entryPrice) * 100;

  return { pnl, pnlPercent };
}

